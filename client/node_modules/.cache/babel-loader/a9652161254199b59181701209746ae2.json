{"ast":null,"code":"import { autoTextColor, deepExtend, getTemplate, valueOrDefault } from '../../common';\nimport { CENTER, ROUNDED_RECT, BOTTOM, WHITE } from '../../common/constants';\nimport { ChartElement, Point, rectToBox, ShapeElement, TextBox } from '../../core';\nimport { TOOLTIP_OFFSET } from '../constants';\nimport NoteMixin from '../mixins/note-mixin';\nimport PointEventsMixin from '../mixins/point-events-mixin';\nvar HeatmapPoint = function (ChartElement) {\n  function HeatmapPoint(value, options) {\n    ChartElement.call(this);\n    this.options = options;\n    this.color = options.color || WHITE;\n    this.value = value;\n  }\n  if (ChartElement) HeatmapPoint.__proto__ = ChartElement;\n  HeatmapPoint.prototype = Object.create(ChartElement && ChartElement.prototype);\n  HeatmapPoint.prototype.constructor = HeatmapPoint;\n  HeatmapPoint.prototype.render = function render() {\n    if (this._rendered) {\n      return;\n    }\n    this._rendered = true;\n    this.createMarker();\n    this.createLabel();\n    this.createNote();\n  };\n  HeatmapPoint.prototype.createLabel = function createLabel() {\n    var options = this.options;\n    var labels = options.labels;\n    if (labels.visible) {\n      var pointData = this.pointData();\n      var labelTemplate = getTemplate(labels);\n      var labelText;\n      var labelColor = labels.color;\n      if (labelTemplate) {\n        labelText = labelTemplate(pointData);\n      } else {\n        labelText = this.formatValue(labels.format);\n      }\n      if (!labelColor) {\n        labelColor = autoTextColor(this.color);\n      }\n      this.label = new TextBox(labelText, deepExtend({\n        align: CENTER,\n        vAlign: CENTER,\n        margin: {\n          left: 5,\n          right: 5\n        },\n        zIndex: valueOrDefault(labels.zIndex, this.series.zIndex)\n      }, labels, {\n        color: labelColor\n      }), pointData);\n      this.append(this.label);\n    }\n  };\n  HeatmapPoint.prototype.formatValue = function formatValue(format) {\n    return this.owner.formatPointValue(this, format);\n  };\n  HeatmapPoint.prototype.reflow = function reflow(targetBox) {\n    this.render();\n    var label = this.label;\n    this.box = targetBox;\n    if (label) {\n      label.reflow(this.markerBox());\n    }\n    if (this.note) {\n      this.note.reflow(targetBox);\n    }\n    this.marker.reflow(this.markerBox());\n  };\n  HeatmapPoint.prototype.markerBox = function markerBox() {\n    var options = this.options;\n    var markers = options.markers;\n    var border = markers.border;\n    var rect = this.box.toRect();\n    var type = valueOrDefault(markers.type, 'rect');\n    var isRoundRect = type === ROUNDED_RECT;\n    var borderWidth = valueOrDefault(border.width, isRoundRect ? 1 : 0);\n    var halfBorderWidth = Math.round(borderWidth / 2);\n    if (markers.size) {\n      var center = rect.center();\n      rect.size.width = rect.size.height = markers.size;\n      rect.origin.x = Math.round(center.x - rect.size.width / 2);\n      rect.origin.y = Math.round(center.y - rect.size.height / 2);\n    }\n    rect.size.width -= borderWidth;\n    rect.size.height -= borderWidth;\n    rect.origin.y += halfBorderWidth + 0.5;\n    rect.origin.x += halfBorderWidth + 0.5;\n    return rectToBox(rect);\n  };\n  HeatmapPoint.prototype.markerBorder = function markerBorder() {\n    var options = this.options;\n    var markers = options.markers;\n    var border = markers.border;\n    var opacity = valueOrDefault(border.opacity, options.opacity);\n    return {\n      color: border.color || this.color,\n      width: border.width,\n      opacity: opacity,\n      dashType: border.dashType\n    };\n  };\n  HeatmapPoint.prototype.createMarker = function createMarker() {\n    var options = this.options;\n    var markerOptions = options.markers;\n    var marker = new ShapeElement({\n      type: valueOrDefault(markerOptions.type, 'rect'),\n      width: markerOptions.size,\n      height: markerOptions.size,\n      rotation: markerOptions.rotation,\n      background: this.color,\n      border: this.markerBorder(),\n      borderRadius: markerOptions.borderRadius,\n      opacity: this.series.opacity || options.opacity,\n      zIndex: valueOrDefault(options.zIndex, this.series.zIndex),\n      animation: options.animation,\n      visual: options.visual\n    }, {\n      dataItem: this.dataItem,\n      value: this.value,\n      series: this.series,\n      category: this.category\n    });\n    this.marker = marker;\n    this.append(marker);\n  };\n  HeatmapPoint.prototype.createHighlight = function createHighlight(style) {\n    var options = this.options;\n    var markerOptions = this.options.highlight.markers || this.options.markers;\n    var highlight = new ShapeElement({\n      type: valueOrDefault(markerOptions.type, 'rect'),\n      width: markerOptions.size,\n      height: markerOptions.size,\n      rotation: markerOptions.rotation,\n      background: markerOptions.color || this.color,\n      border: this.markerBorder(),\n      borderRadius: markerOptions.borderRadius,\n      opacity: this.series.opacity || options.opacity,\n      zIndex: valueOrDefault(options.zIndex, this.series.zIndex)\n    });\n    highlight.reflow(this.markerBox());\n    var visual = highlight.getElement();\n    visual.options.fill = style.fill;\n    visual.options.stroke = style.stroke;\n    return visual;\n  };\n  HeatmapPoint.prototype.highlightVisual = function highlightVisual() {\n    return this.rectVisual;\n  };\n  HeatmapPoint.prototype.highlightVisualArgs = function highlightVisualArgs() {\n    return {\n      options: this.options,\n      rect: this.box.toRect(),\n      visual: this.rectVisual\n    };\n  };\n  HeatmapPoint.prototype.tooltipAnchor = function tooltipAnchor() {\n    var left = this.box.center().x;\n    var top = this.box.y1 - TOOLTIP_OFFSET;\n    return {\n      point: new Point(left, top),\n      align: {\n        horizontal: CENTER,\n        vertical: BOTTOM\n      }\n    };\n  };\n  HeatmapPoint.prototype.overlapsBox = function overlapsBox(box) {\n    return this.box.overlaps(box);\n  };\n  HeatmapPoint.prototype.unclipElements = function unclipElements() {\n    /* noop, clip labels */\n  };\n  HeatmapPoint.prototype.pointData = function pointData() {\n    return {\n      x: this.value.x,\n      y: this.value.y,\n      value: this.value.value,\n      dataItem: this.dataItem,\n      series: this.series\n    };\n  };\n  return HeatmapPoint;\n}(ChartElement);\ndeepExtend(HeatmapPoint.prototype, PointEventsMixin);\ndeepExtend(HeatmapPoint.prototype, NoteMixin);\nHeatmapPoint.prototype.defaults = {\n  markers: {\n    type: 'rect',\n    borderRadius: 4,\n    border: {\n      color: 'transparent'\n    }\n  },\n  padding: {\n    top: 1\n  },\n  labels: {\n    visible: false,\n    padding: 3\n  },\n  opacity: 1,\n  notes: {\n    label: {}\n  }\n};\nexport default HeatmapPoint;","map":null,"metadata":{},"sourceType":"module"}
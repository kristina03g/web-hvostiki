{"ast":null,"code":"// todo: extract to a separate place\n\nimport { Class, deepExtend, addClass, isFunction, setDefaultOptions } from '../../common';\nimport { convertToHtml, prepend, wrapInner, contains, hasNativeScrolling, on, off, proxy, wheelDeltaY, setDefaultEvents } from '../utils';\nimport { Transition, Animation } from './fx';\nimport { Pane, PaneDimensions, Movable, TapCapture } from './draggable';\nimport { UserEvents } from './user-events';\nimport { Observable } from './observable';\nvar extend = Object.assign,\n  abs = Math.abs,\n  SNAPBACK_DURATION = 500,\n  SCROLLBAR_OPACITY = 0.7,\n  FRICTION = 0.96,\n  VELOCITY_MULTIPLIER = 10,\n  MAX_VELOCITY = 55,\n  OUT_OF_BOUNDS_FRICTION = 0.5,\n  ANIMATED_SCROLLER_PRECISION = 5,\n  // SCROLLER_RELEASE_CLASS = 'km-scroller-release',\n  // SCROLLER_REFRESH_CLASS = 'km-scroller-refresh',\n  PULL = 'pull',\n  CHANGE = 'change',\n  RESIZE = 'resize',\n  SCROLL = 'scroll',\n  MOUSE_WHEEL_ID = 2;\nvar ZoomSnapBack = function (Animation) {\n  function ZoomSnapBack(options) {\n    Animation.call(this, options);\n    var that = this;\n    extend(that, options);\n    that.userEvents.bind('gestureend', that.start.bind(this));\n    that.tapCapture.bind('press', that.cancel.bind(this));\n  }\n  if (Animation) ZoomSnapBack.__proto__ = Animation;\n  ZoomSnapBack.prototype = Object.create(Animation && Animation.prototype);\n  ZoomSnapBack.prototype.constructor = ZoomSnapBack;\n  ZoomSnapBack.prototype.enabled = function enabled() {\n    return this.movable.scale < this.dimensions.minScale;\n  };\n  ZoomSnapBack.prototype.done = function done() {\n    return this.dimensions.minScale - this.movable.scale < 0.01;\n  };\n  ZoomSnapBack.prototype.tick = function tick() {\n    var movable = this.movable;\n    movable.scaleWith(1.1);\n    this.dimensions.rescale(movable.scale);\n  };\n  ZoomSnapBack.prototype.onEnd = function onEnd() {\n    var movable = this.movable;\n    movable.scaleTo(this.dimensions.minScale);\n    this.dimensions.rescale(movable.scale);\n  };\n  return ZoomSnapBack;\n}(Animation);\nvar DragInertia = function (Animation) {\n  function DragInertia(options) {\n    Animation.call(this);\n    var that = this;\n    extend(that, options, {\n      transition: new Transition({\n        axis: options.axis,\n        movable: options.movable,\n        onEnd: function onEnd() {\n          that._end();\n        }\n      })\n    });\n    that.tapCapture.bind('press', function () {\n      that.cancel();\n    });\n    that.userEvents.bind('end', proxy(that.start, that));\n    that.userEvents.bind('gestureend', proxy(that.start, that));\n    that.userEvents.bind('tap', proxy(that.onEnd, that));\n  }\n  if (Animation) DragInertia.__proto__ = Animation;\n  DragInertia.prototype = Object.create(Animation && Animation.prototype);\n  DragInertia.prototype.constructor = DragInertia;\n  DragInertia.prototype.onCancel = function onCancel() {\n    this.transition.cancel();\n  };\n  DragInertia.prototype.freeze = function freeze(location) {\n    var that = this;\n    that.cancel();\n    that._moveTo(location);\n  };\n  DragInertia.prototype.onEnd = function onEnd() {\n    var that = this;\n    if (that.paneAxis.outOfBounds()) {\n      that._snapBack();\n    } else {\n      that._end();\n    }\n  };\n  DragInertia.prototype.done = function done() {\n    return abs(this.velocity) < 1;\n  };\n  DragInertia.prototype.start = function start(e) {\n    var that = this,\n      velocity;\n    if (!that.dimension.enabled) {\n      return;\n    }\n    if (that.paneAxis.outOfBounds()) {\n      if (that.transition._started) {\n        that.transition.cancel();\n        that.velocity = Math.min(e.touch[that.axis].velocity * that.velocityMultiplier, MAX_VELOCITY);\n        Animation.prototype.start.call(this);\n      } else {\n        that._snapBack();\n      }\n    } else {\n      velocity = e.touch.id === MOUSE_WHEEL_ID ? 0 : e.touch[that.axis].velocity;\n      that.velocity = Math.max(Math.min(velocity * that.velocityMultiplier, MAX_VELOCITY), -MAX_VELOCITY);\n      that.tapCapture.captureNext();\n      Animation.prototype.start.call(this);\n    }\n  };\n  DragInertia.prototype.tick = function tick() {\n    var that = this,\n      dimension = that.dimension,\n      friction = that.paneAxis.outOfBounds() ? OUT_OF_BOUNDS_FRICTION : that.friction,\n      delta = that.velocity *= friction,\n      location = that.movable[that.axis] + delta;\n    if (!that.elastic && dimension.outOfBounds(location)) {\n      location = Math.max(Math.min(location, dimension.max), dimension.min);\n      that.velocity = 0;\n    }\n    that.movable.moveAxis(that.axis, location);\n  };\n  DragInertia.prototype._end = function _end() {\n    this.tapCapture.cancelCapture();\n    this.end();\n  };\n  DragInertia.prototype._snapBack = function _snapBack() {\n    var that = this,\n      dimension = that.dimension,\n      snapBack = that.movable[that.axis] > dimension.max ? dimension.max : dimension.min;\n    that._moveTo(snapBack);\n  };\n  DragInertia.prototype._moveTo = function _moveTo(location) {\n    this.transition.moveTo({\n      location: location,\n      duration: SNAPBACK_DURATION,\n      ease: Transition.easeOutExpo\n    });\n  };\n  return DragInertia;\n}(Animation);\nvar AnimatedScroller = function (Animation) {\n  function AnimatedScroller(options) {\n    Animation.call(this, options);\n    var that = this;\n    extend(that, options, {\n      origin: {},\n      destination: {},\n      offset: {}\n    });\n  }\n  if (Animation) AnimatedScroller.__proto__ = Animation;\n  AnimatedScroller.prototype = Object.create(Animation && Animation.prototype);\n  AnimatedScroller.prototype.constructor = AnimatedScroller;\n  AnimatedScroller.prototype.tick = function tick() {\n    this._updateCoordinates();\n    this.moveTo(this.origin);\n  };\n  AnimatedScroller.prototype.done = function done() {\n    return abs(this.offset.y) < ANIMATED_SCROLLER_PRECISION && abs(this.offset.x) < ANIMATED_SCROLLER_PRECISION;\n  };\n  AnimatedScroller.prototype.onEnd = function onEnd() {\n    this.moveTo(this.destination);\n    if (this.callback) {\n      this.callback.call();\n    }\n  };\n  AnimatedScroller.prototype.setCoordinates = function setCoordinates(from, to) {\n    this.offset = {};\n    this.origin = from;\n    this.destination = to;\n  };\n\n  /* eslint-disable no-param-reassign */\n  AnimatedScroller.prototype.setCallback = function setCallback(callback) {\n    if (callback && isFunction(callback)) {\n      this.callback = callback;\n    } else {\n      callback = undefined;\n    }\n  };\n  /* eslint-enable no-param-reassign */\n\n  AnimatedScroller.prototype._updateCoordinates = function _updateCoordinates() {\n    this.offset = {\n      x: (this.destination.x - this.origin.x) / 4,\n      y: (this.destination.y - this.origin.y) / 4\n    };\n    this.origin = {\n      y: this.origin.y + this.offset.y,\n      x: this.origin.x + this.offset.x\n    };\n  };\n  return AnimatedScroller;\n}(Animation);\nvar ScrollBar = function (Class) {\n  function ScrollBar(options) {\n    Class.call(this);\n    var that = this,\n      horizontal = options.axis === 'x';\n    var orientation = horizontal ? 'horizontal' : 'vertical';\n    var element = convertToHtml('<div class=\"km-touch-scrollbar km-' + orientation + '-scrollbar\" />');\n    extend(that, options, {\n      element: element,\n      elementSize: 0,\n      movable: new Movable(element),\n      scrollMovable: options.movable,\n      alwaysVisible: options.alwaysVisible,\n      size: horizontal ? 'width' : 'height'\n    });\n    that.scrollMovable.bind(CHANGE, that.refresh.bind(that));\n    that.container.appendChild(element);\n    if (options.alwaysVisible) {\n      that.show();\n    }\n  }\n  if (Class) ScrollBar.__proto__ = Class;\n  ScrollBar.prototype = Object.create(Class && Class.prototype);\n  ScrollBar.prototype.constructor = ScrollBar;\n  ScrollBar.prototype.refresh = function refresh() {\n    var that = this,\n      axis = that.axis,\n      dimension = that.dimension,\n      paneSize = dimension.size,\n      scrollMovable = that.scrollMovable,\n      sizeRatio = paneSize / dimension.total,\n      position = Math.round(-scrollMovable[axis] * sizeRatio),\n      size = Math.round(paneSize * sizeRatio);\n    if (sizeRatio >= 1) {\n      this.element.style.display = \"none\";\n    } else {\n      this.element.style.display = \"\";\n    }\n    if (position + size > paneSize) {\n      size = paneSize - position;\n    } else if (position < 0) {\n      size += position;\n      position = 0;\n    }\n    if (that.elementSize !== size) {\n      that.element.style[that.size] = size + 'px';\n      that.elementSize = size;\n    }\n    that.movable.moveAxis(axis, position);\n  };\n  ScrollBar.prototype.show = function show() {\n    this.element.style.opacity = SCROLLBAR_OPACITY;\n    this.element.style.visibility = \"visible\";\n  };\n  ScrollBar.prototype.hide = function hide() {\n    if (!this.alwaysVisible) {\n      this.element.style.opacity = 0;\n    }\n  };\n  return ScrollBar;\n}(Class);\n\n// export class Scroller extends Class {\nexport var Scroller = function (Observable) {\n  function Scroller(element, options) {\n    Observable.call(this);\n    var that = this;\n    this.element = element;\n    this._initOptions(options);\n    var hasScrolling = hasNativeScrolling(navigator.userAgent);\n    that._native = that.options.useNative && hasScrolling;\n    var scrollHeader = convertToHtml('<div class=\"km-scroll-header\"/>');\n    if (that._native) {\n      addClass(element, 'km-native-scroller');\n      prepend(scrollHeader, element);\n      extend(that, {\n        scrollElement: element,\n        fixedContainer: element.children[0]\n      });\n      return;\n    }\n    element.style.overflow = \"hidden\";\n    addClass(element, 'km-scroll-wrapper');\n    var scrollContainer = convertToHtml('<div class=\"km-scroll-container\"/>');\n    wrapInner(element, scrollContainer);\n    prepend(scrollHeader, element);\n    var inner = element.children[1],\n      tapCapture = new TapCapture(element),\n      movable = new Movable(inner),\n      dimensions = new PaneDimensions({\n        element: inner,\n        container: element,\n        forcedEnabled: that.options.zoom\n      }),\n      avoidScrolling = this.options.avoidScrolling,\n      userEvents = new UserEvents(element, {\n        touchAction: 'pan-y',\n        fastTap: true,\n        allowSelection: true,\n        preventDragEvent: true,\n        captureUpIfMoved: true,\n        multiTouch: that.options.zoom,\n        supportDoubleTap: that.options.supportDoubleTap,\n        start: function start(e) {\n          dimensions.refresh();\n          var velocityX = abs(e.x.velocity),\n            velocityY = abs(e.y.velocity),\n            horizontalSwipe = velocityX * 2 >= velocityY,\n            originatedFromFixedContainer = contains(that.fixedContainer, e.event.target),\n            verticalSwipe = velocityY * 2 >= velocityX;\n          if (!originatedFromFixedContainer && !avoidScrolling(e) && that.enabled && (dimensions.x.enabled && horizontalSwipe || dimensions.y.enabled && verticalSwipe)) {\n            userEvents.capture();\n          } else {\n            userEvents.cancel();\n          }\n        }\n      }),\n      pane = new Pane({\n        movable: movable,\n        dimensions: dimensions,\n        userEvents: userEvents,\n        elastic: that.options.elastic\n      }),\n      zoomSnapBack = new ZoomSnapBack({\n        movable: movable,\n        dimensions: dimensions,\n        userEvents: userEvents,\n        tapCapture: tapCapture\n      }),\n      animatedScroller = new AnimatedScroller({\n        moveTo: function moveTo(coordinates) {\n          that.scrollTo(coordinates.x, coordinates.y);\n        }\n      });\n    movable.bind(CHANGE, function () {\n      that.scrollTop = -movable.y;\n      that.scrollLeft = -movable.x;\n      that.trigger(SCROLL, {\n        scrollTop: that.scrollTop,\n        scrollLeft: that.scrollLeft\n      });\n    });\n    if (that.options.mousewheelScrolling) {\n      this._wheelScrollHandler = this._wheelScroll.bind(this);\n      on(element, 'wheel', this._wheelScrollHandler);\n    }\n    extend(that, {\n      movable: movable,\n      dimensions: dimensions,\n      zoomSnapBack: zoomSnapBack,\n      animatedScroller: animatedScroller,\n      userEvents: userEvents,\n      pane: pane,\n      tapCapture: tapCapture,\n      pulled: false,\n      enabled: true,\n      scrollElement: inner,\n      scrollTop: 0,\n      scrollLeft: 0,\n      fixedContainer: element.children[0]\n    });\n    that._initAxis('x');\n    that._initAxis('y');\n    that._wheelEnd = function () {\n      that._wheel = false;\n      that.userEvents.end(0, that._wheelY);\n    };\n    dimensions.refresh();\n    if (that.options.pullToRefresh) {\n      that._initPullToRefresh();\n    }\n  }\n  if (Observable) Scroller.__proto__ = Observable;\n  Scroller.prototype = Object.create(Observable && Observable.prototype);\n  Scroller.prototype.constructor = Scroller;\n  Scroller.prototype._initOptions = function _initOptions(options) {\n    this.options = deepExtend({}, this.options, options);\n  };\n  Scroller.prototype._wheelScroll = function _wheelScroll(e) {\n    if (e.ctrlKey) {\n      return;\n    }\n    if (!this._wheel) {\n      this._wheel = true;\n      this._wheelY = 0;\n      this.userEvents.press(0, this._wheelY);\n    }\n    clearTimeout(this._wheelTimeout);\n    this._wheelTimeout = setTimeout(this._wheelEnd, 50);\n    var delta = wheelDeltaY(e);\n    if (delta) {\n      this._wheelY += delta;\n      this.userEvents.move(0, this._wheelY);\n    }\n    e.preventDefault();\n  };\n  Scroller.prototype.makeVirtual = function makeVirtual() {\n    this.dimensions.y.makeVirtual();\n  };\n  Scroller.prototype.virtualSize = function virtualSize(min, max) {\n    this.dimensions.y.virtualSize(min, max);\n  };\n  Scroller.prototype.height = function height() {\n    return this.dimensions.y.size;\n  };\n  Scroller.prototype.scrollHeight = function scrollHeight() {\n    return this.scrollElement.scrollHeight;\n  };\n  Scroller.prototype.scrollWidth = function scrollWidth() {\n    return this.scrollElement.scrollWidth;\n  };\n  Scroller.prototype._resize = function _resize() {\n    if (!this._native) {\n      this.contentResized();\n    }\n  };\n  Scroller.prototype.setOptions = function setOptions(options) {\n    var that = this;\n    this._initOptions(options);\n    if (options.pullToRefresh) {\n      that._initPullToRefresh();\n    }\n  };\n  Scroller.prototype.reset = function reset() {\n    if (this._native) {\n      this.scrollElement.scrollTop(0);\n    } else {\n      this.movable.moveTo({\n        x: 0,\n        y: 0\n      });\n      this._scale(1);\n    }\n  };\n  Scroller.prototype.contentResized = function contentResized() {\n    this.dimensions.refresh();\n    if (this.pane.x.outOfBounds()) {\n      this.movable.moveAxis('x', this.dimensions.x.min);\n    }\n    if (this.pane.y.outOfBounds()) {\n      this.movable.moveAxis('y', this.dimensions.y.min);\n    }\n  };\n  Scroller.prototype.zoomOut = function zoomOut() {\n    var dimensions = this.dimensions;\n    dimensions.refresh();\n    this._scale(dimensions.fitScale);\n    this.movable.moveTo(dimensions.centerCoordinates());\n  };\n  Scroller.prototype.enable = function enable() {\n    this.enabled = true;\n  };\n  Scroller.prototype.disable = function disable() {\n    this.enabled = false;\n  };\n  Scroller.prototype.scrollTo = function scrollTo(x, y) {\n    if (this._native) {\n      this.scrollElement.scrollLeft(abs(x));\n      this.scrollElement.scrollTop(abs(y));\n    } else {\n      this.dimensions.refresh();\n      this.movable.moveTo({\n        x: x,\n        y: y\n      });\n    }\n  };\n  Scroller.prototype.animatedScrollTo = function animatedScrollTo(x, y, callback) {\n    var from, to;\n    if (this._native) {\n      this.scrollTo(x, y);\n    } else {\n      from = {\n        x: this.movable.x,\n        y: this.movable.y\n      };\n      to = {\n        x: x,\n        y: y\n      };\n      this.animatedScroller.setCoordinates(from, to);\n      this.animatedScroller.setCallback(callback);\n      this.animatedScroller.start();\n    }\n  };\n\n  // kept for API compatibility, not used\n  Scroller.prototype.pullHandled = function pullHandled() {\n    // let that = this;\n\n    // removeClass(that.refreshHint, SCROLLER_REFRESH_CLASS);\n    // that.hintContainer.innerHTML = that.pullTemplate({}));\n\n    // that.yinertia.onEnd();\n    // that.xinertia.onEnd();\n    // that.userEvents.cancel();\n  };\n  Scroller.prototype.destroy = function destroy() {\n    var element = this.element;\n    off(element, 'wheel', this._wheelScrollHandler);\n    if (this.userEvents) {\n      this.userEvents.destroy();\n    }\n  };\n  Scroller.prototype._scale = function _scale(scale) {\n    this.dimensions.rescale(scale);\n    this.movable.scaleTo(scale);\n  };\n  Scroller.prototype._initPullToRefresh = function _initPullToRefresh() {};\n\n  // kept for API compatibility, not used\n  Scroller.prototype._dragEnd = function _dragEnd() {\n    // let that = this;\n\n    // if (!that.pulled) {\n    //     return;\n    // }\n\n    // that.pulled = false;\n\n    // removeClass(that.refreshHint, SCROLLER_RELEASE_CLASS);\n    // addClass(that.refreshHint, SCROLLER_REFRESH_CLASS);\n\n    // that.hintContainer.innerHTML = that.refreshTemplate({});\n\n    // that.yinertia.freeze(that.options.pullOffset / 2);\n    // that.trigger('pull');\n  };\n\n  // kept for API compatibility, not used\n  Scroller.prototype._paneChange = function _paneChange() {\n    // let that = this;\n    // if (that.movable.y / OUT_OF_BOUNDS_FRICTION > that.options.pullOffset) {\n    //     if (!that.pulled) {\n    //         that.pulled = true;\n    //         that.refreshHint.removeClass(SCROLLER_REFRESH_CLASS).addClass(SCROLLER_RELEASE_CLASS);\n    //         that.hintContainer.html(that.releaseTemplate({}));\n    //         that.hintContainer.html(that.releaseTemplate({}));\n    //     }\n    // } else if (that.pulled) {\n    //     that.pulled = false;\n    //     that.refreshHint.removeClass(SCROLLER_RELEASE_CLASS);\n    //     that.hintContainer.html(that.pullTemplate({}));\n    // }\n  };\n  Scroller.prototype._initAxis = function _initAxis(axis) {\n    var that = this,\n      movable = that.movable,\n      dimension = that.dimensions[axis],\n      tapCapture = that.tapCapture,\n      paneAxis = that.pane[axis],\n      scrollBar = new ScrollBar({\n        axis: axis,\n        movable: movable,\n        dimension: dimension,\n        container: that.element,\n        alwaysVisible: that.options.visibleScrollHints\n      });\n    dimension.bind(CHANGE, function () {\n      scrollBar.refresh();\n    });\n    paneAxis.bind(CHANGE, function () {\n      scrollBar.show();\n    });\n    that[axis + 'inertia'] = new DragInertia({\n      axis: axis,\n      paneAxis: paneAxis,\n      movable: movable,\n      tapCapture: tapCapture,\n      userEvents: that.userEvents,\n      dimension: dimension,\n      elastic: that.options.elastic,\n      friction: that.options.friction || FRICTION,\n      velocityMultiplier: that.options.velocityMultiplier || VELOCITY_MULTIPLIER,\n      end: function end() {\n        scrollBar.hide();\n        that.trigger('scrollEnd', {\n          axis: axis,\n          scrollTop: that.scrollTop,\n          scrollLeft: that.scrollLeft\n        });\n      }\n    });\n  };\n  return Scroller;\n}(Observable);\nsetDefaultOptions(Scroller, {\n  name: 'Scroller',\n  zoom: false,\n  pullOffset: 140,\n  visibleScrollHints: false,\n  elastic: true,\n  useNative: false,\n  mousewheelScrolling: true,\n  avoidScrolling: function avoidScrolling() {\n    return false;\n  },\n  pullToRefresh: false,\n  messages: {\n    pullTemplate: 'Pull to refresh',\n    releaseTemplate: 'Release to refresh',\n    refreshTemplate: 'Refreshing'\n  }\n});\nsetDefaultEvents(Scroller, [PULL, SCROLL, RESIZE]);","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { deepExtend, eventElement, grep, inArray, setDefaultOptions, createHashSet } from '../../common';\nimport { DATE } from '../../common/constants';\nimport { CategoryAxis, DateCategoryAxis, Point } from '../../core';\nimport { HEATMAP } from '../constants';\nimport HeatmapChart from '../heatmap-chart/heatmap-chart';\nimport PlotAreaEventsMixin from '../mixins/plotarea-events-mixin';\nimport SeriesBinder from '../series-binder';\nimport { appendIfNotNull, equalsIgnoreCase, filterSeriesByType, singleItemOrArray } from '../utils';\nimport PlotAreaBase from './plotarea-base';\nvar HeatmapPlotArea = function (PlotAreaBase) {\n  function HeatmapPlotArea() {\n    PlotAreaBase.apply(this, arguments);\n  }\n  if (PlotAreaBase) HeatmapPlotArea.__proto__ = PlotAreaBase;\n  HeatmapPlotArea.prototype = Object.create(PlotAreaBase && PlotAreaBase.prototype);\n  HeatmapPlotArea.prototype.constructor = HeatmapPlotArea;\n  HeatmapPlotArea.prototype.initFields = function initFields() {\n    this.namedXAxes = {};\n    this.namedYAxes = {};\n  };\n  HeatmapPlotArea.prototype.render = function render(panes) {\n    if (panes === void 0) panes = this.panes;\n    this.bindCategories();\n    this.createAxes(panes);\n    this.createCharts(panes);\n    this.createAxisLabels();\n  };\n  HeatmapPlotArea.prototype.bindCategories = function bindCategories() {\n    var this$1 = this;\n    var series = this.srcSeries || this.series;\n    for (var i = 0; i < series.length; i++) {\n      var currentSeries = series[i];\n      var data = currentSeries.data || [];\n      var ref = this$1.seriesAxes(currentSeries);\n      var xAxis = ref.xAxis;\n      var yAxis = ref.yAxis;\n      var xCategories = createHashSet(xAxis.categories || []);\n      var yCategories = createHashSet(yAxis.categories || []);\n      for (var pointIndex = 0; pointIndex < data.length; pointIndex++) {\n        var ref$1 = SeriesBinder.current.bindPoint(currentSeries, pointIndex).valueFields;\n        var x = ref$1.x;\n        var y = ref$1.y;\n        if (!xCategories.has(x)) {\n          xCategories.add(x);\n        }\n        if (!yCategories.has(y)) {\n          yCategories.add(y);\n        }\n      }\n      xAxis.categories = xCategories.values();\n      yAxis.categories = yCategories.values();\n    }\n  };\n  HeatmapPlotArea.prototype.createCharts = function createCharts(panes) {\n    var this$1 = this;\n    var seriesByPane = this.groupSeriesByPane();\n    for (var i = 0; i < panes.length; i++) {\n      var pane = panes[i];\n      var paneSeries = seriesByPane[pane.options.name || \"default\"] || [];\n      this$1.addToLegend(paneSeries);\n      var filteredSeries = this$1.filterVisibleSeries(paneSeries);\n      if (!filteredSeries) {\n        continue;\n      }\n      this$1.createHeatmapChart(filterSeriesByType(filteredSeries, [HEATMAP]), pane);\n    }\n  };\n  HeatmapPlotArea.prototype.createHeatmapChart = function createHeatmapChart(series, pane) {\n    var chart = new HeatmapChart(this, {\n      series: series\n    });\n    this.appendChart(chart, pane);\n  };\n  HeatmapPlotArea.prototype.seriesPaneName = function seriesPaneName(series) {\n    var options = this.options;\n    var xAxisName = series.xAxis;\n    var xAxisOptions = [].concat(options.xAxis);\n    var xAxis = grep(xAxisOptions, function (a) {\n      return a.name === xAxisName;\n    })[0];\n    var yAxisName = series.yAxis;\n    var yAxisOptions = [].concat(options.yAxis);\n    var yAxis = grep(yAxisOptions, function (a) {\n      return a.name === yAxisName;\n    })[0];\n    var panes = options.panes || [{}];\n    var defaultPaneName = panes[0].name || \"default\";\n    var paneName = (xAxis || {}).pane || (yAxis || {}).pane || defaultPaneName;\n    return paneName;\n  };\n  HeatmapPlotArea.prototype.seriesAxes = function seriesAxes(series) {\n    var xAxis;\n    var yAxis;\n    var options = this.options;\n    var xAxisOptions = [].concat(options.xAxis);\n    var xAxisName = series.xAxis;\n    if (xAxisName) {\n      xAxis = xAxisOptions.find(function (axis) {\n        return axis.name === xAxisName;\n      });\n    } else {\n      xAxis = xAxisOptions[0];\n    }\n    var yAxisOptions = [].concat(options.yAxis);\n    var yAxisName = series.yAxis;\n    if (yAxisName) {\n      yAxis = yAxisOptions.find(function (axis) {\n        return axis.name === yAxisName;\n      });\n    } else {\n      yAxis = yAxisOptions[0];\n    }\n    if (!xAxis) {\n      throw new Error(\"Unable to locate X axis with name \" + xAxisName);\n    }\n    if (!yAxis) {\n      throw new Error(\"Unable to locate Y axis with name \" + yAxisName);\n    }\n    return {\n      xAxis: xAxis,\n      yAxis: yAxis\n    };\n  };\n  HeatmapPlotArea.prototype.createAxisLabels = function createAxisLabels() {\n    var axes = this.axes;\n    for (var i = 0; i < axes.length; i++) {\n      axes[i].createLabels();\n    }\n  };\n  HeatmapPlotArea.prototype.createXYAxis = function createXYAxis(options, vertical, axisIndex) {\n    var axisName = options.name;\n    var namedAxes = vertical ? this.namedYAxes : this.namedXAxes;\n    var axisOptions = Object.assign({\n      axisCrossingValue: 0\n    }, options, {\n      vertical: vertical,\n      reverse: vertical || this.chartService.rtl ? !options.reverse : options.reverse,\n      justified: false\n    });\n    var firstCategory = axisOptions.categories ? axisOptions.categories[0] : null;\n    var typeSamples = [axisOptions.min, axisOptions.max, firstCategory];\n    var series = this.series;\n    for (var seriesIx = 0; seriesIx < series.length; seriesIx++) {\n      var currentSeries = series[seriesIx];\n      var seriesAxisName = currentSeries[vertical ? \"yAxis\" : \"xAxis\"];\n      if (seriesAxisName === axisOptions.name || axisIndex === 0 && !seriesAxisName) {\n        var firstPointValue = SeriesBinder.current.bindPoint(currentSeries, 0).valueFields;\n        typeSamples.push(firstPointValue[vertical ? \"y\" : \"x\"]);\n        break;\n      }\n    }\n    var inferredDate;\n    for (var i = 0; i < typeSamples.length; i++) {\n      if (typeSamples[i] instanceof Date) {\n        inferredDate = true;\n        break;\n      }\n    }\n    var axisType;\n    if (equalsIgnoreCase(axisOptions.type, DATE) || !axisOptions.type && inferredDate) {\n      axisType = DateCategoryAxis;\n    } else {\n      axisType = CategoryAxis;\n    }\n    var axis = new axisType(axisOptions, this.chartService);\n    axis.axisIndex = axisIndex;\n    if (axisName) {\n      if (namedAxes[axisName]) {\n        throw new Error((vertical ? \"Y\" : \"X\") + \" axis with name \" + axisName + \" is already defined\");\n      }\n      namedAxes[axisName] = axis;\n    }\n    this.appendAxis(axis);\n    axis.mapCategories();\n    return axis;\n  };\n  HeatmapPlotArea.prototype.createAxes = function createAxes(panes) {\n    var this$1 = this;\n    var options = this.options;\n    var xAxesOptions = [].concat(options.xAxis);\n    var xAxes = [];\n    var yAxesOptions = [].concat(options.yAxis);\n    var yAxes = [];\n    for (var idx = 0; idx < xAxesOptions.length; idx++) {\n      var axisPane = this$1.findPane(xAxesOptions[idx].pane);\n      if (inArray(axisPane, panes)) {\n        xAxes.push(this$1.createXYAxis(xAxesOptions[idx], false, idx));\n      }\n    }\n    for (var idx$1 = 0; idx$1 < yAxesOptions.length; idx$1++) {\n      var axisPane$1 = this$1.findPane(yAxesOptions[idx$1].pane);\n      if (inArray(axisPane$1, panes)) {\n        yAxes.push(this$1.createXYAxis(yAxesOptions[idx$1], true, idx$1));\n      }\n    }\n    this.axisX = this.axisX || xAxes[0];\n    this.axisY = this.axisY || yAxes[0];\n  };\n  HeatmapPlotArea.prototype.removeAxis = function removeAxis(axis) {\n    var axisName = axis.options.name;\n    PlotAreaBase.prototype.removeAxis.call(this, axis);\n    if (axis.options.vertical) {\n      delete this.namedYAxes[axisName];\n    } else {\n      delete this.namedXAxes[axisName];\n    }\n    if (axis === this.axisX) {\n      delete this.axisX;\n    }\n    if (axis === this.axisY) {\n      delete this.axisY;\n    }\n  };\n  HeatmapPlotArea.prototype._dispatchEvent = function _dispatchEvent(chart, e, eventType) {\n    var coords = chart._eventCoordinates(e);\n    var point = new Point(coords.x, coords.y);\n    var allAxes = this.axes;\n    var length = allAxes.length;\n    var xValues = [];\n    var yValues = [];\n    for (var i = 0; i < length; i++) {\n      var axis = allAxes[i];\n      var values = axis.options.vertical ? yValues : xValues;\n      appendIfNotNull(values, axis.getCategory(point));\n    }\n    if (xValues.length > 0 && yValues.length > 0) {\n      chart.trigger(eventType, {\n        element: eventElement(e),\n        originalEvent: e,\n        x: singleItemOrArray(xValues),\n        y: singleItemOrArray(yValues)\n      });\n    }\n  };\n  HeatmapPlotArea.prototype.updateAxisOptions = function updateAxisOptions$1(axis, options) {\n    var vertical = axis.options.vertical;\n    var axes = this.groupAxes(this.panes);\n    var index = (vertical ? axes.y : axes.x).indexOf(axis);\n    updateAxisOptions(this.options, index, vertical, options);\n    updateAxisOptions(this.originalOptions, index, vertical, options);\n  };\n  HeatmapPlotArea.prototype.crosshairOptions = function crosshairOptions(axis) {\n    // Stack the crosshair above the series points.\n    return Object.assign({}, axis.options.crosshair, {\n      zIndex: 0\n    });\n  };\n  return HeatmapPlotArea;\n}(PlotAreaBase);\nfunction updateAxisOptions(targetOptions, axisIndex, vertical, options) {\n  var axisOptions = [].concat(vertical ? targetOptions.yAxis : targetOptions.xAxis)[axisIndex];\n  deepExtend(axisOptions, options);\n}\nsetDefaultOptions(HeatmapPlotArea, {\n  xAxis: {},\n  yAxis: {}\n});\ndeepExtend(HeatmapPlotArea.prototype, PlotAreaEventsMixin);\nexport default HeatmapPlotArea;","map":null,"metadata":{},"sourceType":"module"}
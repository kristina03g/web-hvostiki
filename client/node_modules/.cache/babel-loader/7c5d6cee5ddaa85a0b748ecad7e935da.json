{"ast":null,"code":"import CategoryAxis from './category-axis';\nimport AxisLabel from './axis-label';\nimport Box from './box';\nimport { CENTER, DATE, DEFAULT_PRECISION, MAX_VALUE, OBJECT, X, Y } from '../common/constants';\nimport { deepExtend, defined, inArray, last, limitValue, round, setDefaultOptions, sparseArrayLimits } from '../common';\nimport { MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS, TIME_PER_MINUTE, TIME_PER_HOUR, TIME_PER_DAY, TIME_PER_WEEK, TIME_PER_MONTH, TIME_PER_YEAR, TIME_PER_UNIT } from '../date-utils/constants';\nimport { dateComparer, toDate, addTicks, addDuration, dateDiff, absoluteDateDiff, dateIndex, dateEquals, toTime, parseDate, parseDates, firstDay } from '../date-utils';\nimport { DateLabelFormats } from './constants';\nvar AUTO = \"auto\";\nvar BASE_UNITS = [MILLISECONDS, SECONDS, MINUTES, HOURS, DAYS, WEEKS, MONTHS, YEARS];\nvar FIT = \"fit\";\nfunction categoryRange(categories) {\n  var range = categories._range;\n  if (!range) {\n    range = categories._range = sparseArrayLimits(categories);\n    range.min = toDate(range.min);\n    range.max = toDate(range.max);\n  }\n  return range;\n}\nvar EmptyDateRange = function EmptyDateRange(options) {\n  this.options = options;\n};\nEmptyDateRange.prototype.displayIndices = function displayIndices() {\n  return {\n    min: 0,\n    max: 1\n  };\n};\nEmptyDateRange.prototype.displayRange = function displayRange() {\n  return {};\n};\nEmptyDateRange.prototype.total = function total() {\n  return {};\n};\nEmptyDateRange.prototype.valueRange = function valueRange() {\n  return {};\n};\nEmptyDateRange.prototype.valueIndex = function valueIndex() {\n  return -1;\n};\nEmptyDateRange.prototype.values = function values() {\n  return [];\n};\nEmptyDateRange.prototype.totalIndex = function totalIndex() {\n  return -1;\n};\nEmptyDateRange.prototype.valuesCount = function valuesCount() {\n  return 0;\n};\nEmptyDateRange.prototype.totalCount = function totalCount() {\n  return 0;\n};\nEmptyDateRange.prototype.dateAt = function dateAt() {\n  return null;\n};\nvar DateRange = function DateRange(start, end, options) {\n  this.options = options;\n  options.baseUnitStep = options.baseUnitStep || 1;\n  var roundToBaseUnit = options.roundToBaseUnit;\n  var justified = options.justified;\n  this.start = addDuration(start, 0, options.baseUnit, options.weekStartDay);\n  var lowerEnd = this.roundToTotalStep(end);\n  var expandEnd = !justified && dateEquals(end, lowerEnd) && !options.justifyEnd;\n  this.end = this.roundToTotalStep(end, !justified, expandEnd ? 1 : 0);\n  var min = options.min || start;\n  this.valueStart = this.roundToTotalStep(min);\n  this.displayStart = roundToBaseUnit ? this.valueStart : min;\n  var max = options.max;\n  if (!max) {\n    this.valueEnd = lowerEnd;\n    this.displayEnd = roundToBaseUnit || expandEnd ? this.end : end;\n  } else {\n    var next = !justified && dateEquals(max, this.roundToTotalStep(max)) ? -1 : 0;\n    this.valueEnd = this.roundToTotalStep(max, false, next);\n    this.displayEnd = roundToBaseUnit ? this.roundToTotalStep(max, !justified) : options.max;\n  }\n  if (this.valueEnd < this.valueStart) {\n    this.valueEnd = this.valueStart;\n  }\n  if (this.displayEnd <= this.displayStart) {\n    this.displayEnd = this.roundToTotalStep(this.displayStart, false, 1);\n  }\n};\nDateRange.prototype.displayRange = function displayRange() {\n  return {\n    min: this.displayStart,\n    max: this.displayEnd\n  };\n};\nDateRange.prototype.displayIndices = function displayIndices() {\n  if (!this._indices) {\n    var options = this.options;\n    var baseUnit = options.baseUnit;\n    var baseUnitStep = options.baseUnitStep;\n    var minIdx = dateIndex(this.displayStart, this.valueStart, baseUnit, baseUnitStep);\n    var maxIdx = dateIndex(this.displayEnd, this.valueStart, baseUnit, baseUnitStep);\n    this._indices = {\n      min: minIdx,\n      max: maxIdx\n    };\n  }\n  return this._indices;\n};\nDateRange.prototype.total = function total() {\n  return {\n    min: this.start,\n    max: this.end\n  };\n};\nDateRange.prototype.totalCount = function totalCount() {\n  var last = this.totalIndex(this.end);\n  return last + (this.options.justified ? 1 : 0);\n};\nDateRange.prototype.valueRange = function valueRange() {\n  return {\n    min: this.valueStart,\n    max: this.valueEnd\n  };\n};\nDateRange.prototype.valueIndex = function valueIndex(value) {\n  var options = this.options;\n  return Math.floor(dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep));\n};\nDateRange.prototype.totalIndex = function totalIndex(value) {\n  var options = this.options;\n  return Math.floor(dateIndex(value, this.start, options.baseUnit, options.baseUnitStep));\n};\nDateRange.prototype.dateIndex = function dateIndex$1(value) {\n  var options = this.options;\n  return dateIndex(value, this.valueStart, options.baseUnit, options.baseUnitStep);\n};\nDateRange.prototype.valuesCount = function valuesCount() {\n  var maxIdx = this.valueIndex(this.valueEnd);\n  return maxIdx + 1;\n};\nDateRange.prototype.values = function values() {\n  var values = this._values;\n  if (!values) {\n    var options = this.options;\n    var range = this.valueRange();\n    this._values = values = [];\n    for (var date = range.min; date <= range.max;) {\n      values.push(date);\n      date = addDuration(date, options.baseUnitStep, options.baseUnit, options.weekStartDay);\n    }\n  }\n  return values;\n};\nDateRange.prototype.dateAt = function dateAt(index, total) {\n  var options = this.options;\n  return addDuration(total ? this.start : this.valueStart, options.baseUnitStep * index, options.baseUnit, options.weekStartDay);\n};\nDateRange.prototype.roundToTotalStep = function roundToTotalStep(value, upper, next) {\n  var ref = this.options;\n  var baseUnit = ref.baseUnit;\n  var baseUnitStep = ref.baseUnitStep;\n  var weekStartDay = ref.weekStartDay;\n  var start = this.start;\n  var step = dateIndex(value, start, baseUnit, baseUnitStep);\n  var roundedStep = upper ? Math.ceil(step) : Math.floor(step);\n  if (next) {\n    roundedStep += next;\n  }\n  return addDuration(start, roundedStep * baseUnitStep, baseUnit, weekStartDay);\n};\nfunction autoBaseUnit(options, startUnit, startStep) {\n  var categoryLimits = categoryRange(options.categories);\n  var span = (options.max || categoryLimits.max) - (options.min || categoryLimits.min);\n  var autoBaseUnitSteps = options.autoBaseUnitSteps;\n  var maxDateGroups = options.maxDateGroups;\n  var autoUnit = options.baseUnit === FIT;\n  var autoUnitIx = startUnit ? BASE_UNITS.indexOf(startUnit) : 0;\n  var baseUnit = autoUnit ? BASE_UNITS[autoUnitIx++] : options.baseUnit;\n  var units = span / TIME_PER_UNIT[baseUnit];\n  var totalUnits = units;\n  var unitSteps, step, nextStep;\n  while (!step || units >= maxDateGroups) {\n    unitSteps = unitSteps || autoBaseUnitSteps[baseUnit].slice(0);\n    do {\n      nextStep = unitSteps.shift();\n    } while (nextStep && startUnit === baseUnit && nextStep < startStep);\n    if (nextStep) {\n      step = nextStep;\n      units = totalUnits / step;\n    } else if (baseUnit === last(BASE_UNITS)) {\n      step = Math.ceil(totalUnits / maxDateGroups);\n      break;\n    } else if (autoUnit) {\n      baseUnit = BASE_UNITS[autoUnitIx++] || last(BASE_UNITS);\n      totalUnits = span / TIME_PER_UNIT[baseUnit];\n      unitSteps = null;\n    } else {\n      if (units > maxDateGroups) {\n        step = Math.ceil(totalUnits / maxDateGroups);\n      }\n      break;\n    }\n  }\n  options.baseUnitStep = step;\n  options.baseUnit = baseUnit;\n}\nfunction defaultBaseUnit(options) {\n  var categories = options.categories;\n  var count = defined(categories) ? categories.length : 0;\n  var minDiff = MAX_VALUE;\n  var lastCategory, unit;\n  for (var categoryIx = 0; categoryIx < count; categoryIx++) {\n    var category = categories[categoryIx];\n    if (category && lastCategory) {\n      var diff = absoluteDateDiff(category, lastCategory);\n      if (diff > 0) {\n        minDiff = Math.min(minDiff, diff);\n        if (minDiff >= TIME_PER_YEAR) {\n          unit = YEARS;\n        } else if (minDiff >= TIME_PER_MONTH - TIME_PER_DAY * 3) {\n          unit = MONTHS;\n        } else if (minDiff >= TIME_PER_WEEK) {\n          unit = WEEKS;\n        } else if (minDiff >= TIME_PER_DAY) {\n          unit = DAYS;\n        } else if (minDiff >= TIME_PER_HOUR) {\n          unit = HOURS;\n        } else if (minDiff >= TIME_PER_MINUTE) {\n          unit = MINUTES;\n        } else {\n          unit = SECONDS;\n        }\n      }\n    }\n    lastCategory = category;\n  }\n  options.baseUnit = unit || DAYS;\n}\nfunction initUnit(options) {\n  var baseUnit = (options.baseUnit || \"\").toLowerCase();\n  var useDefault = baseUnit !== FIT && !inArray(baseUnit, BASE_UNITS);\n  if (useDefault) {\n    defaultBaseUnit(options);\n  }\n  if (baseUnit === FIT || options.baseUnitStep === AUTO) {\n    autoBaseUnit(options);\n  }\n  return options;\n}\nvar DateCategoryAxis = function (CategoryAxis) {\n  function DateCategoryAxis() {\n    CategoryAxis.apply(this, arguments);\n  }\n  if (CategoryAxis) DateCategoryAxis.__proto__ = CategoryAxis;\n  DateCategoryAxis.prototype = Object.create(CategoryAxis && CategoryAxis.prototype);\n  DateCategoryAxis.prototype.constructor = DateCategoryAxis;\n  DateCategoryAxis.prototype.clone = function clone() {\n    var copy = new DateCategoryAxis(Object.assign({}, this.options), this.chartService);\n    copy.createLabels();\n    return copy;\n  };\n  DateCategoryAxis.prototype.categoriesHash = function categoriesHash() {\n    var start = this.dataRange.total().min;\n    return this.options.baseUnit + this.options.baseUnitStep + start;\n  };\n  DateCategoryAxis.prototype.initUserOptions = function initUserOptions(options) {\n    return options;\n  };\n  DateCategoryAxis.prototype.initFields = function initFields() {\n    CategoryAxis.prototype.initFields.call(this);\n    var chartService = this.chartService;\n    var intlService = chartService.intl;\n    var options = this.options;\n    var categories = options.categories || [];\n    if (!categories._parsed) {\n      categories = parseDates(intlService, categories);\n      categories._parsed = true;\n    }\n    options = deepExtend({\n      roundToBaseUnit: true\n    }, options, {\n      categories: categories,\n      min: parseDate(intlService, options.min),\n      max: parseDate(intlService, options.max),\n      weekStartDay: firstDay(options, intlService)\n    });\n    if (chartService.panning && chartService.isPannable(options.vertical ? Y : X)) {\n      options.roundToBaseUnit = false;\n    }\n    options.userSetBaseUnit = options.userSetBaseUnit || options.baseUnit;\n    options.userSetBaseUnitStep = options.userSetBaseUnitStep || options.baseUnitStep;\n    this.options = options;\n    options.srcCategories = categories;\n    if (categories.length > 0) {\n      var range = categoryRange(categories);\n      var maxDivisions = options.maxDivisions;\n      this.dataRange = new DateRange(range.min, range.max, initUnit(options));\n      if (maxDivisions) {\n        var dataRange = this.dataRange.displayRange();\n        var divisionOptions = Object.assign({}, options, {\n          justified: true,\n          roundToBaseUnit: false,\n          baseUnit: 'fit',\n          min: dataRange.min,\n          max: dataRange.max,\n          maxDateGroups: maxDivisions\n        });\n        var dataRangeOptions = this.dataRange.options;\n        autoBaseUnit(divisionOptions, dataRangeOptions.baseUnit, dataRangeOptions.baseUnitStep);\n        this.divisionRange = new DateRange(range.min, range.max, divisionOptions);\n      } else {\n        this.divisionRange = this.dataRange;\n      }\n    } else {\n      options.baseUnit = options.baseUnit || DAYS;\n      this.dataRange = this.divisionRange = new EmptyDateRange(options);\n    }\n    this.rangeLabels = [];\n  };\n  DateCategoryAxis.prototype.tickIndices = function tickIndices(stepSize) {\n    var ref = this;\n    var dataRange = ref.dataRange;\n    var divisionRange = ref.divisionRange;\n    var valuesCount = divisionRange.valuesCount();\n    if (!this.options.maxDivisions || !valuesCount) {\n      return CategoryAxis.prototype.tickIndices.call(this, stepSize);\n    }\n    var indices = [];\n    var values = divisionRange.values();\n    var offset = 0;\n    if (!this.options.justified) {\n      values = values.concat(divisionRange.dateAt(valuesCount));\n      offset = 0.5; //align ticks to the center of not justified categories\n    }\n\n    for (var idx = 0; idx < values.length; idx++) {\n      indices.push(dataRange.dateIndex(values[idx]) + offset);\n      if (stepSize !== 1 && idx >= 1) {\n        var last = indices.length - 1;\n        indices.splice(idx, 0, indices[last - 1] + (indices[last] - indices[last - 1]) * stepSize);\n      }\n    }\n    return indices;\n  };\n  DateCategoryAxis.prototype.shouldRenderNote = function shouldRenderNote(value) {\n    var range = this.range();\n    var categories = this.options.categories || [];\n    return dateComparer(value, range.min) >= 0 && dateComparer(value, range.max) <= 0 && categories.length;\n  };\n  DateCategoryAxis.prototype.parseNoteValue = function parseNoteValue(value) {\n    return parseDate(this.chartService.intl, value);\n  };\n  DateCategoryAxis.prototype.noteSlot = function noteSlot(value) {\n    return this.getSlot(value);\n  };\n  DateCategoryAxis.prototype.translateRange = function translateRange(delta) {\n    var options = this.options;\n    var baseUnit = options.baseUnit;\n    var weekStartDay = options.weekStartDay;\n    var vertical = options.vertical;\n    var lineBox = this.lineBox();\n    var size = vertical ? lineBox.height() : lineBox.width();\n    var range = this.range();\n    var scale = size / (range.max - range.min);\n    var offset = round(delta / scale, DEFAULT_PRECISION);\n    if (range.min && range.max) {\n      var from = addTicks(options.min || range.min, offset);\n      var to = addTicks(options.max || range.max, offset);\n      range = {\n        min: addDuration(from, 0, baseUnit, weekStartDay),\n        max: addDuration(to, 0, baseUnit, weekStartDay)\n      };\n    }\n    return range;\n  };\n  DateCategoryAxis.prototype.labelsRange = function labelsRange() {\n    return {\n      min: this.options.labels.skip,\n      max: this.divisionRange.valuesCount()\n    };\n  };\n  DateCategoryAxis.prototype.pan = function pan(delta) {\n    if (this.isEmpty()) {\n      return null;\n    }\n    var options = this.options;\n    var lineBox = this.lineBox();\n    var size = options.vertical ? lineBox.height() : lineBox.width();\n    var ref = this.dataRange.displayRange();\n    var min = ref.min;\n    var max = ref.max;\n    var totalLimits = this.dataRange.total();\n    var scale = size / (max - min);\n    var offset = round(delta / scale, DEFAULT_PRECISION) * (options.reverse ? -1 : 1);\n    var from = addTicks(min, offset);\n    var to = addTicks(max, offset);\n    var panRange = this.limitRange(toTime(from), toTime(to), toTime(totalLimits.min), toTime(totalLimits.max), offset);\n    if (panRange) {\n      panRange.min = toDate(panRange.min);\n      panRange.max = toDate(panRange.max);\n      panRange.baseUnit = options.baseUnit;\n      panRange.baseUnitStep = options.baseUnitStep || 1;\n      panRange.userSetBaseUnit = options.userSetBaseUnit;\n      panRange.userSetBaseUnitStep = options.userSetBaseUnitStep;\n      return panRange;\n    }\n  };\n  DateCategoryAxis.prototype.pointsRange = function pointsRange(start, end) {\n    if (this.isEmpty()) {\n      return null;\n    }\n    var pointsRange = CategoryAxis.prototype.pointsRange.call(this, start, end);\n    var datesRange = this.dataRange.displayRange();\n    var indicesRange = this.dataRange.displayIndices();\n    var scale = dateDiff(datesRange.max, datesRange.min) / (indicesRange.max - indicesRange.min);\n    var options = this.options;\n    var min = addTicks(datesRange.min, pointsRange.min * scale);\n    var max = addTicks(datesRange.min, pointsRange.max * scale);\n    return {\n      min: min,\n      max: max,\n      baseUnit: options.userSetBaseUnit || options.baseUnit,\n      baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n    };\n  };\n  DateCategoryAxis.prototype.scaleRange = function scaleRange(scale, cursor) {\n    if (this.isEmpty()) {\n      return {};\n    }\n    var options = this.options;\n    var fit = options.userSetBaseUnit === FIT;\n    var totalLimits = this.dataRange.total();\n    var ref = this.dataRange.displayRange();\n    var rangeMin = ref.min;\n    var rangeMax = ref.max;\n    var position = Math.abs(this.pointOffset(cursor));\n    var range = rangeMax - rangeMin;\n    var delta = this.scaleToDelta(scale, range);\n    var minDelta = Math.round(position * delta);\n    var maxDelta = Math.round((1 - position) * delta);\n    var ref$1 = this.dataRange.options;\n    var baseUnit = ref$1.baseUnit;\n    var min = new Date(rangeMin.getTime() + minDelta);\n    var max = new Date(rangeMax.getTime() - maxDelta);\n    if (fit) {\n      var autoBaseUnitSteps = options.autoBaseUnitSteps;\n      var maxDateGroups = options.maxDateGroups;\n      var maxDiff = last(autoBaseUnitSteps[baseUnit]) * maxDateGroups * TIME_PER_UNIT[baseUnit];\n      var rangeDiff = dateDiff(rangeMax, rangeMin);\n      var diff = dateDiff(max, min);\n      var baseUnitIndex = BASE_UNITS.indexOf(baseUnit);\n      var autoBaseUnitStep, ticks;\n      if (diff < TIME_PER_UNIT[baseUnit] && baseUnit !== MILLISECONDS) {\n        baseUnit = BASE_UNITS[baseUnitIndex - 1];\n        autoBaseUnitStep = last(autoBaseUnitSteps[baseUnit]);\n        ticks = (rangeDiff - (maxDateGroups - 1) * autoBaseUnitStep * TIME_PER_UNIT[baseUnit]) / 2;\n        min = addTicks(rangeMin, ticks);\n        max = addTicks(rangeMax, -ticks);\n      } else if (diff > maxDiff && baseUnit !== YEARS) {\n        var stepIndex = 0;\n        do {\n          baseUnitIndex++;\n          baseUnit = BASE_UNITS[baseUnitIndex];\n          stepIndex = 0;\n          ticks = 2 * TIME_PER_UNIT[baseUnit];\n          do {\n            autoBaseUnitStep = autoBaseUnitSteps[baseUnit][stepIndex];\n            stepIndex++;\n          } while (stepIndex < autoBaseUnitSteps[baseUnit].length && ticks * autoBaseUnitStep < rangeDiff);\n        } while (baseUnit !== YEARS && ticks * autoBaseUnitStep < rangeDiff);\n        ticks = (ticks * autoBaseUnitStep - rangeDiff) / 2;\n        if (ticks > 0) {\n          min = addTicks(rangeMin, -ticks);\n          max = addTicks(rangeMax, ticks);\n          min = addTicks(min, limitValue(max, totalLimits.min, totalLimits.max) - max);\n          max = addTicks(max, limitValue(min, totalLimits.min, totalLimits.max) - min);\n        }\n      }\n    }\n    if (min && max && dateDiff(max, min) > 0) {\n      return {\n        min: min,\n        max: max,\n        baseUnit: options.userSetBaseUnit || options.baseUnit,\n        baseUnitStep: options.userSetBaseUnitStep || options.baseUnitStep\n      };\n    }\n  };\n  DateCategoryAxis.prototype.zoomRange = function zoomRange(scale, cursor) {\n    var totalLimits = this.dataRange.total();\n    var range = this.scaleRange(scale, cursor);\n    if (range) {\n      if (range.min < totalLimits.min) {\n        range.min = totalLimits.min;\n      }\n      if (range.max > totalLimits.max) {\n        range.max = totalLimits.max;\n      }\n    }\n    return range;\n  };\n  DateCategoryAxis.prototype.range = function range() {\n    return this.dataRange.displayRange();\n  };\n  DateCategoryAxis.prototype.createLabels = function createLabels() {\n    CategoryAxis.prototype.createLabels.call(this);\n    this.createRangeLabels();\n  };\n  DateCategoryAxis.prototype.clearLabels = function clearLabels() {\n    CategoryAxis.prototype.clearLabels.call(this);\n    this.rangeLabels = [];\n  };\n  DateCategoryAxis.prototype.arrangeLabels = function arrangeLabels() {\n    this.arrangeRangeLabels();\n    CategoryAxis.prototype.arrangeLabels.call(this);\n  };\n  DateCategoryAxis.prototype.arrangeRangeLabels = function arrangeRangeLabels() {\n    var ref = this;\n    var options = ref.options;\n    var rangeLabels = ref.rangeLabels;\n    if (rangeLabels.length === 0) {\n      return;\n    }\n    var lineBox = this.lineBox();\n    var vertical = options.vertical;\n    var mirror = options.rangeLabels.mirror || options.labels.mirror;\n    var firstLabel = rangeLabels[0];\n    if (firstLabel) {\n      var position = vertical ? lineBox.y1 - firstLabel.box.height() / 2 : lineBox.x1;\n      this.positionLabel(firstLabel, mirror, position);\n    }\n    var lastLabel = rangeLabels[1];\n    if (lastLabel) {\n      var position$1 = vertical ? lineBox.y2 - lastLabel.box.height() / 2 : lineBox.x2;\n      this.positionLabel(lastLabel, mirror, position$1);\n    }\n  };\n  DateCategoryAxis.prototype.autoRotateLabels = function autoRotateLabels() {\n    CategoryAxis.prototype.autoRotateLabels.call(this);\n    this.autoRotateRangeLabels();\n  };\n  DateCategoryAxis.prototype.hideOutOfRangeLabels = function hideOutOfRangeLabels() {\n    CategoryAxis.prototype.hideOutOfRangeLabels.call(this);\n    this.hideOverlappingLabels();\n  };\n  DateCategoryAxis.prototype.hideOverlappingLabels = function hideOverlappingLabels() {\n    var ref = this;\n    var rangeLabels = ref.rangeLabels;\n    var labels = ref.labels;\n    if (rangeLabels.length === 0) {\n      return;\n    }\n    function clip(rangeLabel, label) {\n      if (!label.options.visible || label.box.overlaps(rangeLabel.box)) {\n        label.options.visible = false;\n        return true;\n      }\n      return false;\n    }\n    var firstRangeLabel = rangeLabels[0];\n    if (firstRangeLabel && firstRangeLabel.options.visible) {\n      for (var i = 0; i < labels.length; i++) {\n        var overlaps = clip(firstRangeLabel, labels[i]);\n        if (!overlaps) {\n          break;\n        }\n      }\n    }\n    var lastRangeLabel = rangeLabels[1];\n    if (lastRangeLabel && lastRangeLabel.options.visible) {\n      for (var i$1 = labels.length - 1; i$1 > 0; --i$1) {\n        var overlaps$1 = clip(lastRangeLabel, labels[i$1]);\n        if (!overlaps$1) {\n          break;\n        }\n      }\n    }\n  };\n  DateCategoryAxis.prototype.contentBox = function contentBox() {\n    var box = CategoryAxis.prototype.contentBox.call(this);\n    var rangeLabels = this.rangeLabels;\n    for (var i = 0; i < rangeLabels.length; i++) {\n      var label = rangeLabels[i];\n      if (label.options.visible) {\n        box.wrap(label.box);\n      }\n    }\n    return box;\n  };\n  DateCategoryAxis.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {\n    if (labelContext === void 0) labelContext = {};\n    var options = this.options;\n    var dataItem = options.dataItems && !options.maxDivisions ? options.dataItems[index] : null;\n    var date = this.divisionRange.dateAt(index);\n    var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n    labelOptions.format = labelOptions.format || unitFormat;\n    labelContext.dataItem = dataItem;\n    var text = this.axisLabelText(date, labelOptions, labelContext);\n    if (text) {\n      return new AxisLabel(date, text, index, dataItem, labelOptions);\n    }\n  };\n  DateCategoryAxis.prototype.createRangeLabels = function createRangeLabels() {\n    var this$1 = this;\n    var ref = this.divisionRange;\n    var displayStart = ref.displayStart;\n    var displayEnd = ref.displayEnd;\n    var options = this.options;\n    var labelOptions = Object.assign({}, options.labels, options.rangeLabels, {\n      align: CENTER,\n      zIndex: options.zIndex\n    });\n    if (labelOptions.visible !== true) {\n      return;\n    }\n    this.normalizeLabelRotation(labelOptions);\n    labelOptions.alignRotation = CENTER;\n    if (labelOptions.rotation === \"auto\") {\n      labelOptions.rotation = 0;\n      options.autoRotateRangeLabels = true;\n    }\n    var unitFormat = labelOptions.dateFormats[this.divisionRange.options.baseUnit];\n    labelOptions.format = labelOptions.format || unitFormat;\n    var createLabel = function createLabel(index, date, text) {\n      if (text) {\n        var label = new AxisLabel(date, text, index, null, labelOptions);\n        this$1.append(label);\n        this$1.rangeLabels.push(label);\n      }\n    };\n    var startText = this.axisLabelText(displayStart, labelOptions, {\n      index: 0,\n      count: 2\n    });\n    createLabel(0, displayStart, startText);\n    var endText = this.axisLabelText(displayEnd, labelOptions, {\n      index: 1,\n      count: 2\n    });\n    createLabel(1, displayEnd, endText);\n  };\n  DateCategoryAxis.prototype.autoRotateRangeLabels = function autoRotateRangeLabels() {\n    var this$1 = this;\n    var labels = this.rangeLabels;\n    if (!this.options.autoRotateRangeLabels || this.options.vertical || labels.length !== 2) {\n      return;\n    }\n    var rotateLabel = function rotateLabel(label, tickPositions, index) {\n      var width = Math.abs(tickPositions[index + 1] - tickPositions[index]) * 2;\n      var angle = this$1.autoRotateLabelAngle(label.box, width);\n      if (angle !== 0) {\n        label.options.rotation = angle;\n        label.reflow(new Box());\n      }\n    };\n    var tickPositions = this.getMajorTickPositions();\n    rotateLabel(labels[0], tickPositions, 0);\n    rotateLabel(labels[1], tickPositions, tickPositions.length - 2);\n  };\n  DateCategoryAxis.prototype.categoryIndex = function categoryIndex(value) {\n    return this.dataRange.valueIndex(value);\n  };\n  DateCategoryAxis.prototype.slot = function slot(from, to, limit) {\n    var dateRange = this.dataRange;\n    var start = from;\n    var end = to;\n    if (start instanceof Date) {\n      start = dateRange.dateIndex(start);\n    }\n    if (end instanceof Date) {\n      end = dateRange.dateIndex(end);\n    }\n    var slot = this.getSlot(start, end, limit);\n    if (slot) {\n      return slot.toRect();\n    }\n  };\n  DateCategoryAxis.prototype.getSlot = function getSlot(a, b, limit) {\n    var start = a;\n    var end = b;\n    if (typeof start === OBJECT) {\n      start = this.categoryIndex(start);\n    }\n    if (typeof end === OBJECT) {\n      end = this.categoryIndex(end);\n    }\n    return CategoryAxis.prototype.getSlot.call(this, start, end, limit);\n  };\n  DateCategoryAxis.prototype.valueRange = function valueRange() {\n    var options = this.options;\n    var range = categoryRange(options.srcCategories);\n    return {\n      min: toDate(range.min),\n      max: toDate(range.max)\n    };\n  };\n  DateCategoryAxis.prototype.categoryAt = function categoryAt(index, total) {\n    return this.dataRange.dateAt(index, total);\n  };\n  DateCategoryAxis.prototype.categoriesCount = function categoriesCount() {\n    return this.dataRange.valuesCount();\n  };\n  DateCategoryAxis.prototype.rangeIndices = function rangeIndices() {\n    return this.dataRange.displayIndices();\n  };\n  DateCategoryAxis.prototype.labelsBetweenTicks = function labelsBetweenTicks() {\n    return !this.divisionRange.options.justified;\n  };\n  DateCategoryAxis.prototype.prepareUserOptions = function prepareUserOptions() {\n    if (this.isEmpty()) {\n      return;\n    }\n    this.options.categories = this.dataRange.values();\n  };\n  DateCategoryAxis.prototype.getCategory = function getCategory(point) {\n    var index = this.pointCategoryIndex(point);\n    if (index === null) {\n      return null;\n    }\n    return this.dataRange.dateAt(index);\n  };\n  DateCategoryAxis.prototype.totalIndex = function totalIndex(value) {\n    return this.dataRange.totalIndex(value);\n  };\n  DateCategoryAxis.prototype.currentRangeIndices = function currentRangeIndices() {\n    var range = this.dataRange.valueRange();\n    return {\n      min: this.dataRange.totalIndex(range.min),\n      max: this.dataRange.totalIndex(range.max)\n    };\n  };\n  DateCategoryAxis.prototype.totalRange = function totalRange() {\n    return this.dataRange.total();\n  };\n  DateCategoryAxis.prototype.totalCount = function totalCount() {\n    return this.dataRange.totalCount();\n  };\n  DateCategoryAxis.prototype.isEmpty = function isEmpty() {\n    return !this.options.srcCategories.length;\n  };\n  DateCategoryAxis.prototype.roundedRange = function roundedRange() {\n    if (this.options.roundToBaseUnit !== false || this.isEmpty()) {\n      return this.range();\n    }\n    var options = this.options;\n    var datesRange = categoryRange(options.srcCategories);\n    var dateRange = new DateRange(datesRange.min, datesRange.max, Object.assign({}, options, {\n      justified: false,\n      roundToBaseUnit: true,\n      justifyEnd: false\n    }));\n    return dateRange.displayRange();\n  };\n  return DateCategoryAxis;\n}(CategoryAxis);\nsetDefaultOptions(DateCategoryAxis, {\n  type: DATE,\n  labels: {\n    dateFormats: DateLabelFormats\n  },\n  rangeLabels: {\n    visible: false\n  },\n  autoBaseUnitSteps: {\n    milliseconds: [1, 10, 100],\n    seconds: [1, 2, 5, 15, 30],\n    minutes: [1, 2, 5, 15, 30],\n    hours: [1, 2, 3],\n    days: [1, 2, 3],\n    weeks: [1, 2],\n    months: [1, 2, 3, 6],\n    years: [1, 2, 3, 5, 10, 25, 50]\n  },\n  maxDateGroups: 10\n});\nexport default DateCategoryAxis;","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"var __spreadArray = this && this.__spreadArray || function (to, from, pack) {\n  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\n    if (ar || !(i in from)) {\n      if (!ar) ar = Array.prototype.slice.call(from, 0, i);\n      ar[i] = from[i];\n    }\n  }\n  return to.concat(ar || Array.prototype.slice.call(from));\n};\nimport * as React from 'react';\n/**\n * An utility function for asynchronous focus/blur handling.\n *\n * By default, the `onFocus` and `onBlur` callbacks are called every time a child components receives/loses focus.\n * Use this utility hook for scenarios where you need to know if the parent has received focus for the first time, or completely lost focus.\n *\n * @returns\n */\nexport function useAsyncFocusBlur(_a) {\n  var onFocus = _a.onFocus,\n    onBlur = _a.onBlur,\n    onSyncFocus = _a.onSyncFocus,\n    onSyncBlur = _a.onSyncBlur;\n  var focused = React.useRef(false);\n  var tick = React.useRef(0);\n  var nextTick = React.useCallback(function (f) {\n    clearTimeout(tick.current);\n    tick.current = window.setTimeout(function () {\n      return f();\n    });\n  }, [tick]);\n  var handleFocus = React.useCallback(function () {\n    var event = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      event[_i] = arguments[_i];\n    }\n    clearTimeout(tick.current);\n    if (onSyncFocus) {\n      onSyncFocus.call(undefined, event[0]);\n    }\n    if (focused.current) {\n      return;\n    }\n    ;\n    focused.current = true;\n    if (onFocus) {\n      onFocus.call.apply(onFocus, __spreadArray([undefined], event, false));\n    }\n  }, [focused, onFocus, onSyncFocus]);\n  var handleBlur = React.useCallback(function () {\n    var event = [];\n    for (var _i = 0; _i < arguments.length; _i++) {\n      event[_i] = arguments[_i];\n    }\n    if (onSyncBlur) {\n      onSyncBlur.call(undefined, event[0]);\n    }\n    nextTick(function () {\n      if (!focused.current) {\n        return;\n      }\n      if (onBlur) {\n        focused.current = false;\n        onBlur.call.apply(onBlur, __spreadArray([undefined], event, false));\n      }\n    });\n  }, [focused, nextTick, onBlur, onSyncBlur]);\n  React.useEffect(function () {\n    return function () {\n      clearTimeout(tick.current);\n    };\n  }, []);\n  return {\n    onFocus: handleFocus,\n    onBlur: handleBlur\n  };\n}","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import * as React from 'react';\nimport { dispatchDragAndDrop, autoScroll as autoScrollElement, getScrollableParent } from '@progress/kendo-draggable-common';\nimport { noop } from '../noop';\nimport { useInheritedState } from '../hooks/useInheritedState';\nimport { DragContext, DropContext, DragsContext, DropsContext } from '../drag-n-drop/context';\nvar IGNORE_MOUSE_TIMEOUT = 2000;\n/**\n * Represents the KendoReact `useDraggable` hook.\n * Use it to attach `drag` events to a native HTML DOM elements, or custom React Components.\n *\n * For more information, refer to the [KendoReact Draggable]({% slug draggable_drag-and-drop %}) article.\n *\n * @param ref - The `ref` of the HTML Element or React Component which will enable the `draggable` functionality.\n * @param callbacks - A collection of callbacks, called by the `useDraggable` hook when a specific action occurs.\n * @param options - Additional configuration of the `useDraggable` hook.\n */\nexport function useDraggable(ref, callbacks, options) {\n  if (options === void 0) {\n    options = {};\n  }\n  var _a = callbacks.onPress,\n    onPress = _a === void 0 ? noop : _a,\n    _b = callbacks.onRelease,\n    onRelease = _b === void 0 ? noop : _b,\n    _c = callbacks.onDragStart,\n    onDragStart = _c === void 0 ? noop : _c,\n    _d = callbacks.onDrag,\n    onDrag = _d === void 0 ? noop : _d,\n    _e = callbacks.onDragEnd,\n    onDragEnd = _e === void 0 ? noop : _e;\n  var _f = options.hint,\n    hint = _f === void 0 ? null : _f,\n    _g = options.mouseOnly,\n    mouseOnly = _g === void 0 ? false : _g,\n    _h = options.autoScroll,\n    autoScroll = _h === void 0 ? true : _h,\n    _j = options.scrollContainer,\n    scrollContainer = _j === void 0 ? null : _j;\n  var _k = React.useState(false),\n    pressed = _k[0],\n    setPressed = _k[1];\n  var _l = React.useState(false),\n    scrolling = _l[0],\n    setScrolling = _l[1];\n  var drop = useInheritedState(DropContext)[0];\n  var _m = useInheritedState(DragContext),\n    drag = _m[0],\n    setDrag = _m[1];\n  var drops = React.useContext(DropsContext)[0];\n  var _o = React.useContext(DragsContext),\n    drags = _o[0],\n    registerDrag = _o[1],\n    deregisterDrag = _o[2];\n  var velocity = React.useRef({\n    x: 0,\n    y: 0\n  });\n  var scrollInterval = React.useRef();\n  var ignoreMouse = React.useRef(false);\n  var restoreMouseTimeout = React.useRef();\n  var scrollable = React.useRef(null);\n  var unmount = React.useRef(false);\n  var offset = React.useRef({\n    x: 0,\n    y: 0\n  });\n  var pageOffset = React.useRef({\n    x: 0,\n    y: 0\n  });\n  var clientOffset = React.useRef({\n    x: 0,\n    y: 0\n  });\n  var initialClientOffset = React.useRef({\n    x: 0,\n    y: 0\n  });\n  var scrollOffset = React.useRef({\n    x: 0,\n    y: 0\n  });\n  var initialScrollOffset = React.useRef({\n    x: 0,\n    y: 0\n  });\n  var supportPointerEvent = Boolean(typeof window !== 'undefined' && window.PointerEvent);\n  var pointers = !mouseOnly && supportPointerEvent;\n  var getElement = React.useCallback(function () {\n    return ref.current && ref.current.element ? ref.current.element : ref.current;\n  }, [ref]);\n  var getHintElement = React.useCallback(function () {\n    return hint && hint.current && hint.current.element ? hint.current.element : hint ? hint.current : null;\n  }, [hint]);\n  var getScrollContainer = React.useCallback(function () {\n    return scrollContainer && scrollContainer.current && scrollContainer.current.element ? scrollContainer.current.element : scrollContainer ? scrollContainer.current : null;\n  }, [scrollContainer]);\n  var getAutoScrollContainer = React.useCallback(function () {\n    return typeof autoScroll === 'object' && autoScroll.boundaryElementRef && autoScroll.boundaryElementRef.current && autoScroll.boundaryElementRef.current.element ? autoScroll.boundaryElementRef.current.element : typeof autoScroll === 'object' && autoScroll.boundaryElementRef && autoScroll.boundaryElementRef.current ? autoScroll.boundaryElementRef.current : null;\n  }, [autoScroll]);\n  var target = React.useRef(null);\n  React.useImperativeHandle(target, function () {\n    return {\n      element: getElement(),\n      hint: getHintElement(),\n      onPress: handlePress,\n      onDragStart: handleDragStart,\n      onDrag: handleDrag,\n      onDragEnd: handleDragEnd,\n      onRelease: handleRelease,\n      data: ref.current\n    };\n  });\n  var getDocument = React.useCallback(function () {\n    var element = getElement();\n    return element ? element.ownerDocument || document : document;\n  }, [getElement]);\n  var getWindow = React.useCallback(function () {\n    var document = getDocument();\n    return document ? document.defaultView || window : window;\n  }, [getDocument]);\n  var getState = React.useCallback(function () {\n    return {\n      drag: drag ? drag.current : null,\n      drop: drop ? drop.current : null,\n      drags: drags.map(function (d) {\n        return d.current;\n      }),\n      drops: drops.map(function (d) {\n        return d.current;\n      }),\n      pressed: pressed,\n      ignoreMouse: ignoreMouse.current,\n      scrollOffset: scrollOffset.current,\n      offset: offset.current,\n      pageOffset: pageOffset.current,\n      initialScrollOffset: initialScrollOffset.current,\n      clientOffset: clientOffset.current,\n      initialClientOffset: initialClientOffset.current,\n      velocity: velocity.current,\n      autoScroll: Boolean(typeof autoScroll === 'object' ? autoScroll.enabled !== false : autoScroll),\n      scrollableParent: getAutoScrollContainer(),\n      autoScrollDirection: typeof autoScroll === 'object' ? autoScroll.direction : {\n        horizontal: true,\n        vertical: true\n      },\n      isScrolling: scrolling\n    };\n  }, [drag, drop, drags, drops, pressed, autoScroll, getAutoScrollContainer, scrolling]);\n  var handlePressedChange = React.useCallback(function (value) {\n    setPressed(value);\n  }, []);\n  var handleScrollingChange = React.useCallback(function (value) {\n    setScrolling(value);\n  }, []);\n  var handleVelocityChange = React.useCallback(function (value) {\n    velocity.current = value;\n  }, []);\n  var handleOffsetChange = React.useCallback(function (value) {\n    offset.current = value;\n  }, []);\n  var handleClientOffsetChange = React.useCallback(function (value) {\n    clientOffset.current = value;\n  }, []);\n  var handlePageOffsetChange = React.useCallback(function (value) {\n    pageOffset.current = value;\n  }, []);\n  var handleInitialClientOffsetChange = React.useCallback(function (value) {\n    initialClientOffset.current = value;\n  }, []);\n  var handleScrollOffsetChange = React.useCallback(function (value) {\n    scrollOffset.current = value;\n  }, []);\n  var handleInitialScrollOffsetChange = React.useCallback(function (value) {\n    initialScrollOffset.current = value;\n  }, []);\n  // Drag Events\n  var handlePress = React.useCallback(function (event) {\n    onPress(event);\n  }, [onPress]);\n  var handleRelease = React.useCallback(function (event) {\n    onRelease(event);\n  }, [onRelease]);\n  var handleDragStart = React.useCallback(function (event) {\n    setDrag(target, {\n      target: ref.current,\n      event: event\n    });\n    onDragStart(event);\n  }, [setDrag, ref, onDragStart]);\n  var handleDrag = React.useCallback(function (event) {\n    onDrag(event);\n  }, [onDrag]);\n  var handleDragEnd = React.useCallback(function (event) {\n    if (unmount.current) {\n      return;\n    }\n    setDrag(null, {\n      target: ref.current,\n      event: event\n    });\n    onDragEnd(event);\n  }, [onDragEnd, setDrag, ref]);\n  var dispatchDragEvent = React.useCallback(function (event) {\n    dispatchDragAndDrop(getState(), {\n      event: event,\n      payload: target.current\n    }, {\n      onVelocityChange: handleVelocityChange,\n      onOffsetChange: handleOffsetChange,\n      onClientOffsetChange: handleClientOffsetChange,\n      onPageOffsetChange: handlePageOffsetChange,\n      onInitialClientOffsetChange: handleInitialClientOffsetChange,\n      onScrollOffsetChange: handleScrollOffsetChange,\n      onInitialScrollOffsetChange: handleInitialScrollOffsetChange,\n      onIsPressedChange: handlePressedChange,\n      onIsScrollingChange: handleScrollingChange\n    });\n  }, [getState, handleVelocityChange, handleOffsetChange, handlePageOffsetChange, handleClientOffsetChange, handleInitialClientOffsetChange, handleInitialScrollOffsetChange, handlePressedChange, handleScrollOffsetChange, handleScrollingChange]);\n  // Pointer Events\n  var handlePointerDown = React.useCallback(function (event) {\n    dispatchDragEvent(event);\n  }, [dispatchDragEvent]);\n  var handlePointerMove = React.useCallback(function (event) {\n    dispatchDragEvent(event);\n  }, [dispatchDragEvent]);\n  var handlePointerCancel = React.useCallback(function (event) {\n    dispatchDragEvent(event);\n  }, [dispatchDragEvent]);\n  var handlePointerUp = React.useCallback(function (event) {\n    dispatchDragEvent(event);\n  }, [dispatchDragEvent]);\n  // Mouse Events\n  var handleMouseDown = React.useCallback(function (event) {\n    dispatchDragEvent(event);\n  }, [dispatchDragEvent]);\n  var handleMouseMove = React.useCallback(function (event) {\n    dispatchDragEvent(event);\n  }, [dispatchDragEvent]);\n  var handleMouseUp = React.useCallback(function (event) {\n    dispatchDragEvent(event);\n  }, [dispatchDragEvent]);\n  var handleContextMenu = React.useCallback(function (event) {\n    event.preventDefault();\n    dispatchDragEvent(event);\n  }, [dispatchDragEvent]);\n  // Touch Events\n  var handleTouchStart = React.useCallback(function (event) {\n    event.preventDefault();\n    dispatchDragEvent(event);\n  }, [dispatchDragEvent]);\n  var handleTouchMove = React.useCallback(function (event) {\n    event.preventDefault();\n    dispatchDragEvent(event);\n  }, [dispatchDragEvent]);\n  var handleTouchEnd = React.useCallback(function (event) {\n    if (event.touches.length === 0 && event.changedTouches.length === 1) {\n      var currentWindow = getWindow();\n      ignoreMouse.current = true;\n      restoreMouseTimeout.current = currentWindow.setTimeout(function () {\n        ignoreMouse.current = false;\n      }, IGNORE_MOUSE_TIMEOUT);\n    }\n    dispatchDragEvent(event);\n  }, [dispatchDragEvent, getWindow]);\n  var handleScroll = React.useCallback(function (event) {\n    dispatchDragEvent(event);\n  }, [dispatchDragEvent]);\n  // Misc\n  var prerequisites = React.useCallback(function () {\n    var element = getElement();\n    if (element) {\n      var initialTouchAction_1 = element.style.touchAction;\n      element.style.touchAction = 'none';\n      return function () {\n        element.style.touchAction = initialTouchAction_1;\n      };\n    }\n  }, [getElement]);\n  var register = React.useCallback(function () {\n    registerDrag(target);\n    return function () {\n      deregisterDrag(target);\n    };\n  }, [deregisterDrag, registerDrag]);\n  var init = function init() {\n    var window = getWindow();\n    var element = getElement();\n    var document = getDocument();\n    if (pointers) {\n      if (element) {\n        scrollable.current = getScrollableParent(element);\n        if (scrollable.current) {\n          scrollable.current.addEventListener('scroll', handleScroll, {\n            passive: true\n          });\n        }\n        element.addEventListener('pointerdown', handlePointerDown, {\n          passive: true\n        });\n      }\n      if (pressed) {\n        document.addEventListener('pointermove', handlePointerMove);\n        document.addEventListener('pointerup', handlePointerUp, true);\n        document.addEventListener('contextmenu', handleContextMenu);\n        document.addEventListener('pointercancel', handlePointerCancel, {\n          passive: true\n        });\n      }\n    } else {\n      // Hacky-hacky iOS Safari\n      window.addEventListener('touchmove', noop, {\n        capture: false,\n        passive: false\n      });\n      if (element) {\n        element.addEventListener('mousedown', handleMouseDown, {\n          passive: true\n        });\n        if (!mouseOnly) {\n          element.addEventListener('touchstart', handleTouchStart, {\n            passive: true\n          });\n          if (pressed) {\n            element.addEventListener('touchmove', handleTouchMove, {\n              passive: true\n            });\n            element.addEventListener('touchend', handleTouchEnd, {\n              passive: true\n            });\n          }\n        }\n      }\n      if (pressed) {\n        document.addEventListener('mousemove', handleMouseMove, {\n          passive: true\n        });\n        document.addEventListener('mouseup', handleMouseUp, {\n          passive: true\n        });\n      }\n    }\n    return function () {\n      if (scrollable.current) {\n        scrollable.current.removeEventListener('scroll', handleScroll);\n      }\n      if (element) {\n        element.removeEventListener('pointerdown', handlePointerDown);\n        element.removeEventListener('mousedown', handleMouseDown);\n        element.removeEventListener('touchstart', handleTouchStart);\n        element.removeEventListener('touchmove', handleTouchMove);\n        element.removeEventListener('touchend', handleTouchEnd);\n      }\n      document.removeEventListener('pointermove', handlePointerMove);\n      document.removeEventListener('pointerup', handlePointerUp, true);\n      document.removeEventListener('contextmenu', handleContextMenu);\n      document.removeEventListener('pointercancel', handlePointerCancel);\n      document.removeEventListener('mousemove', handleMouseMove);\n      document.removeEventListener('mouseup', handleMouseUp);\n      window.removeEventListener('touchmove', noop);\n      window.clearTimeout(restoreMouseTimeout.current);\n    };\n  };\n  React.useEffect(function () {\n    var window = getWindow();\n    if (scrolling) {\n      var scrollableParent_1 = getScrollContainer() || getScrollableParent(document.elementFromPoint(clientOffset.current.x, clientOffset.current.y));\n      window.clearInterval(scrollInterval.current);\n      scrollInterval.current = window.setInterval(function () {\n        autoScrollElement(scrollableParent_1, {\n          x: velocity.current.x,\n          y: velocity.current.y\n        });\n      }, 50);\n    }\n    return function () {\n      window.clearInterval(scrollInterval.current);\n    };\n  }, [getElement, getScrollContainer, getWindow, scrolling]);\n  React.useEffect(prerequisites, [prerequisites]);\n  React.useEffect(init, [pressed, getWindow, getElement, getDocument, mouseOnly, pointers, handleContextMenu, handleMouseDown, handleMouseMove, handleMouseUp, handlePointerCancel, handlePointerDown, handlePointerMove, handlePointerUp, handleTouchEnd, handleTouchMove, handleTouchStart, handleScroll]);\n  React.useEffect(function () {\n    unmount.current = false;\n    return function () {\n      unmount.current = true;\n    };\n  }, []);\n  React.useLayoutEffect(register, [register]);\n}","map":null,"metadata":{},"sourceType":"module"}
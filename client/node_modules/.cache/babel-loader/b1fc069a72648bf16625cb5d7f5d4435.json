{"ast":null,"code":"import { toBitsString, toDecimal } from '../utils';\nimport { FreeCellVisitor } from './free-cell-visitor';\nimport { IsoEncoder } from './encoders/iso-encoder';\nimport { Utf8Encoder } from './encoders/utf8-encoder';\nimport { VersionsCodewordsInformation } from './version-codewords';\nimport { DataModeInstances } from './data-modes/data-mode-instances';\nvar terminator = \"0000\",\n  NUMERIC = \"numeric\",\n  ALPHA_NUMERIC = \"alphanumeric\",\n  BYTE = \"byte\",\n  powersOfTwo = {\n    \"1\": 0\n  },\n  powersOfTwoResult = {\n    \"0\": 1\n  },\n  irregularAlignmentPatternsStartDistance = {\n    15: 20,\n    16: 20,\n    18: 24,\n    19: 24,\n    22: 20,\n    24: 22,\n    26: 24,\n    28: 20,\n    30: 20,\n    31: 24,\n    32: 28,\n    33: 24,\n    36: 18,\n    37: 22,\n    39: 20,\n    40: 24\n  },\n  finderPattern = [1, 0, 1, 1, 1],\n  alignmentPattern = [1, 0, 1],\n  errorCorrectionPatterns = {\n    L: \"01\",\n    M: \"00\",\n    Q: \"11\",\n    H: \"10\"\n  },\n  formatMaskPattern = \"101010000010010\",\n  formatGeneratorPolynomial = \"10100110111\",\n  versionGeneratorPolynomial = \"1111100100101\",\n  paddingCodewords = [\"11101100\", \"00010001\"],\n  finderPatternValue = 93,\n  /* eslint-disable arrow-body-style */\n  /* eslint-disable no-unused-vars */\n  maskPatternConditions = [function (row, column) {\n    return (row + column) % 2 === 0;\n  }, function (row, column) {\n    return row % 2 === 0;\n  }, function (row, column) {\n    return column % 3 === 0;\n  }, function (row, column) {\n    return (row + column) % 3 === 0;\n  }, function (row, column) {\n    return (Math.floor(row / 2) + Math.floor(column / 3)) % 2 === 0;\n  }, function (row, column) {\n    return row * column % 2 + row * column % 3 === 0;\n  }, function (row, column) {\n    return (row * column % 2 + row * column % 3) % 2 === 0;\n  }, function (row, column) {\n    return ((row + column) % 2 + row * column % 3) % 2 === 0;\n  }],\n  /* eslint-enable no-unused-vars */\n  /* eslint-enable arrow-body-style */\n  numberRegex = /^\\d+/,\n  alphaPattern = \"A-Z0-9 $%*+./:-\",\n  alphaExclusiveSet = \"A-Z $%*+./:-\",\n  alphaRegex = new RegExp(\"^[\" + alphaExclusiveSet + \"]+\"),\n  alphaNumericRegex = new RegExp(\"^[\" + alphaPattern + \"]+\"),\n  byteRegex = new RegExp(\"^[^\" + alphaPattern + \"]+\"),\n  initMinNumericBeforeAlpha = 8,\n  initMinNumericBeforeByte = 5,\n  initMinAlphaBeforeByte = 8,\n  minNumericBeforeAlpha = 17,\n  minNumericBeforeByte = 9,\n  minAlphaBeforeByte = 16;\nexport var generatorPolynomials = [[1, 0], [1, 25, 0]];\nexport function fillFunctionCell(matrices, bit, x, y) {\n  for (var i = 0; i < matrices.length; i++) {\n    matrices[i][x][y] = bit;\n  }\n}\nexport function fillDataCell(matrices, bit, x, y) {\n  for (var i = 0; i < maskPatternConditions.length; i++) {\n    matrices[i][x][y] = maskPatternConditions[i](x, y) ? bit ^ 1 : parseInt(bit, 10);\n  }\n}\nexport function fillData(matrices, blocks) {\n  var cellVisitor = new FreeCellVisitor(matrices[0]),\n    block,\n    codewordIdx,\n    cell;\n  for (var blockIdx = 0; blockIdx < blocks.length; blockIdx++) {\n    block = blocks[blockIdx];\n    codewordIdx = 0;\n    while (block.length > 0) {\n      for (var i = 0; i < block.length; i++) {\n        for (var j = 0; j < 8; j++) {\n          cell = cellVisitor.getNextCell();\n          fillDataCell(matrices, block[i][codewordIdx].charAt(j), cell.row, cell.column);\n        }\n      }\n      codewordIdx++;\n      while (block[0] && codewordIdx === block[0].length) {\n        block.splice(0, 1);\n      }\n    }\n  }\n  while (cell = cellVisitor.getNextRemainderCell()) {\n    fillDataCell(matrices, 0, cell.row, cell.column);\n  }\n}\nexport function padDataString(initialDataString, totalDataCodewords) {\n  var dataBitsCount = totalDataCodewords * 8,\n    terminatorIndex = 0,\n    paddingCodewordIndex = 0;\n  var dataString = initialDataString;\n  while (dataString.length < dataBitsCount && terminatorIndex < terminator.length) {\n    dataString += terminator.charAt(terminatorIndex++);\n  }\n  if (dataString.length % 8 !== 0) {\n    dataString += new Array(9 - dataString.length % 8).join(\"0\");\n  }\n  while (dataString.length < dataBitsCount) {\n    dataString += paddingCodewords[paddingCodewordIndex];\n    paddingCodewordIndex ^= 1;\n  }\n  return dataString;\n}\nexport function generatePowersOfTwo() {\n  var result;\n  var power;\n  for (power = 1; power < 255; power++) {\n    result = powersOfTwoResult[power - 1] * 2;\n    if (result > 255) {\n      result = result ^ 285;\n    }\n    powersOfTwoResult[power] = result;\n    powersOfTwo[result] = power;\n  }\n  result = powersOfTwoResult[power - 1] * 2 ^ 285;\n  powersOfTwoResult[power] = result;\n  powersOfTwoResult[-1] = 0;\n}\nexport function xorPolynomials(x, y) {\n  var result = [],\n    idx = x.length - 2;\n  for (var i = idx; i >= 0; i--) {\n    result[i] = x[i] ^ y[i];\n  }\n  return result;\n}\nexport function multiplyPolynomials(x, y) {\n  var result = [];\n  for (var i = 0; i < x.length; i++) {\n    for (var j = 0; j < y.length; j++) {\n      if (result[i + j] === undefined) {\n        result[i + j] = (x[i] + (y[j] >= 0 ? y[j] : 0)) % 255;\n      } else {\n        result[i + j] = powersOfTwo[powersOfTwoResult[result[i + j]] ^ powersOfTwoResult[(x[i] + y[j]) % 255]];\n      }\n    }\n  }\n  return result;\n}\nexport function generateGeneratorPolynomials() {\n  var maxErrorCorrectionCodeWordsCount = 68;\n  for (var idx = 2; idx <= maxErrorCorrectionCodeWordsCount; idx++) {\n    var firstPolynomial = generatorPolynomials[idx - 1],\n      secondPolynomial = [idx, 0];\n    generatorPolynomials[idx] = multiplyPolynomials(firstPolynomial, secondPolynomial);\n  }\n}\n\n//possibly generate on demand\ngeneratePowersOfTwo();\ngenerateGeneratorPolynomials();\nexport function multiplyByConstant(polynomial, power) {\n  var result = [],\n    idx = polynomial.length - 1;\n  do {\n    result[idx] = powersOfTwoResult[(polynomial[idx] + power) % 255];\n    idx--;\n  } while (polynomial[idx] !== undefined);\n  return result;\n}\nexport function generateErrorCodewords(data, errorCodewordsCount) {\n  var generator = generatorPolynomials[errorCodewordsCount - 1],\n    result = new Array(errorCodewordsCount).concat(data),\n    generatorPolynomial = new Array(result.length - generator.length).concat(generator),\n    steps = data.length,\n    errorCodewords = [],\n    divisor,\n    idx;\n  for (idx = 0; idx < steps; idx++) {\n    divisor = multiplyByConstant(generatorPolynomial, powersOfTwo[result[result.length - 1]]);\n    generatorPolynomial.splice(0, 1);\n    result = xorPolynomials(divisor, result);\n  }\n  for (idx = result.length - 1; idx >= 0; idx--) {\n    errorCodewords[errorCodewordsCount - 1 - idx] = toBitsString(result[idx], 8);\n  }\n  return errorCodewords;\n}\nexport function getBlocks(dataStream, versionCodewordsInformation) {\n  var codewordStart = 0,\n    dataBlocks = [],\n    errorBlocks = [],\n    dataBlock,\n    versionGroups = versionCodewordsInformation.groups,\n    blockCodewordsCount,\n    groupBlocksCount,\n    messagePolynomial,\n    codeword;\n  for (var groupIdx = 0; groupIdx < versionGroups.length; groupIdx++) {\n    groupBlocksCount = versionGroups[groupIdx][0];\n    for (var blockIdx = 0; blockIdx < groupBlocksCount; blockIdx++) {\n      blockCodewordsCount = versionGroups[groupIdx][1];\n      dataBlock = [];\n      messagePolynomial = [];\n      for (var codewordIdx = 1; codewordIdx <= blockCodewordsCount; codewordIdx++) {\n        codeword = dataStream.substring(codewordStart, codewordStart + 8);\n        dataBlock.push(codeword);\n        messagePolynomial[blockCodewordsCount - codewordIdx] = toDecimal(codeword);\n        codewordStart += 8;\n      }\n      dataBlocks.push(dataBlock);\n      errorBlocks.push(generateErrorCodewords(messagePolynomial, versionCodewordsInformation.errorCodewordsPerBlock));\n    }\n  }\n  return [dataBlocks, errorBlocks];\n}\nexport function chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode) {\n  var numeric = numberRegex.exec(str),\n    numericMatch = numeric ? numeric[0] : \"\",\n    alpha = alphaRegex.exec(str),\n    alphaMatch = alpha ? alpha[0] : \"\",\n    alphaNumeric = alphaNumericRegex.exec(str),\n    alphaNumericMatch = alphaNumeric ? alphaNumeric[0] : \"\",\n    mode,\n    modeString;\n  if (numericMatch && (numericMatch.length >= minNumericBeforeAlpha || str.length === numericMatch.length || numericMatch.length >= minNumericBeforeByte && !alphaNumericRegex.test(str.charAt(numericMatch.length)))) {\n    mode = NUMERIC;\n    modeString = numericMatch;\n  } else if (alphaNumericMatch && (str.length === alphaNumericMatch.length || alphaNumericMatch.length >= minAlphaBeforeByte || previousMode === ALPHA_NUMERIC)) {\n    mode = ALPHA_NUMERIC;\n    modeString = numericMatch || alphaMatch;\n  } else {\n    mode = BYTE;\n    if (alphaNumericMatch) {\n      modeString = alphaNumericMatch + byteRegex.exec(str.substring(alphaNumericMatch.length))[0];\n    } else {\n      modeString = byteRegex.exec(str)[0];\n    }\n  }\n  return {\n    mode: mode,\n    modeString: modeString\n  };\n}\nexport function getModes(inputString) {\n  var modes = [],\n    previousMode,\n    idx = 0;\n  var str = inputString;\n  modes.push(chooseMode(str, initMinNumericBeforeAlpha, initMinNumericBeforeByte, initMinAlphaBeforeByte, previousMode));\n  previousMode = modes[0].mode;\n  str = str.substr(modes[0].modeString.length);\n  while (str.length > 0) {\n    var nextMode = chooseMode(str, minNumericBeforeAlpha, minNumericBeforeByte, minAlphaBeforeByte, previousMode);\n    if (nextMode.mode !== previousMode) {\n      previousMode = nextMode.mode;\n      modes.push(nextMode);\n      idx++;\n    } else {\n      modes[idx].modeString += nextMode.modeString;\n    }\n    str = str.substr(nextMode.modeString.length);\n  }\n  return modes;\n}\nexport function getDataCodewordsCount(modes) {\n  var length = 0,\n    mode;\n  for (var i = 0; i < modes.length; i++) {\n    mode = DataModeInstances[modes[i].mode];\n    length += mode.getStringBitsLength(modes[i].modeString.length);\n  }\n  return Math.ceil(length / 8);\n}\nexport function getVersion(dataCodewordsCount, errorCorrectionLevel) {\n  var x = 0,\n    y = VersionsCodewordsInformation.length - 1,\n    version = Math.floor(VersionsCodewordsInformation.length / 2);\n  do {\n    if (dataCodewordsCount < VersionsCodewordsInformation[version][errorCorrectionLevel].totalDataCodewords) {\n      y = version;\n    } else {\n      x = version;\n    }\n    version = x + Math.floor((y - x) / 2);\n  } while (y - x > 1);\n  if (dataCodewordsCount <= VersionsCodewordsInformation[x][errorCorrectionLevel].totalDataCodewords) {\n    return version + 1;\n  }\n  return y + 1;\n}\nexport function getDataString(modes, version) {\n  var dataString = \"\",\n    mode;\n  for (var i = 0; i < modes.length; i++) {\n    mode = DataModeInstances[modes[i].mode];\n    dataString += mode.encode(modes[i].modeString, version);\n  }\n  return dataString;\n}\n\n//fix case all zeros\nexport function encodeFormatInformation(format) {\n  var formatNumber = toDecimal(format),\n    encodedString,\n    result = \"\";\n  if (formatNumber === 0) {\n    return \"101010000010010\";\n  }\n  encodedString = encodeBCH(toDecimal(format), formatGeneratorPolynomial, 15);\n  for (var i = 0; i < encodedString.length; i++) {\n    result += encodedString.charAt(i) ^ formatMaskPattern.charAt(i);\n  }\n  return result;\n}\nexport function encodeBCH(value, generatorPolynomial, codeLength) {\n  var generatorNumber = toDecimal(generatorPolynomial),\n    polynomialLength = generatorPolynomial.length - 1,\n    valueNumber = value << polynomialLength,\n    length = codeLength - polynomialLength,\n    valueString = toBitsString(value, length),\n    result = dividePolynomials(valueNumber, generatorNumber);\n  result = valueString + toBitsString(result, polynomialLength);\n  return result;\n}\nexport function dividePolynomials(numberX, numberY) {\n  var yLength = numberY.toString(2).length,\n    xLength = numberX.toString(2).length;\n  var x = numberX;\n  do {\n    x ^= numberY << xLength - yLength;\n    xLength = x.toString(2).length;\n  } while (xLength >= yLength);\n  return x;\n}\nexport function getNumberAt(str, idx) {\n  return parseInt(str.charAt(idx), 10);\n}\nexport function initMatrices(version) {\n  var matrices = [],\n    modules = 17 + 4 * version;\n  for (var i = 0; i < maskPatternConditions.length; i++) {\n    matrices[i] = new Array(modules);\n    for (var j = 0; j < modules; j++) {\n      matrices[i][j] = new Array(modules);\n    }\n  }\n  return matrices;\n}\nexport function addFormatInformation(matrices, formatString) {\n  var matrix = matrices[0],\n    x,\n    y,\n    idx = 0,\n    length = formatString.length;\n  for (x = 0, y = 8; x <= 8; x++) {\n    if (x !== 6) {\n      fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n    }\n  }\n  for (x = 8, y = 7; y >= 0; y--) {\n    if (y !== 6) {\n      fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n    }\n  }\n  idx = 0;\n  for (y = matrix.length - 1, x = 8; y >= matrix.length - 8; y--) {\n    fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n  }\n  fillFunctionCell(matrices, 1, matrix.length - 8, 8);\n  for (x = matrix.length - 7, y = 8; x < matrix.length; x++) {\n    fillFunctionCell(matrices, getNumberAt(formatString, length - 1 - idx++), x, y);\n  }\n}\nexport function encodeVersionInformation(version) {\n  return encodeBCH(version, versionGeneratorPolynomial, 18);\n}\nexport function addVersionInformation(matrices, dataString) {\n  var matrix = matrices[0],\n    modules = matrix.length,\n    x1 = 0,\n    y1 = modules - 11,\n    x2 = modules - 11,\n    y2 = 0,\n    quotient,\n    mod,\n    value;\n  for (var idx = 0; idx < dataString.length; idx++) {\n    quotient = Math.floor(idx / 3);\n    mod = idx % 3;\n    value = getNumberAt(dataString, dataString.length - idx - 1);\n    fillFunctionCell(matrices, value, x1 + quotient, y1 + mod);\n    fillFunctionCell(matrices, value, x2 + mod, y2 + quotient);\n  }\n}\nexport function addCentricPattern(matrices, pattern, x, y) {\n  var size = pattern.length + 2,\n    length = pattern.length + 1,\n    value;\n  for (var i = 0; i < pattern.length; i++) {\n    for (var j = i; j < size - i; j++) {\n      value = pattern[i];\n      fillFunctionCell(matrices, value, x + j, y + i);\n      fillFunctionCell(matrices, value, x + i, y + j);\n      fillFunctionCell(matrices, value, x + length - j, y + length - i);\n      fillFunctionCell(matrices, value, x + length - i, y + length - j);\n    }\n  }\n}\nexport function addFinderSeparator(matrices, direction, x, y) {\n  var nextX = x,\n    nextY = y,\n    matrix = matrices[0];\n  do {\n    fillFunctionCell(matrices, 0, nextX, y);\n    fillFunctionCell(matrices, 0, x, nextY);\n    nextX += direction[0];\n    nextY += direction[1];\n  } while (nextX >= 0 && nextX < matrix.length);\n}\nexport function addFinderPatterns(matrices) {\n  var modules = matrices[0].length;\n  addCentricPattern(matrices, finderPattern, 0, 0);\n  addFinderSeparator(matrices, [-1, -1], 7, 7);\n  addCentricPattern(matrices, finderPattern, modules - 7, 0);\n  addFinderSeparator(matrices, [1, -1], modules - 8, 7);\n  addCentricPattern(matrices, finderPattern, 0, modules - 7);\n  addFinderSeparator(matrices, [-1, 1], 7, modules - 8);\n}\nexport function addAlignmentPatterns(matrices, version) {\n  if (version < 2) {\n    return;\n  }\n  var matrix = matrices[0],\n    modules = matrix.length,\n    pointsCount = Math.floor(version / 7),\n    points = [6],\n    startDistance,\n    distance,\n    idx = 0;\n  if (startDistance = irregularAlignmentPatternsStartDistance[version]) {\n    distance = (modules - 13 - startDistance) / pointsCount;\n  } else {\n    startDistance = distance = (modules - 13) / (pointsCount + 1);\n  }\n  points.push(points[idx++] + startDistance);\n  while (points[idx] + distance < modules) {\n    points.push(points[idx++] + distance);\n  }\n  for (var i = 0; i < points.length; i++) {\n    for (var j = 0; j < points.length; j++) {\n      if (matrix[points[i]][points[j]] === undefined) {\n        addCentricPattern(matrices, alignmentPattern, points[i] - 2, points[j] - 2);\n      }\n    }\n  }\n}\nexport function addTimingFunctions(matrices) {\n  var row = 6,\n    column = 6,\n    value = 1,\n    modules = matrices[0].length;\n  for (var i = 8; i < modules - 8; i++) {\n    fillFunctionCell(matrices, value, row, i);\n    fillFunctionCell(matrices, value, i, column);\n    value ^= 1;\n  }\n}\nexport function scoreMaskMatrixes(matrices) {\n  var scores = [],\n    previousBits = [],\n    darkModules = [],\n    patterns = [],\n    adjacentSameBits = [],\n    matrix,\n    i,\n    row = 0,\n    column = 1,\n    modulesLength = matrices[0].length;\n  for (i = 0; i < matrices.length; i++) {\n    scores[i] = 0;\n    darkModules[i] = 0;\n    adjacentSameBits[i] = [0, 0];\n    patterns[i] = [0, 0];\n    previousBits[i] = [];\n  }\n  for (var rowIndex = 0; rowIndex < modulesLength; rowIndex++) {\n    for (var columnIndex = 0; columnIndex < modulesLength; columnIndex++) {\n      for (var matrixIndex = 0; matrixIndex < matrices.length; matrixIndex++) {\n        matrix = matrices[matrixIndex];\n        darkModules[matrixIndex] += parseInt(matrix[rowIndex][columnIndex], 10);\n        if (previousBits[matrixIndex][row] === matrix[rowIndex][columnIndex] && rowIndex + 1 < modulesLength && columnIndex - 1 >= 0 && matrix[rowIndex + 1][columnIndex] === previousBits[matrixIndex][row] && matrix[rowIndex + 1][columnIndex - 1] === previousBits[matrixIndex][row]) {\n          scores[matrixIndex] += 3;\n        }\n        scoreFinderPatternOccurance(matrixIndex, patterns, scores, row, matrix[rowIndex][columnIndex]);\n        scoreFinderPatternOccurance(matrixIndex, patterns, scores, column, matrix[columnIndex][rowIndex]);\n        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[rowIndex][columnIndex], adjacentSameBits, row);\n        scoreAdjacentSameBits(matrixIndex, scores, previousBits, matrix[columnIndex][rowIndex], adjacentSameBits, column);\n      }\n    }\n  }\n  var total = modulesLength * modulesLength,\n    minIdx,\n    min = Number.MAX_VALUE;\n  for (i = 0; i < scores.length; i++) {\n    scores[i] += calculateDarkModulesRatioScore(darkModules[i], total);\n    if (scores[i] < min) {\n      min = scores[i];\n      minIdx = i;\n    }\n  }\n  return minIdx;\n}\nexport function scoreFinderPatternOccurance(idx, patterns, scores, rowColumn, bit) {\n  patterns[idx][rowColumn] = (patterns[idx][rowColumn] << 1 ^ bit) % 128;\n  if (patterns[idx][rowColumn] === finderPatternValue) {\n    scores[idx] += 40;\n  }\n}\nexport function scoreAdjacentSameBits(idx, scores, previousBits, bit, adjacentBits, rowColumn) {\n  if (previousBits[idx][rowColumn] === bit) {\n    adjacentBits[idx][rowColumn]++;\n  } else {\n    previousBits[idx][rowColumn] = bit;\n    if (adjacentBits[idx][rowColumn] >= 5) {\n      scores[idx] += 3 + adjacentBits[idx][rowColumn] - 5;\n    }\n    adjacentBits[idx][rowColumn] = 1;\n  }\n}\nexport function calculateDarkModulesRatioScore(darkModules, total) {\n  var percent = Math.floor(darkModules / total * 100),\n    mod5 = percent % 5,\n    previous = Math.abs(percent - mod5 - 50),\n    next = Math.abs(percent + 5 - mod5 - 50),\n    score = 10 * Math.min(previous / 5, next / 5);\n  return score;\n}\nexport function createQRCodeDataEncoder(encoding) {\n  if (encoding && encoding.toLowerCase().indexOf(\"utf_8\") >= 0) {\n    return new Utf8Encoder();\n  }\n  return new IsoEncoder();\n}\nexport function encodeData(inputString, errorCorrectionLevel, encoding) {\n  var encoder = createQRCodeDataEncoder(encoding),\n    encodingResult = encoder.getEncodingResult(inputString, errorCorrectionLevel),\n    version = encodingResult.version,\n    versionInformation = VersionsCodewordsInformation[version - 1][errorCorrectionLevel],\n    dataString = padDataString(encodingResult.dataString, versionInformation.totalDataCodewords),\n    blocks = getBlocks(dataString, versionInformation),\n    matrices = initMatrices(version);\n  addFinderPatterns(matrices);\n  addAlignmentPatterns(matrices, version);\n  addTimingFunctions(matrices);\n  if (version >= 7) {\n    addVersionInformation(matrices, toBitsString(0, 18));\n  }\n  addFormatInformation(matrices, toBitsString(0, 15));\n  fillData(matrices, blocks);\n  var minIdx = scoreMaskMatrixes(matrices),\n    optimalMatrix = matrices[minIdx];\n  if (version >= 7) {\n    addVersionInformation([optimalMatrix], encodeVersionInformation(version));\n  }\n  var formatString = errorCorrectionPatterns[errorCorrectionLevel] + toBitsString(minIdx, 3);\n  addFormatInformation([optimalMatrix], encodeFormatInformation(formatString));\n  return optimalMatrix;\n}","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __assign = this && this.__assign || function () {\n  __assign = Object.assign || function (t) {\n    for (var s, i = 1, n = arguments.length; i < n; i++) {\n      s = arguments[i];\n      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\n    }\n    return t;\n  };\n  return __assign.apply(this, arguments);\n};\nimport * as React from 'react';\nimport * as ReactDOM from 'react-dom';\nimport * as PropTypes from 'prop-types';\nimport { slide } from './animation';\nimport { canUseDOM, ZIndexContext, validatePackage, classNames } from '@progress/kendo-react-common';\nimport { AlignPoint, alignElement, domUtils, positionElement, Collision as CollisionEnum } from '@progress/kendo-popup-common';\nimport { throttle, FRAME_DURATION } from './util';\nimport { packageMetadata } from './package-metadata';\nvar DEFAULT_POPUP_ZINDEX = 100;\nvar ZINDEX_POPUP_STEP = 1;\nfunction isEquivalent(a, b) {\n  if (a === b) {\n    return true;\n  }\n  if (!!a !== !!b) {\n    return false;\n  }\n  var aProps = Object.getOwnPropertyNames(a);\n  var bProps = Object.getOwnPropertyNames(b);\n  if (aProps.length !== bProps.length) {\n    return false;\n  }\n  for (var i = 0; i < aProps.length; i++) {\n    var propName = aProps[i];\n    if (a[propName] !== b[propName]) {\n      return false;\n    }\n  }\n  return true;\n}\nvar DEFAULT_OFFSET = {\n  left: -1000,\n  top: 0\n};\nvar Status;\n(function (Status) {\n  Status[\"hiding\"] = \"hiding\";\n  Status[\"hidden\"] = \"hidden\";\n  Status[\"showing\"] = \"showing\";\n  Status[\"shown\"] = \"shown\";\n  Status[\"reposition\"] = \"reposition\";\n})(Status || (Status = {}));\nvar ANIMATION_CONTAINER = 'k-animation-container';\nvar ANIMATION_CONTAINER_SHOWN = 'k-animation-container-shown';\nvar ANIMATION_CONTAINER_RELATIVE = 'k-animation-container-relative';\nvar ANIMATION_CONTAINER_CHILD = 'k-child-animation-container';\nvar K_POPUP = 'k-popup';\n/**\n * @hidden\n */\nvar PopupWithoutContext = /** @class */function (_super) {\n  __extends(PopupWithoutContext, _super);\n  function PopupWithoutContext(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * @hidden\n     */\n    _this.context = 0;\n    /**\n     * @hidden\n     */\n    _this.state = {\n      current: Status.hidden,\n      previous: Status.hidden,\n      props: {}\n    };\n    _this._popup = null;\n    _this.show = function (popup) {\n      _this.setPosition(popup);\n      _this.animate(popup.firstChild, 'enter', _this.onOpened);\n      _this.setState({\n        current: Status.shown,\n        previous: _this.state.current\n      });\n    };\n    _this.setPosition = function (popup) {\n      var _a = _this.props,\n        anchorAlign = _a.anchorAlign,\n        popupAlign = _a.popupAlign,\n        collision = _a.collision,\n        offset = _a.offset,\n        anchor = _a.anchor,\n        margin = _a.margin,\n        scale = _a.scale,\n        positionMode = _a.positionMode;\n      var _b = popup.style,\n        width = _b.width,\n        height = _b.height;\n      // Calculations are wrong if popup does not have set size\n      popup.style.width = popup.offsetWidth + 'px';\n      popup.style.height = popup.offsetHeight + 'px';\n      var alignedOffset = alignElement({\n        anchor: anchor,\n        anchorAlign: anchorAlign,\n        element: popup,\n        elementAlign: popupAlign,\n        offset: offset,\n        margin: margin,\n        positionMode: positionMode,\n        scale: scale\n      });\n      var position = positionElement({\n        anchor: anchor,\n        anchorAlign: anchorAlign,\n        element: popup,\n        elementAlign: popupAlign,\n        collisions: collision,\n        currentLocation: alignedOffset,\n        margin: _this.props.margin\n      });\n      popup.style.top = position.offset.top + 'px';\n      popup.style.left = position.offset.left + 'px';\n      popup.style.width = width;\n      popup.style.height = height;\n      _this._collisions = {\n        fit: position.fit,\n        fitted: position.fitted,\n        flip: position.flip,\n        flipped: position.flipped\n      };\n      if (_this.props.onPosition) {\n        var event_1 = {\n          target: _this,\n          flipped: position.flipped,\n          fitted: position.fitted\n        };\n        _this.props.onPosition.call(undefined, event_1);\n      }\n    };\n    _this.onOpened = function () {\n      var element = _this._popup;\n      if (!element) {\n        return;\n      }\n      if (_this.props.show) {\n        element.classList.add(ANIMATION_CONTAINER_SHOWN);\n      }\n      _this.attachRepositionHandlers(element);\n      if (_this.props.onOpen) {\n        _this.props.onOpen.call(undefined, {\n          target: _this\n        });\n      }\n    };\n    _this.animate = function (element, type, callback) {\n      if (!_this.props.popupAlign) {\n        return;\n      }\n      var animationDirection;\n      var _a = _this.props.popupAlign,\n        horizontal = _a.horizontal,\n        vertical = _a.vertical;\n      if (horizontal === 'left' && vertical === 'center') {\n        animationDirection = 'right';\n      } else if (horizontal === 'right' && vertical === 'center') {\n        animationDirection = 'left';\n      } else if (vertical === 'top') {\n        animationDirection = 'down';\n      } else {\n        animationDirection = 'up';\n      }\n      var flipPositions = {\n        down: 'up',\n        up: 'down',\n        left: 'right',\n        right: 'left'\n      };\n      if (_this._collisions && _this._collisions.flipped) {\n        animationDirection = flipPositions[animationDirection];\n      }\n      slide(element, animationDirection, _this.animationDuration[type], type, callback);\n    };\n    _this.onClosing = function (popup) {\n      if (!_this.props.show) {\n        popup.classList.remove(ANIMATION_CONTAINER_SHOWN);\n      }\n      _this.detachRepositionHandlers();\n    };\n    _this.onClosed = function () {\n      if (_this.state.current === Status.hiding && _this.state.previous === Status.shown) {\n        _this.setState({\n          current: Status.hidden,\n          previous: _this.state.current\n        });\n      }\n      if (_this.props.onClose) {\n        _this.props.onClose.call(undefined, {\n          target: _this\n        });\n      }\n    };\n    _this.getCurrentZIndex = function () {\n      return _this.context ? _this.context + ZINDEX_POPUP_STEP : DEFAULT_POPUP_ZINDEX;\n    };\n    validatePackage(packageMetadata);\n    _this.reposition = throttle(_this.reposition.bind(_this), FRAME_DURATION);\n    return _this;\n  }\n  Object.defineProperty(PopupWithoutContext.prototype, \"element\", {\n    /**\n     * Represents the Popup DOM element.\n     */\n    get: function get() {\n      return this._popup;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @hidden\n   */\n  PopupWithoutContext.getDerivedStateFromProps = function (props, state) {\n    var show = props.show,\n      anchor = props.anchor,\n      anchorAlign = props.anchorAlign,\n      appendTo = props.appendTo,\n      collision = props.collision,\n      popupAlign = props.popupAlign,\n      className = props.className,\n      popupClass = props.popupClass,\n      style = props.style,\n      offset = props.offset,\n      contentKey = props.contentKey;\n    var nextState = __assign(__assign({}, state), {\n      props: {\n        show: show,\n        anchor: anchor,\n        anchorAlign: anchorAlign,\n        appendTo: appendTo,\n        collision: collision,\n        popupAlign: popupAlign,\n        className: className,\n        popupClass: popupClass,\n        style: style,\n        offset: offset,\n        contentKey: contentKey\n      }\n    });\n    if (props.show) {\n      if (state.current === Status.hidden || state.current === Status.hiding) {\n        return __assign(__assign({}, nextState), {\n          current: Status.showing,\n          previous: state.current\n        });\n      }\n      if (state.current === Status.showing) {\n        return __assign(__assign({}, nextState), {\n          current: Status.shown,\n          previous: state.current\n        });\n      }\n      if (state.current === Status.shown && (!isEquivalent(offset, state.props.offset) || !isEquivalent(anchorAlign, state.props.anchorAlign) || !isEquivalent(appendTo, state.props.appendTo) || !isEquivalent(collision, state.props.collision) || !isEquivalent(popupAlign, state.props.popupAlign) || !isEquivalent(style, state.props.style) || anchor !== state.props.anchor || popupClass !== state.props.popupClass || className !== state.props.className)) {\n        return __assign(__assign({}, nextState), {\n          current: Status.reposition,\n          previous: state.current\n        });\n      }\n      return nextState;\n    }\n    if (state.current === Status.hiding || state.current === Status.hidden) {\n      return __assign(__assign({}, nextState), {\n        current: Status.hidden,\n        previous: state.current\n      });\n    }\n    return __assign(__assign({}, nextState), {\n      current: Status.hiding,\n      previous: state.current\n    });\n  };\n  /**\n   * @hidden\n   */\n  PopupWithoutContext.prototype.componentDidUpdate = function (prevProps) {\n    if (this.state.current === Status.showing && this._popup) {\n      this.show(this._popup);\n    } else if (this.state.current === Status.hiding && this._popup) {\n      this.onClosing(this._popup);\n      this.animate(this._popup.firstChild, 'exit', this.onClosed);\n    } else if (this.state.current === Status.reposition && this.state.previous === Status.shown) {\n      this.setState({\n        current: Status.shown,\n        previous: this.state.current\n      });\n    } else if (this.state.current === Status.shown && prevProps.contentKey !== this.props.contentKey && this._popup) {\n      this.setPosition(this._popup);\n    }\n  };\n  /**\n   * @hidden\n   */\n  PopupWithoutContext.prototype.componentDidMount = function () {\n    if (this.state.current === Status.showing && this._popup) {\n      this.show(this._popup);\n    }\n  };\n  /**\n   * @hidden\n   */\n  PopupWithoutContext.prototype.componentWillUnmount = function () {\n    this.detachRepositionHandlers();\n  };\n  /**\n   * @hidden\n   */\n  PopupWithoutContext.prototype.render = function () {\n    var _this = this;\n    var _a = this.props,\n      children = _a.children,\n      className = _a.className,\n      popupClass = _a.popupClass,\n      show = _a.show,\n      id = _a.id,\n      positionMode = _a.positionMode;\n    var calculatedAppendTo = this.props.appendTo ? this.props.appendTo : canUseDOM ? this.props.anchor && this.props.anchor.ownerDocument ? this.props.anchor.ownerDocument.body : document.body : undefined;\n    if (this.state.current === Status.reposition && this.state.previous === Status.shown && this._popup) {\n      this.setPosition(this._popup);\n    }\n    var style = Object.assign({}, {\n      position: positionMode,\n      top: 0,\n      left: -10000\n    }, this.props.style || {});\n    var closing = this.state.current === Status.hiding;\n    if ((show || closing) && calculatedAppendTo) {\n      var currentZIndex = this.getCurrentZIndex();\n      var popupElement = React.createElement(ZIndexContext.Provider, {\n        value: currentZIndex\n      }, React.createElement(\"div\", {\n        className: classNames(ANIMATION_CONTAINER, ANIMATION_CONTAINER_RELATIVE, className),\n        id: id,\n        ref: function ref(e) {\n          return _this._popup = e;\n        },\n        style: __assign({\n          zIndex: currentZIndex\n        }, style)\n      }, React.createElement(\"div\", {\n        role: this.props.role,\n        className: classNames(K_POPUP, popupClass, ANIMATION_CONTAINER_CHILD),\n        style: {\n          transitionDelay: '0ms'\n        }\n      }, children)));\n      return this.props.appendTo !== null ? ReactDOM.createPortal(popupElement, calculatedAppendTo) : popupElement;\n    }\n    return null;\n  };\n  Object.defineProperty(PopupWithoutContext.prototype, \"animationDuration\", {\n    get: function get() {\n      var animate = this.props.animate;\n      var enter = 0;\n      var exit = 0;\n      if (animate) {\n        if (animate === true) {\n          enter = exit = 300;\n        } else {\n          enter = animate.openDuration || 0;\n          exit = animate.closeDuration || 0;\n        }\n      }\n      return {\n        enter: enter,\n        exit: exit\n      };\n    },\n    enumerable: false,\n    configurable: true\n  });\n  PopupWithoutContext.prototype.attachRepositionHandlers = function (element) {\n    var _this = this;\n    this.detachRepositionHandlers();\n    this._scrollableParents = domUtils.scrollableParents(this.props.anchor || element);\n    if (this._scrollableParents) {\n      this._scrollableParents.map(function (p) {\n        return p.addEventListener('scroll', _this.reposition);\n      });\n    }\n    window.addEventListener('resize', this.reposition);\n  };\n  PopupWithoutContext.prototype.detachRepositionHandlers = function () {\n    var _this = this;\n    if (this._scrollableParents) {\n      this._scrollableParents.map(function (p) {\n        return p.removeEventListener('scroll', _this.reposition);\n      });\n      this._scrollableParents = undefined;\n    }\n    window.removeEventListener('resize', this.reposition);\n  };\n  PopupWithoutContext.prototype.reposition = function () {\n    this.setState({\n      current: Status.reposition,\n      previous: this.state.current\n    });\n  };\n  /**\n   * @hidden\n   */\n  PopupWithoutContext.propTypes = {\n    anchor: function anchor(props) {\n      var anchor = props.anchor;\n      if (anchor && typeof anchor.nodeType !== 'number') {\n        return new Error('Invalid prop `anchor` supplied to `Kendo React Popup`. Validation failed.');\n      }\n      return null;\n    },\n    appendTo: function appendTo(props) {\n      var element = props.appendTo;\n      if (element && typeof element.nodeType !== 'number') {\n        return new Error('Invalid prop `appendTo` supplied to `Kendo React Popup`. Validation failed.');\n      }\n      return null;\n    },\n    className: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string), PropTypes.object]),\n    id: PropTypes.string,\n    popupClass: PropTypes.oneOfType([PropTypes.string, PropTypes.arrayOf(PropTypes.string), PropTypes.object]),\n    collision: PropTypes.shape({\n      horizontal: PropTypes.oneOf([CollisionEnum.fit, CollisionEnum.flip, CollisionEnum.none]),\n      vertical: PropTypes.oneOf([CollisionEnum.fit, CollisionEnum.flip, CollisionEnum.none])\n    }),\n    anchorAlign: PropTypes.shape({\n      horizontal: PropTypes.oneOf([AlignPoint.left, AlignPoint.center, AlignPoint.right]),\n      vertical: PropTypes.oneOf([AlignPoint.top, AlignPoint.center, AlignPoint.bottom])\n    }),\n    popupAlign: PropTypes.shape({\n      horizontal: PropTypes.oneOf([AlignPoint.left, AlignPoint.center, AlignPoint.right]),\n      vertical: PropTypes.oneOf([AlignPoint.top, AlignPoint.center, AlignPoint.bottom])\n    }),\n    offset: PropTypes.shape({\n      left: PropTypes.number,\n      top: PropTypes.number\n    }),\n    children: PropTypes.oneOfType([PropTypes.element, PropTypes.node]),\n    show: PropTypes.bool,\n    animate: PropTypes.oneOfType([PropTypes.bool, PropTypes.shape({\n      openDuration: PropTypes.number,\n      closeDuration: PropTypes.number\n    })]),\n    margin: PropTypes.shape({\n      horizontal: PropTypes.number,\n      vertical: PropTypes.number\n    }),\n    positionMode: PropTypes.oneOf(['fixed', 'absolute']),\n    scale: PropTypes.number,\n    style: PropTypes.object,\n    onClose: PropTypes.func,\n    onPosition: PropTypes.func,\n    onOpen: PropTypes.func\n  };\n  /**\n   * @hidden\n   */\n  PopupWithoutContext.defaultProps = {\n    collision: {\n      horizontal: CollisionEnum.fit,\n      vertical: CollisionEnum.flip\n    },\n    anchorAlign: {\n      horizontal: AlignPoint.left,\n      vertical: AlignPoint.bottom\n    },\n    popupAlign: {\n      horizontal: AlignPoint.left,\n      vertical: AlignPoint.top\n    },\n    offset: DEFAULT_OFFSET,\n    animate: true,\n    show: false,\n    margin: {\n      horizontal: 0,\n      vertical: 0\n    },\n    positionMode: 'absolute'\n  };\n  /**\n   * @hidden\n   */\n  PopupWithoutContext.contextType = ZIndexContext;\n  /**\n   * @hidden\n   */\n  PopupWithoutContext.displayName = 'PopupComponent';\n  return PopupWithoutContext;\n}(React.Component);\nexport { PopupWithoutContext };","map":null,"metadata":{},"sourceType":"module"}
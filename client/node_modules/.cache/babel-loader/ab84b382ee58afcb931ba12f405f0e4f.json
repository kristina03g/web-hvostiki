{"ast":null,"code":"import { geometry as g } from '@progress/kendo-drawing';\nimport { Class, setDefaultOptions, limitValue, rad, deg, deepExtend } from '../common';\nimport { Location } from './location';\nimport { datums } from './datums';\nvar math = Math,\n  atan = math.atan,\n  exp = math.exp,\n  pow = math.pow,\n  sin = math.sin,\n  log = math.log,\n  tan = math.tan,\n  Point = g.Point;\nvar PI = math.PI,\n  PI_DIV_2 = PI / 2,\n  PI_DIV_4 = PI / 4,\n  DEG_TO_RAD = PI / 180;\nvar WGS84 = datums.WGS84;\n\n// WGS 84 / World Mercator\nexport var Mercator = function (Class) {\n  function Mercator(options) {\n    Class.call(this);\n    this.initProperties();\n    this._initOptions(options);\n  }\n  if (Class) Mercator.__proto__ = Class;\n  Mercator.prototype = Object.create(Class && Class.prototype);\n  Mercator.prototype.constructor = Mercator;\n  Mercator.prototype._initOptions = function _initOptions(options) {\n    this.options = deepExtend({}, this.options, options);\n  };\n  Mercator.prototype.initProperties = function initProperties() {\n    // super.initProperties();\n\n    deepExtend(this, {\n      MAX_LNG: 180,\n      MAX_LAT: 85.0840590501,\n      INVERSE_ITERATIONS: 15,\n      INVERSE_CONVERGENCE: 1e-12\n    });\n  };\n  Mercator.prototype.forward = function forward(loc, clamp) {\n    var proj = this,\n      options = proj.options,\n      datum = options.datum,\n      r = datum.a,\n      lng0 = options.centralMeridian,\n      lat = limitValue(loc.lat, -proj.MAX_LAT, proj.MAX_LAT),\n      lng = clamp ? limitValue(loc.lng, -proj.MAX_LNG, proj.MAX_LNG) : loc.lng,\n      x = rad(lng - lng0) * r,\n      y = proj._projectLat(lat);\n    return new Point(x, y);\n  };\n  Mercator.prototype._projectLat = function _projectLat(lat) {\n    var datum = this.options.datum,\n      ecc = datum.e,\n      r = datum.a,\n      y = rad(lat),\n      ts = tan(PI_DIV_4 + y / 2),\n      con = ecc * sin(y),\n      p = pow((1 - con) / (1 + con), ecc / 2);\n\n    // See: http://en.wikipedia.org/wiki/Mercator_projection#Generalization_to_the_ellipsoid\n    return r * log(ts * p);\n  };\n  Mercator.prototype.inverse = function inverse(point, clamp) {\n    var proj = this,\n      options = proj.options,\n      datum = options.datum,\n      r = datum.a,\n      lng0 = options.centralMeridian,\n      lng = point.x / (DEG_TO_RAD * r) + lng0,\n      lat = limitValue(proj._inverseY(point.y), -proj.MAX_LAT, proj.MAX_LAT);\n    if (clamp) {\n      lng = limitValue(lng, -proj.MAX_LNG, proj.MAX_LNG);\n    }\n    return new Location(lat, lng);\n  };\n  Mercator.prototype._inverseY = function _inverseY(y) {\n    var proj = this,\n      datum = proj.options.datum,\n      r = datum.a,\n      ecc = datum.e,\n      ecch = ecc / 2,\n      ts = exp(-y / r),\n      phi = PI_DIV_2 - 2 * atan(ts),\n      i;\n    for (i = 0; i <= proj.INVERSE_ITERATIONS; i++) {\n      var con = ecc * sin(phi),\n        p = pow((1 - con) / (1 + con), ecch),\n        dphi = PI_DIV_2 - 2 * atan(ts * p) - phi;\n      phi += dphi;\n      if (math.abs(dphi) <= proj.INVERSE_CONVERGENCE) {\n        break;\n      }\n    }\n    return deg(phi);\n  };\n  return Mercator;\n}(Class);\nsetDefaultOptions(Mercator, {\n  centralMeridian: 0,\n  datum: WGS84\n});\n\n// WGS 84 / Pseudo-Mercator\n// Used by Google Maps, Bing, OSM, etc.\n// Spherical projection of ellipsoidal coordinates.\nexport var SphericalMercator = function (Mercator) {\n  function SphericalMercator() {\n    Mercator.apply(this, arguments);\n  }\n  if (Mercator) SphericalMercator.__proto__ = Mercator;\n  SphericalMercator.prototype = Object.create(Mercator && Mercator.prototype);\n  SphericalMercator.prototype.constructor = SphericalMercator;\n  SphericalMercator.prototype.initProperties = function initProperties() {\n    Mercator.prototype.initProperties.call(this);\n    deepExtend(this, {\n      MAX_LAT: 85.0511287798\n    });\n  };\n  SphericalMercator.prototype._projectLat = function _projectLat(lat) {\n    var r = this.options.datum.a,\n      y = rad(lat),\n      ts = tan(PI_DIV_4 + y / 2);\n    return r * log(ts);\n  };\n  SphericalMercator.prototype._inverseY = function _inverseY(y) {\n    var r = this.options.datum.a,\n      ts = exp(-y / r);\n    return deg(PI_DIV_2 - 2 * atan(ts));\n  };\n  return SphericalMercator;\n}(Mercator);\nexport var Equirectangular = function (Class) {\n  function Equirectangular() {\n    Class.apply(this, arguments);\n  }\n  if (Class) Equirectangular.__proto__ = Class;\n  Equirectangular.prototype = Object.create(Class && Class.prototype);\n  Equirectangular.prototype.constructor = Equirectangular;\n  Equirectangular.prototype.forward = function forward(loc) {\n    return new Point(loc.lng, loc.lat);\n  };\n  Equirectangular.prototype.inverse = function inverse(point) {\n    return new Location(point.y, point.x);\n  };\n  return Equirectangular;\n}(Class);\n\n// This is the projected coordinate system used for rendering maps in Google Maps, OpenStreetMap, etc\n// Unit: metre\n// Geodetic CRS: WGS 84\n// Scope: Certain Web mapping and visualisation applications. It is not a recognised geodetic system: for that see ellipsoidal Mercator CRS code 3395 (WGS 84 / World Mercator).\n// Remarks: Uses spherical development of ellipsoidal coordinates. Relative to WGS 84 / World Mercator (CRS code 3395) errors of 0.7 percent in scale and differences in northing of up to 43km in the map (equivalent to 21km on the ground) may arise.\n// Area of use: World between 85.06째S and 85.06째N.\n// Coordinate system: Cartesian 2D CS. Axes: easting, northing (X,Y). Orientations: east, north. UoM: m.\n// https://epsg.io/3857\nexport var EPSG3857 = function (Class) {\n  function EPSG3857() {\n    Class.call(this);\n    var crs = this,\n      proj = crs._proj = new SphericalMercator();\n    var c = this.c = 2 * PI * proj.options.datum.a;\n\n    // transfrom matrix\n    // Scale circumference to 1, mirror Y and shift origin to top left\n    this._tm = g.transform().translate(0.5, 0.5).scale(1 / c, -1 / c);\n\n    // Inverse transform matrix\n    this._itm = g.transform().scale(c, -c).translate(-0.5, -0.5);\n  }\n  if (Class) EPSG3857.__proto__ = Class;\n  EPSG3857.prototype = Object.create(Class && Class.prototype);\n  EPSG3857.prototype.constructor = EPSG3857;\n\n  // Location <-> Point (screen coordinates for a given scale)\n  EPSG3857.prototype.toPoint = function toPoint(loc, scale, clamp) {\n    var point = this._proj.forward(loc, clamp);\n    return point.transform(this._tm).scale(scale || 1);\n  };\n  EPSG3857.prototype.toLocation = function toLocation(point, scale, clamp) {\n    var newPoint = point.clone().scale(1 / (scale || 1)).transform(this._itm);\n    return this._proj.inverse(newPoint, clamp);\n  };\n  return EPSG3857;\n}(Class);\n\n// Unit: metre\n// Geodetic CRS: WGS 84\n// Scope: Very small scale mapping.\n// Remarks: Euro-centric view of world excluding polar areas.\n// Area of use: World between 80째S and 84째N.\n// Coordinate system: Cartesian 2D CS. Axes: easting, northing (E,N). Orientations: east, north. UoM: m.\n// https://epsg.io/3395\nexport var EPSG3395 = function (Class) {\n  function EPSG3395() {\n    Class.call(this);\n    this._proj = new Mercator();\n  }\n  if (Class) EPSG3395.__proto__ = Class;\n  EPSG3395.prototype = Object.create(Class && Class.prototype);\n  EPSG3395.prototype.constructor = EPSG3395;\n  EPSG3395.prototype.toPoint = function toPoint(loc) {\n    return this._proj.forward(loc);\n  };\n  EPSG3395.prototype.toLocation = function toLocation(point) {\n    return this._proj.inverse(point);\n  };\n  return EPSG3395;\n}(Class);\n\n// Unit: degree\n// Geodetic CRS: WGS 84\n// Scope: Horizontal component of 3D system. Used by the GPS satellite navigation system and for NATO military geodetic surveying.\n// Area of use: World.\n// Coordinate system: Ellipsoidal 2D CS. Axes: latitude, longitude. Orientations: north, east. UoM: degree\n// https://epsg.io/4326\nexport var EPSG4326 = function (Class) {\n  function EPSG4326() {\n    Class.call(this);\n    this._proj = new Equirectangular();\n  }\n  if (Class) EPSG4326.__proto__ = Class;\n  EPSG4326.prototype = Object.create(Class && Class.prototype);\n  EPSG4326.prototype.constructor = EPSG4326;\n  EPSG4326.prototype.toPoint = function toPoint(loc) {\n    return this._proj.forward(loc);\n  };\n  EPSG4326.prototype.toLocation = function toLocation(point) {\n    return this._proj.inverse(point);\n  };\n  return EPSG4326;\n}(Class);","map":null,"metadata":{},"sourceType":"module"}
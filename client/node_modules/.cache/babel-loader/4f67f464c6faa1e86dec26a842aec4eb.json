{"ast":null,"code":"import { DomEventsBuilder } from '../services';\nimport { DateCategoryAxis, Point } from '../core';\nimport { MOUSEWHEEL_DELAY, MOUSEWHEEL, SELECT_START, SELECT, SELECT_END } from './constants';\nimport { LEFT, RIGHT, MIN_VALUE, MAX_VALUE, X } from '../common/constants';\nimport { addClass, Class, removeClass, eventCoordinates, deepExtend, elementStyles, eventElement, setDefaultOptions, limitValue, round, bindEvents, unbindEvents, mousewheelDelta, hasClasses } from '../common';\nimport { parseDate } from '../date-utils';\nvar ZOOM_ACCELERATION = 3;\nvar SELECTOR_HEIGHT_ADJUST = 0.1;\nfunction createDiv(classNames) {\n  var element = document.createElement(\"div\");\n  if (classNames) {\n    element.className = classNames;\n  }\n  return element;\n}\nfunction closestHandle(element) {\n  var current = element;\n  while (current && !hasClasses(current, \"k-handle\")) {\n    current = current.parentNode;\n  }\n  return current;\n}\nvar Selection = function (Class) {\n  function Selection(chart, categoryAxis, options, observer) {\n    Class.call(this);\n    var chartElement = chart.element;\n    this.options = deepExtend({}, this.options, options);\n    this.chart = chart;\n    this.observer = observer;\n    this.chartElement = chartElement;\n    this.categoryAxis = categoryAxis;\n    this._dateAxis = this.categoryAxis instanceof DateCategoryAxis;\n    this.initOptions();\n    this.visible = this.options.visible && chartElement.offsetHeight;\n    if (this.visible) {\n      this.createElements();\n      this.set(this._index(this.options.from), this._index(this.options.to));\n      this.bindEvents();\n    }\n  }\n  if (Class) Selection.__proto__ = Class;\n  Selection.prototype = Object.create(Class && Class.prototype);\n  Selection.prototype.constructor = Selection;\n  Selection.prototype.onPane = function onPane(pane) {\n    return this.categoryAxis.pane === pane;\n  };\n  Selection.prototype.createElements = function createElements() {\n    var options = this.options;\n    var wrapper = this.wrapper = createDiv(\"k-selector k-pointer-events-none\");\n    elementStyles(wrapper, {\n      top: options.offset.top,\n      left: options.offset.left,\n      width: options.width,\n      height: options.height,\n      direction: 'ltr'\n    });\n    var selection = this.selection = createDiv(\"k-selection k-pointer-events-none\");\n    this.leftMask = createDiv(\"k-mask k-pointer-events-none\");\n    this.rightMask = createDiv(\"k-mask k-pointer-events-none\");\n    wrapper.appendChild(this.leftMask);\n    wrapper.appendChild(this.rightMask);\n    wrapper.appendChild(selection);\n    var body = this.body = createDiv(\"k-selection-bg k-pointer-events-none\");\n    selection.appendChild(body);\n    var leftHandle = this.leftHandle = createDiv(\"k-handle k-left-handle k-pointer-events-auto\");\n    var rightHandle = this.rightHandle = createDiv(\"k-handle k-right-handle k-pointer-events-auto\");\n    leftHandle.appendChild(createDiv());\n    rightHandle.appendChild(createDiv());\n    selection.appendChild(leftHandle);\n    selection.appendChild(rightHandle);\n    this.chartElement.appendChild(wrapper);\n    var selectionStyles = elementStyles(selection, [\"borderLeftWidth\", \"borderRightWidth\", \"height\"]);\n    var leftHandleHeight = elementStyles(leftHandle, \"height\").height;\n    var rightHandleHeight = elementStyles(rightHandle, \"height\").height;\n    options.selection = {\n      border: {\n        left: selectionStyles.borderLeftWidth,\n        right: selectionStyles.borderRightWidth\n      }\n    };\n    elementStyles(leftHandle, {\n      top: (selectionStyles.height - leftHandleHeight) / 2\n    });\n    elementStyles(rightHandle, {\n      top: (selectionStyles.height - rightHandleHeight) / 2\n    });\n    wrapper.style.cssText = wrapper.style.cssText;\n  };\n  Selection.prototype.bindEvents = function bindEvents$1() {\n    var obj;\n    if (this.options.mousewheel !== false) {\n      this._mousewheelHandler = this._mousewheel.bind(this);\n      bindEvents(this.chartElement, (obj = {}, obj[MOUSEWHEEL] = this._mousewheelHandler, obj));\n    }\n    this._domEvents = DomEventsBuilder.create(this.chartElement, {\n      stopPropagation: true,\n      // applicable for the jQuery UserEvents\n      start: this._start.bind(this),\n      move: this._move.bind(this),\n      end: this._end.bind(this),\n      tap: this._tap.bind(this),\n      press: this._press.bind(this),\n      gesturestart: this._gesturestart.bind(this),\n      gesturechange: this._gesturechange.bind(this),\n      gestureend: this._gestureend.bind(this)\n    });\n  };\n  Selection.prototype.initOptions = function initOptions() {\n    var ref = this;\n    var options = ref.options;\n    var categoryAxis = ref.categoryAxis;\n    var box = categoryAxis.pane.chartsBox();\n    var intlService = this.chart.chartService.intl;\n    if (this._dateAxis) {\n      deepExtend(options, {\n        min: parseDate(intlService, options.min),\n        max: parseDate(intlService, options.max),\n        from: parseDate(intlService, options.from),\n        to: parseDate(intlService, options.to)\n      });\n    }\n    var ref$1 = elementStyles(this.chartElement, [\"paddingLeft\", \"paddingTop\"]);\n    var paddingLeft = ref$1.paddingLeft;\n    var paddingTop = ref$1.paddingTop;\n    this.options = deepExtend({}, {\n      width: box.width(),\n      height: box.height() + SELECTOR_HEIGHT_ADJUST,\n      //workaround for sub-pixel hover on the paths in chrome\n      padding: {\n        left: paddingLeft,\n        top: paddingTop\n      },\n      offset: {\n        left: box.x1 + paddingLeft,\n        top: box.y1 + paddingTop\n      },\n      from: options.min,\n      to: options.max\n    }, options);\n  };\n  Selection.prototype.destroy = function destroy() {\n    var obj;\n    if (this._domEvents) {\n      this._domEvents.destroy();\n      delete this._domEvents;\n    }\n    clearTimeout(this._mwTimeout);\n    this._state = null;\n    if (this.wrapper) {\n      if (this._mousewheelHandler) {\n        unbindEvents(this.chartElement, (obj = {}, obj[MOUSEWHEEL] = this._mousewheelHandler, obj));\n        this._mousewheelHandler = null;\n      }\n      this.chartElement.removeChild(this.wrapper);\n      this.wrapper = null;\n    }\n  };\n  Selection.prototype._rangeEventArgs = function _rangeEventArgs(range) {\n    return {\n      axis: this.categoryAxis.options,\n      from: this._value(range.from),\n      to: this._value(range.to)\n    };\n  };\n  Selection.prototype._pointInPane = function _pointInPane(x, y) {\n    var paneBox = this.categoryAxis.pane.box;\n    var modelCoords = this.chart._toModelCoordinates(x, y);\n    return paneBox.containsPoint(modelCoords);\n  };\n  Selection.prototype._start = function _start(e) {\n    var options = this.options;\n    var target = eventElement(e);\n    if (this._state || !target) {\n      return;\n    }\n    var coords = eventCoordinates(e);\n    var inPane = this._pointInPane(coords.x, coords.y);\n    if (!inPane) {\n      return;\n    }\n    var handle = closestHandle(target);\n    var bodyRect = this.body.getBoundingClientRect();\n    var inBody = !handle && coords.x >= bodyRect.x && coords.x <= bodyRect.x + bodyRect.width && coords.y >= bodyRect.y && coords.y <= bodyRect.y + bodyRect.height;\n    this.chart._unsetActivePoint();\n    this._state = {\n      moveTarget: handle,\n      startLocation: e.x ? e.x.location : 0,\n      inBody: inBody,\n      range: {\n        from: this._index(options.from),\n        to: this._index(options.to)\n      }\n    };\n    var args = this._rangeEventArgs({\n      from: this._index(options.from),\n      to: this._index(options.to)\n    });\n    if (this.trigger(SELECT_START, args)) {\n      this._state = null;\n    }\n  };\n  Selection.prototype._press = function _press(e) {\n    var handle;\n    if (this._state) {\n      handle = this._state.moveTarget;\n    } else {\n      handle = closestHandle(eventElement(e));\n    }\n    if (handle) {\n      addClass(handle, \"k-handle-active\");\n    }\n  };\n  Selection.prototype._move = function _move(e) {\n    if (!this._state) {\n      return;\n    }\n    var ref = this;\n    var state = ref._state;\n    var options = ref.options;\n    var categoryAxis = ref.categoryAxis;\n    var range = state.range;\n    var target = state.moveTarget;\n    var reverse = categoryAxis.options.reverse;\n    var from = this._index(options.from);\n    var to = this._index(options.to);\n    var min = this._index(options.min);\n    var max = this._index(options.max);\n    var delta = state.startLocation - e.x.location;\n    var oldRange = {\n      from: range.from,\n      to: range.to\n    };\n    var span = range.to - range.from;\n    var scale = elementStyles(this.wrapper, \"width\").width / (categoryAxis.categoriesCount() - 1);\n    var offset = Math.round(delta / scale) * (reverse ? -1 : 1);\n    if (!target && !state.inBody) {\n      return;\n    }\n    var leftHandle = target && hasClasses(target, \"k-left-handle\");\n    var rightHandle = target && hasClasses(target, \"k-right-handle\");\n    if (state.inBody) {\n      range.from = Math.min(Math.max(min, from - offset), max - span);\n      range.to = Math.min(range.from + span, max);\n    } else if (leftHandle && !reverse || rightHandle && reverse) {\n      range.from = Math.min(Math.max(min, from - offset), max - 1);\n      range.to = Math.max(range.from + 1, range.to);\n    } else if (leftHandle && reverse || rightHandle && !reverse) {\n      range.to = Math.min(Math.max(min + 1, to - offset), max);\n      range.from = Math.min(range.to - 1, range.from);\n    }\n    if (range.from !== oldRange.from || range.to !== oldRange.to) {\n      this.move(range.from, range.to);\n      this.trigger(SELECT, this._rangeEventArgs(range));\n    }\n  };\n  Selection.prototype._end = function _end() {\n    if (this._state) {\n      var moveTarget = this._state.moveTarget;\n      if (moveTarget) {\n        removeClass(moveTarget, \"k-handle-active\");\n      }\n      var range = this._state.range;\n      this.set(range.from, range.to);\n      this.trigger(SELECT_END, this._rangeEventArgs(range));\n      delete this._state;\n    }\n  };\n  Selection.prototype._tap = function _tap(e) {\n    var ref = this;\n    var options = ref.options;\n    var categoryAxis = ref.categoryAxis;\n    var coords = this.chart._eventCoordinates(e);\n    var categoryIx = categoryAxis.pointCategoryIndex(new Point(coords.x, categoryAxis.box.y1));\n    var from = this._index(options.from);\n    var to = this._index(options.to);\n    var min = this._index(options.min);\n    var max = this._index(options.max);\n    var span = to - from;\n    var mid = from + span / 2;\n    var range = {};\n    var rightClick = e.event.which === 3;\n    var offset = Math.round(mid - categoryIx);\n    if (this._state || rightClick) {\n      return;\n    }\n    this.chart._unsetActivePoint();\n    if (!categoryAxis.options.justified) {\n      offset--;\n    }\n    range.from = Math.min(Math.max(min, from - offset), max - span);\n    range.to = Math.min(range.from + span, max);\n    this._start(e);\n    if (this._state) {\n      this._state.range = range;\n      this.trigger(SELECT, this._rangeEventArgs(range));\n      this._end();\n    }\n  };\n  Selection.prototype._mousewheel = function _mousewheel(e) {\n    var this$1 = this;\n    var delta = mousewheelDelta(e);\n    this._start(e);\n    if (this._state) {\n      var range = this._state.range;\n      e.preventDefault();\n      e.stopPropagation();\n      if (Math.abs(delta) > 1) {\n        delta *= ZOOM_ACCELERATION;\n      }\n      if (this.options.mousewheel.reverse) {\n        delta *= -1;\n      }\n      if (this.expand(delta)) {\n        this.trigger(SELECT, {\n          axis: this.categoryAxis.options,\n          delta: delta,\n          originalEvent: e,\n          from: this._value(range.from),\n          to: this._value(range.to)\n        });\n      }\n      if (this._mwTimeout) {\n        clearTimeout(this._mwTimeout);\n      }\n      this._mwTimeout = setTimeout(function () {\n        this$1._end();\n      }, MOUSEWHEEL_DELAY);\n    }\n  };\n  Selection.prototype._gesturestart = function _gesturestart(e) {\n    var options = this.options;\n    var touch = e.touches[0];\n    var inPane = this._pointInPane(touch.pageX, touch.pageY);\n    if (!inPane) {\n      return;\n    }\n    this._state = {\n      range: {\n        from: this._index(options.from),\n        to: this._index(options.to)\n      }\n    };\n    var args = this._rangeEventArgs(this._state.range);\n    if (this.trigger(SELECT_START, args)) {\n      this._state = null;\n    } else {\n      e.preventDefault();\n    }\n  };\n  Selection.prototype._gestureend = function _gestureend() {\n    if (this._state) {\n      this.trigger(SELECT_END, this._rangeEventArgs(this._state.range));\n      delete this._state;\n    }\n  };\n  Selection.prototype._gesturechange = function _gesturechange(e) {\n    if (!this._state) {\n      return;\n    }\n    var ref = this;\n    var chart = ref.chart;\n    var state = ref._state;\n    var options = ref.options;\n    var categoryAxis = ref.categoryAxis;\n    var range = state.range;\n    var p0 = chart._toModelCoordinates(e.touches[0].x.location).x;\n    var p1 = chart._toModelCoordinates(e.touches[1].x.location).x;\n    var left = Math.min(p0, p1);\n    var right = Math.max(p0, p1);\n    e.preventDefault();\n    range.from = categoryAxis.pointCategoryIndex(new Point(left)) || options.min;\n    range.to = categoryAxis.pointCategoryIndex(new Point(right)) || options.max;\n    this.move(range.from, range.to);\n    this.trigger(SELECT, this._rangeEventArgs(range));\n  };\n  Selection.prototype._index = function _index(value) {\n    var index = value;\n    if (value instanceof Date) {\n      index = this.categoryAxis.categoryIndex(value);\n    }\n    return index;\n  };\n  Selection.prototype._value = function _value(index) {\n    var value = index;\n    if (this._dateAxis) {\n      value = this.categoryAxis.categoryAt(index);\n      if (value > this.options.max) {\n        value = this.options.max;\n      }\n    }\n    return value;\n  };\n  Selection.prototype._slot = function _slot(value) {\n    var categoryAxis = this.categoryAxis;\n    var index = this._index(value);\n    return categoryAxis.getSlot(index, index, true);\n  };\n  Selection.prototype.move = function move(from, to) {\n    var options = this.options;\n    var reverse = this.categoryAxis.options.reverse;\n    var offset = options.offset;\n    var padding = options.padding;\n    var border = options.selection.border;\n    var left = reverse ? to : from;\n    var right = reverse ? from : to;\n    var edge = 'x' + (reverse ? 2 : 1);\n    var box = this._slot(left);\n    var leftMaskWidth = round(box[edge] - offset.left + padding.left);\n    elementStyles(this.leftMask, {\n      width: leftMaskWidth\n    });\n    elementStyles(this.selection, {\n      left: leftMaskWidth\n    });\n    box = this._slot(right);\n    var rightMaskWidth = round(options.width - (box[edge] - offset.left + padding.left));\n    elementStyles(this.rightMask, {\n      width: rightMaskWidth\n    });\n    var distance = options.width - rightMaskWidth;\n    if (distance !== options.width) {\n      distance += border.right;\n    }\n    elementStyles(this.rightMask, {\n      left: distance\n    });\n    elementStyles(this.selection, {\n      width: Math.max(options.width - (leftMaskWidth + rightMaskWidth) - border.right, 0)\n    });\n  };\n  Selection.prototype.set = function set(from, to) {\n    var options = this.options;\n    var min = this._index(options.min);\n    var max = this._index(options.max);\n    var fromValue = limitValue(this._index(from), min, max);\n    var toValue = limitValue(this._index(to), fromValue + 1, max);\n    if (options.visible) {\n      this.move(fromValue, toValue);\n    }\n    options.from = this._value(fromValue);\n    options.to = this._value(toValue);\n  };\n  Selection.prototype.expand = function expand(delta) {\n    var options = this.options;\n    var min = this._index(options.min);\n    var max = this._index(options.max);\n    var zDir = options.mousewheel.zoom;\n    var from = this._index(options.from);\n    var to = this._index(options.to);\n    var range = {\n      from: from,\n      to: to\n    };\n    var oldRange = deepExtend({}, range);\n    if (this._state) {\n      range = this._state.range;\n    }\n    if (zDir !== RIGHT) {\n      range.from = limitValue(limitValue(from - delta, 0, to - 1), min, max);\n    }\n    if (zDir !== LEFT) {\n      range.to = limitValue(limitValue(to + delta, range.from + 1, max), min, max);\n    }\n    if (range.from !== oldRange.from || range.to !== oldRange.to) {\n      this.set(range.from, range.to);\n      return true;\n    }\n  };\n  Selection.prototype.zoom = function zoom(delta, coords) {\n    var options = this.options;\n    var min = this._index(options.min);\n    var max = this._index(options.max);\n    var from = this._index(options.from);\n    var to = this._index(options.to);\n    var range = {\n      from: from,\n      to: to\n    };\n    var oldRange = deepExtend({}, range);\n    var ref = this.categoryAxis.options;\n    var reverse = ref.reverse;\n    var origin = X + (reverse ? '2' : '1');\n    var lineBox = this.categoryAxis.lineBox();\n    var relative = Math.abs(lineBox[origin] - coords[X]);\n    var size = lineBox.width();\n    var position = round(relative / size, 2);\n    var minDelta = round(position * delta);\n    var maxDelta = round((1 - position) * delta);\n    if (this._state) {\n      range = this._state.range;\n    }\n    range.from = limitValue(limitValue(from - minDelta, 0, to - 1), min, max);\n    range.to = limitValue(limitValue(to + maxDelta, range.from + 1, max), min, max);\n    if (range.from !== oldRange.from || range.to !== oldRange.to) {\n      this.set(range.from, range.to);\n      return true;\n    }\n  };\n  Selection.prototype.trigger = function trigger(name, args) {\n    return (this.observer || this.chart).trigger(name, args);\n  };\n  return Selection;\n}(Class);\nsetDefaultOptions(Selection, {\n  visible: true,\n  mousewheel: {\n    zoom: \"both\"\n  },\n  min: MIN_VALUE,\n  max: MAX_VALUE\n});\nexport default Selection;","map":null,"metadata":{},"sourceType":"module"}
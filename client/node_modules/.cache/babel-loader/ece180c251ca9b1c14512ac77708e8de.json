{"ast":null,"code":"import { Class, elementOffset } from '../../common';\nimport { Observable } from './observable';\nimport { getEventMap, proxy, getSupportedFeatures } from '../utils';\nvar extend = Object.assign;\nvar CHANGE = 'change';\nexport var TapCapture = function (Observable) {\n  function TapCapture(element, options) {\n    Observable.call(this);\n    var that = this,\n      domElement = element[0] || element;\n    that.capture = false;\n    var eventMap = getEventMap(navigator.userAgent);\n    if (domElement.addEventListener) {\n      eventMap.down.split(' ').forEach(function (event) {\n        domElement.addEventListener(event, proxy(that._press, that), true);\n      });\n      eventMap.up.split(' ').forEach(function (event) {\n        domElement.addEventListener(event, proxy(that._release, that), true);\n      });\n    } else {\n      eventMap.down.split(' ').forEach(function (event) {\n        domElement.attachEvent(event, proxy(that._press, that));\n      });\n      eventMap.up.split(' ').forEach(function (event) {\n        domElement.attachEvent(event, proxy(that._release, that));\n      });\n    }\n    that.bind(['press', 'release'], options || {});\n  }\n  if (Observable) TapCapture.__proto__ = Observable;\n  TapCapture.prototype = Object.create(Observable && Observable.prototype);\n  TapCapture.prototype.constructor = TapCapture;\n  TapCapture.prototype.captureNext = function captureNext() {\n    this.capture = true;\n  };\n  TapCapture.prototype.cancelCapture = function cancelCapture() {\n    this.capture = false;\n  };\n  TapCapture.prototype._press = function _press(e) {\n    var that = this;\n    that.trigger('press');\n    if (that.capture) {\n      e.preventDefault();\n    }\n  };\n  TapCapture.prototype._release = function _release(e) {\n    var that = this;\n    that.trigger('release');\n    if (that.capture) {\n      e.preventDefault();\n      that.cancelCapture();\n    }\n  };\n  return TapCapture;\n}(Observable);\nexport var PaneDimension = function (Observable) {\n  function PaneDimension(options) {\n    Observable.call(this);\n    var that = this;\n    that.forcedEnabled = false;\n    extend(that, options);\n    that.scale = 1;\n    if (that.horizontal) {\n      that.measure = 'offsetWidth';\n      that.scrollSize = 'scrollWidth';\n      that.axis = 'x';\n    } else {\n      that.measure = 'offsetHeight';\n      that.scrollSize = 'scrollHeight';\n      that.axis = 'y';\n    }\n  }\n  if (Observable) PaneDimension.__proto__ = Observable;\n  PaneDimension.prototype = Object.create(Observable && Observable.prototype);\n  PaneDimension.prototype.constructor = PaneDimension;\n  PaneDimension.prototype.makeVirtual = function makeVirtual() {\n    extend(this, {\n      virtual: true,\n      forcedEnabled: true,\n      _virtualMin: 0,\n      _virtualMax: 0\n    });\n  };\n  PaneDimension.prototype.virtualSize = function virtualSize(min, max) {\n    if (this._virtualMin !== min || this._virtualMax !== max) {\n      this._virtualMin = min;\n      this._virtualMax = max;\n      this.update();\n    }\n  };\n  PaneDimension.prototype.outOfBounds = function outOfBounds(offset) {\n    return offset > this.max || offset < this.min;\n  };\n  PaneDimension.prototype.forceEnabled = function forceEnabled() {\n    this.forcedEnabled = true;\n  };\n  PaneDimension.prototype.getSize = function getSize() {\n    return this.container[this.measure];\n  };\n  PaneDimension.prototype.getTotal = function getTotal() {\n    return this.element[this.scrollSize];\n  };\n  PaneDimension.prototype.rescale = function rescale(scale) {\n    this.scale = scale;\n  };\n  PaneDimension.prototype.update = function update(silent) {\n    var that = this,\n      total = that.virtual ? that._virtualMax : that.getTotal(),\n      scaledTotal = total * that.scale,\n      size = that.getSize();\n    if (total === 0 && !that.forcedEnabled) {\n      return;\n    }\n    that.max = that.virtual ? -that._virtualMin : 0;\n    that.size = size;\n    that.total = scaledTotal;\n    that.min = Math.min(that.max, size - scaledTotal);\n    that.minScale = size / total;\n    that.centerOffset = (scaledTotal - size) / 2;\n    that.enabled = that.forcedEnabled || scaledTotal > size;\n    if (!silent) {\n      that.trigger(CHANGE, that);\n    }\n  };\n  return PaneDimension;\n}(Observable);\nexport var PaneDimensions = function (Observable) {\n  function PaneDimensions(options) {\n    Observable.call(this);\n    var that = this;\n    that.x = new PaneDimension(extend({\n      horizontal: true\n    }, options));\n    that.y = new PaneDimension(extend({\n      horizontal: false\n    }, options));\n    that.container = options.container;\n    that.forcedMinScale = options.minScale;\n    that.maxScale = options.maxScale || 100;\n    that.bind(CHANGE, options);\n  }\n  if (Observable) PaneDimensions.__proto__ = Observable;\n  PaneDimensions.prototype = Object.create(Observable && Observable.prototype);\n  PaneDimensions.prototype.constructor = PaneDimensions;\n  PaneDimensions.prototype.rescale = function rescale(newScale) {\n    this.x.rescale(newScale);\n    this.y.rescale(newScale);\n    this.refresh();\n  };\n  PaneDimensions.prototype.centerCoordinates = function centerCoordinates() {\n    return {\n      x: Math.min(0, -this.x.centerOffset),\n      y: Math.min(0, -this.y.centerOffset)\n    };\n  };\n  PaneDimensions.prototype.refresh = function refresh() {\n    var that = this;\n    that.x.update();\n    that.y.update();\n    that.enabled = that.x.enabled || that.y.enabled;\n    that.minScale = that.forcedMinScale || Math.min(that.x.minScale, that.y.minScale);\n    that.fitScale = Math.max(that.x.minScale, that.y.minScale);\n    that.trigger(CHANGE);\n  };\n  return PaneDimensions;\n}(Observable);\nexport var PaneAxis = function (Observable) {\n  function PaneAxis(options) {\n    Observable.call(this);\n    extend(this, options);\n  }\n  if (Observable) PaneAxis.__proto__ = Observable;\n  PaneAxis.prototype = Object.create(Observable && Observable.prototype);\n  PaneAxis.prototype.constructor = PaneAxis;\n  PaneAxis.prototype.outOfBounds = function outOfBounds() {\n    return this.dimension.outOfBounds(this.movable[this.axis]);\n  };\n  PaneAxis.prototype.dragMove = function dragMove(delta) {\n    var that = this,\n      dimension = that.dimension,\n      axis = that.axis,\n      movable = that.movable,\n      position = movable[axis] + delta;\n    if (!dimension.enabled) {\n      return;\n    }\n    var dragDelta = delta;\n    if (position < dimension.min && delta < 0 || position > dimension.max && delta > 0) {\n      dragDelta *= that.resistance;\n    }\n    movable.translateAxis(axis, dragDelta);\n    that.trigger(CHANGE, that);\n  };\n  return PaneAxis;\n}(Observable);\nexport var Pane = function (Class) {\n  function Pane(options) {\n    Class.call(this);\n    var that = this,\n      x,\n      y,\n      resistance,\n      movable;\n    extend(that, {\n      elastic: true\n    }, options);\n    resistance = that.elastic ? 0.5 : 0;\n    movable = that.movable;\n    that.x = x = new PaneAxis({\n      axis: 'x',\n      dimension: that.dimensions.x,\n      resistance: resistance,\n      movable: movable\n    });\n    that.y = y = new PaneAxis({\n      axis: 'y',\n      dimension: that.dimensions.y,\n      resistance: resistance,\n      movable: movable\n    });\n    that.userEvents.bind(['press', 'move', 'end', 'gesturestart', 'gesturechange'], {\n      gesturestart: function gesturestart(e) {\n        that.gesture = e;\n        that.offset = elementOffset(that.dimensions.container);\n      },\n      press: function press(e) {\n        var closestAnchor = e.event.target.closest('a');\n        if (closestAnchor && closestAnchor.matches('[data-navigate-on-press=true]')) {\n          e.sender.cancel();\n        }\n      },\n      gesturechange: function gesturechange(e) {\n        var previousGesture = that.gesture,\n          previousCenter = previousGesture.center,\n          center = e.center,\n          scaleDelta = e.distance / previousGesture.distance,\n          minScale = that.dimensions.minScale,\n          maxScale = that.dimensions.maxScale,\n          coordinates;\n        if (movable.scale <= minScale && scaleDelta < 1) {\n          scaleDelta += (1 - scaleDelta) * 0.8;\n        }\n        if (movable.scale * scaleDelta >= maxScale) {\n          scaleDelta = maxScale / movable.scale;\n        }\n        var offsetX = movable.x + that.offset.left,\n          offsetY = movable.y + that.offset.top;\n        coordinates = {\n          x: (offsetX - previousCenter.x) * scaleDelta + center.x - offsetX,\n          y: (offsetY - previousCenter.y) * scaleDelta + center.y - offsetY\n        };\n        movable.scaleWith(scaleDelta);\n        x.dragMove(coordinates.x);\n        y.dragMove(coordinates.y);\n        that.dimensions.rescale(movable.scale);\n        that.gesture = e;\n        e.preventDefault();\n      },\n      move: function move(e) {\n        if (e.event.target.tagName.match(/textarea|input/i)) {\n          return;\n        }\n        if (x.dimension.enabled || y.dimension.enabled) {\n          x.dragMove(e.x.delta);\n          y.dragMove(e.y.delta);\n          e.preventDefault();\n        } else {\n          e.touch.skip();\n        }\n      },\n      end: function end(e) {\n        e.preventDefault();\n      }\n    });\n  }\n  if (Class) Pane.__proto__ = Class;\n  Pane.prototype = Object.create(Class && Class.prototype);\n  Pane.prototype.constructor = Pane;\n  return Pane;\n}(Class);\nvar translate = function translate(x, y, scale) {\n  return 'translate3d(' + x + 'px,' + y + 'px,0) scale(' + scale + ')';\n};\nexport var Movable = function (Observable) {\n  function Movable(element) {\n    Observable.call(this);\n    var that = this;\n    that.support = getSupportedFeatures();\n    this.transformStyle = this.support.transitions.prefix + 'Transform';\n    that.element = element;\n    that.element.style.webkitTransformOrigin = 'left top';\n    that.x = 0;\n    that.y = 0;\n    that.scale = 1;\n    var coordinates = translate(that.x, that.y, that.scale);\n    that.element.style[this.transformStyle] = coordinates;\n    that._saveCoordinates(coordinates);\n  }\n  if (Observable) Movable.__proto__ = Observable;\n  Movable.prototype = Object.create(Observable && Observable.prototype);\n  Movable.prototype.constructor = Movable;\n  Movable.prototype.translateAxis = function translateAxis(axis, by) {\n    this[axis] += by;\n    this.refresh();\n  };\n  Movable.prototype.scaleTo = function scaleTo(scale) {\n    this.scale = scale;\n    this.refresh();\n  };\n  Movable.prototype.scaleWith = function scaleWith(scaleDelta) {\n    this.scale *= scaleDelta;\n    this.refresh();\n  };\n  Movable.prototype.translate = function translate(coordinates) {\n    this.x += coordinates.x;\n    this.y += coordinates.y;\n    this.refresh();\n  };\n  Movable.prototype.moveAxis = function moveAxis(axis, value) {\n    this[axis] = value;\n    this.refresh();\n  };\n  Movable.prototype.moveTo = function moveTo(coordinates) {\n    extend(this, coordinates);\n    this.refresh();\n  };\n  Movable.prototype.refresh = function refresh() {\n    var that = this,\n      x = that.x,\n      y = that.y,\n      newCoordinates;\n    if (that.round) {\n      x = Math.round(x);\n      y = Math.round(y);\n    }\n    newCoordinates = translate(x, y, that.scale);\n    if (newCoordinates !== that.coordinates) {\n      that.element.style[this.transformStyle] = newCoordinates;\n      that._saveCoordinates(newCoordinates);\n      that.trigger(CHANGE);\n    }\n  };\n  Movable.prototype._saveCoordinates = function _saveCoordinates(coordinates) {\n    this.coordinates = coordinates;\n  };\n  return Movable;\n}(Observable);","map":null,"metadata":{},"sourceType":"module"}
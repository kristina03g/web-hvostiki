{"ast":null,"code":"import { Class, deepExtend, deg, rad, round, defined } from '../common';\nimport { datums } from './datums';\nfunction toSquare(value) {\n  return value * value;\n}\nvar math = Math,\n  abs = math.abs,\n  atan = math.atan,\n  atan2 = math.atan2,\n  cos = math.cos,\n  sin = math.sin,\n  tan = math.tan;\nexport var Location = function (Class) {\n  function Location(lat, lng) {\n    Class.call(this);\n    this.initProperties();\n    if (arguments.length === 1) {\n      this.lat = lat[0];\n      this.lng = lat[1];\n    } else {\n      this.lat = lat;\n      this.lng = lng;\n    }\n  }\n  if (Class) Location.__proto__ = Class;\n  Location.prototype = Object.create(Class && Class.prototype);\n  Location.prototype.constructor = Location;\n  Location.prototype.initProperties = function initProperties() {\n    deepExtend(this, {\n      DISTANCE_ITERATIONS: 100,\n      DISTANCE_CONVERGENCE: 1e-12,\n      DISTANCE_PRECISION: 2,\n      FORMAT: '{0:N6}{1:N6}'\n    });\n  };\n  Location.prototype.toArray = function toArray() {\n    return [this.lat, this.lng];\n  };\n  Location.prototype.equals = function equals(loc) {\n    return loc && loc.lat === this.lat && loc.lng === this.lng;\n  };\n  Location.prototype.clone = function clone() {\n    return new Location(this.lat, this.lng);\n  };\n  Location.prototype.round = function round$1(precision) {\n    this.lng = round(this.lng, precision);\n    this.lat = round(this.lat, precision);\n    return this;\n  };\n  Location.prototype.wrap = function wrap() {\n    this.lng = this.lng % 180;\n    this.lat = this.lat % 90;\n    return this;\n  };\n  Location.prototype.distanceTo = function distanceTo(dest, datum) {\n    return this.greatCircleTo(dest, datum).distance;\n  };\n  Location.prototype.destination = function destination(distance, initialBearing, initialDatum) {\n    var bearing = rad(initialBearing);\n    var datum = initialDatum || datums.WGS84;\n    var fromLat = rad(this.lat);\n    var fromLng = rad(this.lng);\n    var dToR = distance / datum.a;\n    var lat = math.asin(sin(fromLat) * cos(dToR) + cos(fromLat) * sin(dToR) * cos(bearing));\n    var lng = fromLng + atan2(sin(bearing) * sin(dToR) * cos(fromLat), cos(dToR) - sin(fromLat) * sin(lat));\n    return new Location(deg(lat), deg(lng));\n  };\n  Location.prototype.greatCircleTo = function greatCircleTo(initialDest, initialDatum) {\n    var this$1 = this;\n    var dest = Location.create(dest);\n    var datum = initialDatum || datums.WGS84;\n    if (!dest || this.clone().round(8).equals(dest.clone().round(8))) {\n      return {\n        distance: 0,\n        azimuthFrom: 0,\n        azimuthTo: 0\n      };\n    }\n\n    // See http://en.wikipedia.org/wiki/Vincenty's_formulae#Notation\n    // o == sigma\n    // A == alpha\n\n    var a = datum.a;\n    var b = datum.b;\n    var f = datum.f;\n    var L = rad(dest.lng - this.lng);\n    var U1 = atan((1 - f) * tan(rad(this.lat)));\n    var sinU1 = sin(U1);\n    var cosU1 = cos(U1);\n    var U2 = atan((1 - f) * tan(rad(dest.lat)));\n    var sinU2 = sin(U2);\n    var cosU2 = cos(U2);\n    var lambda = L;\n    var prevLambda;\n    var i = this.DISTANCE_ITERATIONS;\n    var converged = false;\n    var sinLambda;\n    var cosLambda;\n    var sino;\n    var cosA2;\n    var coso;\n    var cos2om;\n    var sigma;\n    while (!converged && i-- > 0) {\n      sinLambda = sin(lambda);\n      cosLambda = cos(lambda);\n      sino = math.sqrt(toSquare(cosU2 * sinLambda) + toSquare(cosU1 * sinU2 - sinU1 * cosU2 * cosLambda));\n      coso = sinU1 * sinU2 + cosU1 * cosU2 * cosLambda;\n      sigma = atan2(sino, coso);\n      var sinA = cosU1 * cosU2 * sinLambda / sino;\n      cosA2 = 1 - toSquare(sinA);\n      cos2om = 0;\n      if (cosA2 !== 0) {\n        cos2om = coso - 2 * sinU1 * sinU2 / cosA2;\n      }\n      prevLambda = lambda;\n      var C = f / 16 * cosA2 * (4 + f * (4 - 3 * cosA2));\n      lambda = L + (1 - C) * f * sinA * (sigma + C * sino * (cos2om + C * coso * (-1 + 2 * toSquare(cos2om))));\n      converged = abs(lambda - prevLambda) <= this$1.DISTANCE_CONVERGENCE;\n    }\n    var u2 = cosA2 * (toSquare(a) - toSquare(b)) / toSquare(b);\n    var A = 1 + u2 / 16384 * (4096 + u2 * (-768 + u2 * (320 - 175 * u2)));\n    var B = u2 / 1024 * (256 + u2 * (-128 + u2 * (74 - 47 * u2)));\n    var deltao = B * sino * (cos2om + B / 4 * (coso * (-1 + 2 * toSquare(cos2om)) - B / 6 * cos2om * (-3 + 4 * toSquare(sino)) * (-3 + 4 * toSquare(cos2om))));\n    var azimuthFrom = atan2(cosU2 * sinLambda, cosU1 * sinU2 - sinU1 * cosU2 * cosLambda);\n    var azimuthTo = atan2(cosU1 * sinLambda, -sinU1 * cosU2 + cosU1 * sinU2 * cosLambda);\n    return {\n      distance: round(b * A * (sigma - deltao), this.DISTANCE_PRECISION),\n      azimuthFrom: deg(azimuthFrom),\n      azimuthTo: deg(azimuthTo)\n    };\n  };\n\n  // IE < 9 doesn't allow to override toString on definition\n  Location.prototype.toString = function toString() {\n    // return kendo.format(this.FORMAT, this.lat, this.lng);\n    return String(this.lat) + \",\" + String(this.lng);\n  };\n  Location.fromLngLat = function fromLngLat(lngAndLat) {\n    return new Location(lngAndLat[1], lngAndLat[0]);\n  };\n  Location.fromLatLng = function fromLatLng(lngAndLat) {\n    return new Location(lngAndLat[0], lngAndLat[1]);\n  };\n  Location.create = function create(a, b) {\n    if (defined(a)) {\n      if (a instanceof Location) {\n        return a.clone();\n      } else if (arguments.length === 1 && a.length === 2) {\n        return Location.fromLatLng(a);\n      }\n      return new Location(a, b);\n    }\n  };\n  return Location;\n}(Class);","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import { Class, grep } from '../../common';\nimport { proxy, noop, applyEventMap, getEventMap, on, off, now, getSupportedFeatures } from '../utils';\nimport { Observable } from './observable';\nvar extend = Object.assign;\nvar preventDefault = function preventDefault(e) {\n  e.preventDefault();\n};\nvar DEFAULT_MIN_HOLD = 800,\n  CLICK_DELAY = 300,\n  // DEFAULT_THRESHOLD = support.browser.msie ? 5 : 0,\n  DEFAULT_THRESHOLD = 0,\n  PRESS = 'press',\n  HOLD = 'hold',\n  SELECT = 'select',\n  START = 'start',\n  MOVE = 'move',\n  END = 'end',\n  CANCEL = 'cancel',\n  TAP = 'tap',\n  DOUBLETAP = 'doubleTap',\n  RELEASE = 'release',\n  GESTURESTART = 'gesturestart',\n  GESTURECHANGE = 'gesturechange',\n  GESTUREEND = 'gestureend',\n  GESTURETAP = 'gesturetap';\nvar THRESHOLD = {\n  'api': 0,\n  'touch': 0,\n  'mouse': 9,\n  'pointer': 9\n};\nfunction touchDelta(touch1, touch2) {\n  var x1 = touch1.x.location,\n    y1 = touch1.y.location,\n    x2 = touch2.x.location,\n    y2 = touch2.y.location,\n    dx = x1 - x2,\n    dy = y1 - y2;\n  return {\n    center: {\n      x: (x1 + x2) / 2,\n      y: (y1 + y2) / 2\n    },\n    distance: Math.sqrt(dx * dx + dy * dy)\n  };\n}\nfunction getTouches(e) {\n  var support = getSupportedFeatures();\n  var touches = [],\n    originalEvent = e.originalEvent || e,\n    currentTarget = e.currentTarget,\n    idx = 0,\n    length,\n    changedTouches,\n    touch;\n  if (e.api) {\n    touches.push({\n      id: 2,\n      event: e,\n      target: e.target,\n      currentTarget: e.target,\n      location: e,\n      type: 'api'\n    });\n  } else if (e.type.match(/touch/)) {\n    changedTouches = originalEvent ? originalEvent.changedTouches : [];\n    for (length = changedTouches.length; idx < length; idx++) {\n      touch = changedTouches[idx];\n      touches.push({\n        location: touch,\n        event: e,\n        target: touch.target,\n        currentTarget: currentTarget,\n        id: touch.identifier,\n        type: 'touch'\n      });\n    }\n  } else if (support.pointers || support.msPointers) {\n    touches.push({\n      location: originalEvent,\n      event: e,\n      target: e.target,\n      currentTarget: currentTarget,\n      id: originalEvent.pointerId,\n      type: 'pointer'\n    });\n  } else {\n    touches.push({\n      id: 1,\n      event: e,\n      target: e.target,\n      currentTarget: currentTarget,\n      location: e,\n      type: 'mouse'\n    });\n  }\n  return touches;\n}\nexport var TouchAxis = function (Class) {\n  function TouchAxis(axis, location) {\n    Class.call(this);\n    var that = this;\n    that.support = getSupportedFeatures();\n    that.invalidZeroEvents = this.support.mobileOS && this.support.mobileOS.android;\n    that.axis = axis;\n    that._updateLocationData(location);\n    that.startLocation = that.location;\n    that.velocity = that.delta = 0;\n    that.timeStamp = now();\n  }\n  if (Class) TouchAxis.__proto__ = Class;\n  TouchAxis.prototype = Object.create(Class && Class.prototype);\n  TouchAxis.prototype.constructor = TouchAxis;\n  TouchAxis.prototype.move = function move(location) {\n    var that = this,\n      offset = location['page' + that.axis],\n      timeStamp = now(),\n      timeDelta = timeStamp - that.timeStamp || 1;\n    if (!offset && this.invalidZeroEvents) {\n      return;\n    }\n    that.delta = offset - that.location;\n    that._updateLocationData(location);\n    that.initialDelta = offset - that.startLocation;\n    that.velocity = that.delta / timeDelta;\n    that.timeStamp = timeStamp;\n  };\n  TouchAxis.prototype._updateLocationData = function _updateLocationData(location) {\n    var that = this,\n      axis = that.axis;\n    that.location = location['page' + axis];\n    that.client = location['client' + axis];\n    that.screen = location['screen' + axis];\n  };\n  return TouchAxis;\n}(Class);\nexport var Touch = function (Class) {\n  function Touch(userEvents, target, touchInfo) {\n    Class.call(this);\n    extend(this, {\n      x: new TouchAxis('X', touchInfo.location),\n      y: new TouchAxis('Y', touchInfo.location),\n      type: touchInfo.type,\n      useClickAsTap: userEvents.useClickAsTap,\n      threshold: userEvents.threshold || THRESHOLD[touchInfo.type],\n      userEvents: userEvents,\n      target: target,\n      currentTarget: touchInfo.currentTarget,\n      initialTouch: touchInfo.target,\n      id: touchInfo.id,\n      pressEvent: touchInfo,\n      _clicks: userEvents._clicks,\n      supportDoubleTap: userEvents.supportDoubleTap,\n      _moved: false,\n      _finished: false\n    });\n  }\n  if (Class) Touch.__proto__ = Class;\n  Touch.prototype = Object.create(Class && Class.prototype);\n  Touch.prototype.constructor = Touch;\n  Touch.prototype.press = function press() {\n    // this._holdTimeout = setTimeout($.proxy(this, '_hold'), this.userEvents.minHold);\n    this._holdTimeout = setTimeout(proxy(this._hold, this), this.userEvents.minHold);\n    this._trigger(PRESS, this.pressEvent);\n  };\n  Touch.prototype._tap = function _tap(touchInfo) {\n    var that = this;\n    that.userEvents._clicks++;\n    if (that.userEvents._clicks === 1) {\n      that._clickTimeout = setTimeout(function () {\n        if (that.userEvents._clicks === 1) {\n          that._trigger(TAP, touchInfo);\n        } else {\n          that._trigger(DOUBLETAP, touchInfo);\n        }\n        that.userEvents._clicks = 0;\n      }, CLICK_DELAY);\n    }\n  };\n  Touch.prototype._hold = function _hold() {\n    this._trigger(HOLD, this.pressEvent);\n  };\n\n  /* eslint-disable consistent-return */\n  Touch.prototype.move = function move(touchInfo) {\n    var that = this;\n    var preventMove = touchInfo.type !== 'api' && that.userEvents._shouldNotMove;\n    if (that._finished || preventMove) {\n      return;\n    }\n    that.x.move(touchInfo.location);\n    that.y.move(touchInfo.location);\n    if (!that._moved) {\n      if (that._withinIgnoreThreshold()) {\n        return;\n      }\n      if (!UserEvents.current || UserEvents.current === that.userEvents) {\n        that._start(touchInfo);\n      } else {\n        return that.dispose();\n      }\n    }\n    if (!that._finished) {\n      that._trigger(MOVE, touchInfo);\n    }\n  };\n  /* eslint-enable consistent-return */\n\n  Touch.prototype.end = function end(touchInfo) {\n    this.endTime = now();\n    if (this._finished) {\n      return;\n    }\n    this._finished = true;\n    this._trigger(RELEASE, touchInfo);\n    if (this._moved) {\n      this._trigger(END, touchInfo);\n    } else {\n      if (!this.useClickAsTap) {\n        if (this.supportDoubleTap) {\n          this._tap(touchInfo);\n        } else {\n          this._trigger(TAP, touchInfo);\n        }\n      }\n    }\n    clearTimeout(this._holdTimeout);\n    this.dispose();\n  };\n  Touch.prototype.dispose = function dispose() {\n    var userEvents = this.userEvents,\n      activeTouches = userEvents.touches || [];\n    this._finished = true;\n    this.pressEvent = null;\n    clearTimeout(this._holdTimeout);\n    // activeTouches.splice($.inArray(this, activeTouches), 1);\n    var activeTouchIndex = activeTouches.indexOf(this);\n    activeTouches.splice(activeTouchIndex, 1);\n  };\n  Touch.prototype.skip = function skip() {\n    this.dispose();\n  };\n  Touch.prototype.cancel = function cancel() {\n    this.dispose();\n  };\n  Touch.prototype.isMoved = function isMoved() {\n    return this._moved;\n  };\n  Touch.prototype._start = function _start(touchInfo) {\n    clearTimeout(this._holdTimeout);\n    this.startTime = now();\n    this._moved = true;\n    this._trigger(START, touchInfo);\n  };\n  Touch.prototype._trigger = function _trigger(name, touchInfo) {\n    var that = this,\n      jQueryEvent = touchInfo.event,\n      data = {\n        touch: that,\n        x: that.x,\n        y: that.y,\n        target: that.target,\n        event: jQueryEvent\n      };\n    if (that.userEvents.notify(name, data)) {\n      jQueryEvent.preventDefault();\n    }\n  };\n  Touch.prototype._withinIgnoreThreshold = function _withinIgnoreThreshold() {\n    var xDelta = this.x.initialDelta,\n      yDelta = this.y.initialDelta;\n    return Math.sqrt(xDelta * xDelta + yDelta * yDelta) <= this.threshold;\n  };\n  return Touch;\n}(Class);\nfunction withEachUpEvent(callback) {\n  var eventMap = getEventMap(navigator.userAgent);\n  var downEvents = eventMap.up.split(' '),\n    idx = 0,\n    length = downEvents.length;\n  for (; idx < length; idx++) {\n    callback(downEvents[idx]);\n  }\n}\nexport var UserEvents = function (Observable) {\n  function UserEvents(element, options) {\n    Observable.call(this);\n    var that = this;\n    var filter;\n    var support = getSupportedFeatures();\n    this.support = support;\n\n    /* eslint-disable no-param-reassign */\n    options = options || {};\n    /* eslint-enable no-param-reassign */\n    this.options = options;\n    filter = that.filter = options.filter;\n    that.threshold = options.threshold || DEFAULT_THRESHOLD;\n    that.minHold = options.minHold || DEFAULT_MIN_HOLD;\n    that.touches = [];\n    that._maxTouches = options.multiTouch ? 2 : 1;\n    that.allowSelection = options.allowSelection;\n    that.captureUpIfMoved = options.captureUpIfMoved;\n    that.useClickAsTap = !options.fastTap && !support.delayedClick();\n    that._clicks = 0;\n    that.supportDoubleTap = options.supportDoubleTap;\n    var enableGlobalSurface = !support.touch || support.mouseAndTouchPresent;\n    extend(that, {\n      element: element,\n      surface: options.global && enableGlobalSurface ? element.ownerDocument.documentElement : options.surface || element,\n      stopPropagation: options.stopPropagation,\n      pressed: false\n    });\n    this._surfaceMoveHandler = proxy(this._move, this);\n    on(that.surface, applyEventMap('move'), this._surfaceMoveHandler);\n    this._surfaceEndHandler = proxy(this._end, this);\n    on(that.surface, applyEventMap('up cancel'), this._surfaceEndHandler);\n    this._elementStartHandler = proxy(this._start, this);\n    on(element, applyEventMap('down'), filter, this._elementStartHandler);\n    if (that.useClickAsTap) {\n      this._elementClickHandler = proxy(this._click, this);\n      on(element, applyEventMap('click'), filter, this._elementClickHandler);\n    }\n    if (support.pointers || support.msPointers) {\n      if (support.browser.version < 11) {\n        var defaultAction = 'pinch-zoom double-tap-zoom';\n        element.style['-ms-touch-action'] = options.touchAction && options.touchAction !== 'none' ? defaultAction + ' ' + options.touchAction : defaultAction;\n      } else {\n        element.style['touch-action'] = options.touchAction || 'none';\n      }\n    }\n    if (options.preventDragEvent) {\n      this._elementDragStartHandler = preventDefault;\n      on(element, applyEventMap('dragstart'), this._elementDragStartHandler);\n    }\n\n    // element.on(kendo.applyEventMap('mousedown'), filter, {\n    //     root: element\n    // } '_select');\n\n    // todo: use root\n    this._elementSelectHandler = proxy(this._select, this);\n    on(element, applyEventMap('mousedown'), filter, this._elementSelectHandler);\n    if (that.captureUpIfMoved && support.eventCapture) {\n      var surfaceElement = that.surface,\n        preventIfMovingProxy = proxy(that.preventIfMoving, that);\n      withEachUpEvent(function (eventName) {\n        surfaceElement.addEventListener(eventName, preventIfMovingProxy, true);\n      });\n    }\n    that.bind([PRESS, HOLD, TAP, DOUBLETAP, START, MOVE, END, RELEASE, CANCEL, GESTURESTART, GESTURECHANGE, GESTUREEND, GESTURETAP, SELECT], options);\n  }\n  if (Observable) UserEvents.__proto__ = Observable;\n  UserEvents.prototype = Object.create(Observable && Observable.prototype);\n  UserEvents.prototype.constructor = UserEvents;\n  UserEvents.prototype.preventIfMoving = function preventIfMoving(e) {\n    if (this._isMoved()) {\n      e.preventDefault();\n    }\n  };\n  UserEvents.prototype.destroy = function destroy() {\n    var that = this;\n    var options = this.options;\n    var element = this.element;\n    if (that._destroyed) {\n      return;\n    }\n    that._destroyed = true;\n    if (that.captureUpIfMoved && this.support.eventCapture) {\n      var surfaceElement = that.surface;\n      withEachUpEvent(function (eventName) {\n        surfaceElement.removeEventListener(eventName, that.preventIfMoving);\n      });\n    }\n    off(that.surface, applyEventMap('move'), this._surfaceMoveHandler);\n    off(that.surface, applyEventMap('up cancel'), this._surfaceEndHandler);\n    off(element, applyEventMap('down'), this._elementStartHandler);\n    if (that.useClickAsTap) {\n      off(element, applyEventMap('click'), this._elementClickHandler);\n    }\n    if (options.preventDragEvent) {\n      off(element, applyEventMap('dragstart'), this._elementDragStartHandler);\n    }\n    off(element, applyEventMap('mousedown'), this._elementSelectHandler);\n    that._disposeAll();\n    that.unbind();\n    delete that.surface;\n    delete that.element;\n    delete that.currentTarget;\n  };\n  UserEvents.prototype.capture = function capture() {\n    UserEvents.current = this;\n  };\n  UserEvents.prototype.cancel = function cancel() {\n    this._disposeAll();\n    this.trigger(CANCEL);\n  };\n\n  /* eslint-disable indent */\n  UserEvents.prototype.notify = function notify(event, data) {\n    var that = this,\n      touches = that.touches;\n    var eventName = event;\n    if (this._isMultiTouch()) {\n      switch (eventName) {\n        case MOVE:\n          eventName = GESTURECHANGE;\n          break;\n        case END:\n          eventName = GESTUREEND;\n          break;\n        case TAP:\n          eventName = GESTURETAP;\n          break;\n        default:\n          break;\n      }\n      extend(data, {\n        touches: touches\n      }, touchDelta(touches[0], touches[1]));\n    }\n    return this.trigger(eventName, extend(data, {\n      type: eventName\n    }));\n  };\n  /* eslint-enable indent */\n\n  UserEvents.prototype.press = function press(x, y, target) {\n    this._apiCall('_start', x, y, target);\n  };\n  UserEvents.prototype.move = function move(x, y) {\n    this._apiCall('_move', x, y);\n  };\n  UserEvents.prototype.end = function end(x, y) {\n    this._apiCall('_end', x, y);\n  };\n  UserEvents.prototype._isMultiTouch = function _isMultiTouch() {\n    return this.touches.length > 1;\n  };\n  UserEvents.prototype._maxTouchesReached = function _maxTouchesReached() {\n    return this.touches.length >= this._maxTouches;\n  };\n  UserEvents.prototype._disposeAll = function _disposeAll() {\n    var touches = this.touches;\n    while (touches.length > 0) {\n      touches.pop().dispose();\n    }\n  };\n  UserEvents.prototype._isMoved = function _isMoved() {\n    return grep(this.touches, function (touch) {\n      return touch.isMoved();\n    }).length;\n  };\n  UserEvents.prototype._select = function _select(e) {\n    if (!this.allowSelection || this.trigger(SELECT, {\n      event: e\n    })) {\n      e.preventDefault();\n    }\n  };\n  UserEvents.prototype._start = function _start(e) {\n    var that = this,\n      idx = 0,\n      filter = that.filter,\n      target,\n      touches = getTouches(e),\n      length = touches.length,\n      touch,\n      which = e.which;\n    if (which && which > 1 || that._maxTouchesReached()) {\n      return;\n    }\n    UserEvents.current = null;\n    that.currentTarget = e.currentTarget;\n    if (that.stopPropagation) {\n      e.stopPropagation();\n    }\n    for (; idx < length; idx++) {\n      if (that._maxTouchesReached()) {\n        break;\n      }\n      touch = touches[idx];\n      if (filter) {\n        target = touch.currentTarget;\n      } else {\n        target = that.element;\n      }\n      if (target && target.length === 0) {\n        continue;\n      }\n      touch = new Touch(that, target, touch);\n      that.touches.push(touch);\n      touch.press();\n      if (that._isMultiTouch()) {\n        that.notify('gesturestart', {});\n      }\n    }\n  };\n  UserEvents.prototype._move = function _move(e) {\n    this._eachTouch('move', e);\n  };\n  UserEvents.prototype._end = function _end(e) {\n    this._eachTouch('end', e);\n  };\n  UserEvents.prototype._click = function _click(e) {\n    var data = {\n      touch: {\n        initialTouch: e.target,\n        target: e.currentTarget,\n        endTime: now(),\n        x: {\n          location: e.pageX,\n          client: e.clientX\n        },\n        y: {\n          location: e.pageY,\n          client: e.clientY\n        }\n      },\n      x: e.pageX,\n      y: e.pageY,\n      target: e.currentTarget,\n      event: e,\n      type: 'tap'\n    };\n    if (this.trigger('tap', data)) {\n      e.preventDefault();\n    }\n  };\n  UserEvents.prototype._eachTouch = function _eachTouch(methodName, e) {\n    var that = this,\n      dict = {},\n      touches = getTouches(e),\n      activeTouches = that.touches,\n      idx,\n      touch,\n      touchInfo,\n      matchingTouch;\n    for (idx = 0; idx < activeTouches.length; idx++) {\n      touch = activeTouches[idx];\n      dict[touch.id] = touch;\n    }\n    for (idx = 0; idx < touches.length; idx++) {\n      touchInfo = touches[idx];\n      matchingTouch = dict[touchInfo.id];\n      if (matchingTouch) {\n        matchingTouch[methodName](touchInfo);\n      }\n    }\n  };\n  UserEvents.prototype._apiCall = function _apiCall(type, x, y, target) {\n    this[type]({\n      api: true,\n      pageX: x,\n      pageY: y,\n      clientX: x,\n      clientY: y,\n      target: target || this.element,\n      stopPropagation: noop,\n      preventDefault: noop\n    });\n  };\n  UserEvents.defaultThreshold = function defaultThreshold(value) {\n    DEFAULT_THRESHOLD = value;\n  };\n  UserEvents.minHold = function minHold(value) {\n    DEFAULT_MIN_HOLD = value;\n  };\n  return UserEvents;\n}(Observable);","map":null,"metadata":{},"sourceType":"module"}
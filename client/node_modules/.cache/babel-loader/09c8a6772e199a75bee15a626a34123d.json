{"ast":null,"code":"import { drawing as draw, geometry as geom } from '@progress/kendo-drawing';\nimport ChartElement from './chart-element';\nimport TextBox from './text-box';\nimport AxisLabel from './axis-label';\nimport Note from './note';\nimport Box from './box';\nimport { ChartService } from '../services';\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\nimport { NONE, BLACK, CENTER, TOP, BOTTOM, LEFT, RIGHT, OUTSIDE, X, Y, WIDTH, HEIGHT } from '../common/constants';\nimport { alignPathToPixel, deepExtend, getTemplate, grep, defined, isObject, inArray, limitValue, round, setDefaultOptions } from '../common';\nvar Axis = function (ChartElement) {\n  function Axis(options, chartService) {\n    if (chartService === void 0) chartService = new ChartService();\n    ChartElement.call(this, options);\n    this.chartService = chartService;\n    if (!this.options.visible) {\n      this.options = deepExtend({}, this.options, {\n        labels: {\n          visible: false\n        },\n        line: {\n          visible: false\n        },\n        margin: 0,\n        majorTickSize: 0,\n        minorTickSize: 0\n      });\n    }\n    this.options.minorTicks = deepExtend({}, {\n      color: this.options.line.color,\n      width: this.options.line.width,\n      visible: this.options.minorTickType !== NONE\n    }, this.options.minorTicks, {\n      size: this.options.minorTickSize,\n      align: this.options.minorTickType\n    });\n    this.options.majorTicks = deepExtend({}, {\n      color: this.options.line.color,\n      width: this.options.line.width,\n      visible: this.options.majorTickType !== NONE\n    }, this.options.majorTicks, {\n      size: this.options.majorTickSize,\n      align: this.options.majorTickType\n    });\n    this.initFields();\n    if (!this.options._deferLabels) {\n      this.createLabels();\n    }\n    this.createTitle();\n    this.createNotes();\n  }\n  if (ChartElement) Axis.__proto__ = ChartElement;\n  Axis.prototype = Object.create(ChartElement && ChartElement.prototype);\n  Axis.prototype.constructor = Axis;\n  Axis.prototype.initFields = function initFields() {};\n\n  // abstract labelsCount(): Number\n  // abstract createAxisLabel(index, options): AxisLabel\n\n  Axis.prototype.labelsRange = function labelsRange() {\n    return {\n      min: this.options.labels.skip,\n      max: this.labelsCount()\n    };\n  };\n  Axis.prototype.normalizeLabelRotation = function normalizeLabelRotation(labelOptions) {\n    var rotation = labelOptions.rotation;\n    if (isObject(rotation)) {\n      labelOptions.alignRotation = rotation.align;\n      labelOptions.rotation = rotation.angle;\n    }\n  };\n  Axis.prototype.createLabels = function createLabels() {\n    var this$1 = this;\n    var options = this.options;\n    var align = options.vertical ? RIGHT : CENTER;\n    var labelOptions = deepExtend({}, options.labels, {\n      align: align,\n      zIndex: options.zIndex\n    });\n    var step = Math.max(1, labelOptions.step);\n    this.clearLabels();\n    if (labelOptions.visible) {\n      this.normalizeLabelRotation(labelOptions);\n      if (labelOptions.rotation === \"auto\") {\n        labelOptions.rotation = 0;\n        options.autoRotateLabels = true;\n      }\n      var range = this.labelsRange();\n      for (var idx = range.min; idx < range.max; idx += step) {\n        var labelContext = {\n          index: idx,\n          count: range.max\n        };\n        var label = this$1.createAxisLabel(idx, labelOptions, labelContext);\n        if (label) {\n          this$1.append(label);\n          this$1.labels.push(label);\n        }\n      }\n    }\n  };\n  Axis.prototype.clearLabels = function clearLabels() {\n    this.children = grep(this.children, function (child) {\n      return !(child instanceof AxisLabel);\n    });\n    this.labels = [];\n  };\n  Axis.prototype.clearTitle = function clearTitle() {\n    var this$1 = this;\n    if (this.title) {\n      this.children = grep(this.children, function (child) {\n        return child !== this$1.title;\n      });\n      this.title = undefined;\n    }\n  };\n  Axis.prototype.clear = function clear() {\n    this.clearLabels();\n    this.clearTitle();\n  };\n  Axis.prototype.lineBox = function lineBox() {\n    var ref = this;\n    var options = ref.options;\n    var box = ref.box;\n    var vertical = options.vertical;\n    var mirror = options.labels.mirror;\n    var axisX = mirror ? box.x1 : box.x2;\n    var axisY = mirror ? box.y2 : box.y1;\n    var lineWidth = options.line.width || 0;\n    return vertical ? new Box(axisX, box.y1, axisX, box.y2 - lineWidth) : new Box(box.x1, axisY, box.x2 - lineWidth, axisY);\n  };\n  Axis.prototype.createTitle = function createTitle() {\n    var options = this.options;\n    var titleOptions = deepExtend({\n      rotation: options.vertical ? -90 : 0,\n      text: \"\",\n      zIndex: 1,\n      visualSize: true\n    }, options.title);\n    if (titleOptions.visible && titleOptions.text) {\n      var title = new TextBox(titleOptions.text, titleOptions);\n      this.append(title);\n      this.title = title;\n    }\n  };\n  Axis.prototype.createNotes = function createNotes() {\n    var this$1 = this;\n    var options = this.options;\n    var notes = options.notes;\n    var items = notes.data || [];\n    this.notes = [];\n    for (var i = 0; i < items.length; i++) {\n      var item = deepExtend({}, notes, items[i]);\n      item.value = this$1.parseNoteValue(item.value);\n      var note = new Note({\n        value: item.value,\n        text: item.label.text,\n        dataItem: item\n      }, item, this$1.chartService);\n      if (note.options.visible) {\n        if (defined(note.options.position)) {\n          if (options.vertical && !inArray(note.options.position, [LEFT, RIGHT])) {\n            note.options.position = options.reverse ? LEFT : RIGHT;\n          } else if (!options.vertical && !inArray(note.options.position, [TOP, BOTTOM])) {\n            note.options.position = options.reverse ? BOTTOM : TOP;\n          }\n        } else {\n          if (options.vertical) {\n            note.options.position = options.reverse ? LEFT : RIGHT;\n          } else {\n            note.options.position = options.reverse ? BOTTOM : TOP;\n          }\n        }\n        this$1.append(note);\n        this$1.notes.push(note);\n      }\n    }\n  };\n  Axis.prototype.parseNoteValue = function parseNoteValue(value) {\n    return value;\n  };\n  Axis.prototype.renderVisual = function renderVisual() {\n    ChartElement.prototype.renderVisual.call(this);\n    this.createPlotBands();\n  };\n  Axis.prototype.createVisual = function createVisual() {\n    ChartElement.prototype.createVisual.call(this);\n    this.createBackground();\n    this.createLine();\n  };\n  Axis.prototype.gridLinesVisual = function gridLinesVisual() {\n    var gridLines = this._gridLines;\n    if (!gridLines) {\n      gridLines = this._gridLines = new draw.Group({\n        zIndex: -2\n      });\n      this.appendVisual(this._gridLines);\n    }\n    return gridLines;\n  };\n  Axis.prototype.createTicks = function createTicks(lineGroup) {\n    var options = this.options;\n    var lineBox = this.lineBox();\n    var mirror = options.labels.mirror;\n    var majorUnit = options.majorTicks.visible ? options.majorUnit : 0;\n    var tickLineOptions = {\n      // TODO\n      // _alignLines: options._alignLines,\n      vertical: options.vertical\n    };\n    function render(tickPositions, tickOptions, skipUnit) {\n      var count = tickPositions.length;\n      var step = Math.max(1, tickOptions.step);\n      if (tickOptions.visible) {\n        for (var i = tickOptions.skip; i < count; i += step) {\n          if (defined(skipUnit) && i % skipUnit === 0) {\n            continue;\n          }\n          tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n          tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n          tickLineOptions.position = tickPositions[i];\n          lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n        }\n      }\n    }\n    render(this.getMajorTickPositions(), options.majorTicks);\n    render(this.getMinorTickPositions(), options.minorTicks, majorUnit / options.minorUnit);\n  };\n  Axis.prototype.createLine = function createLine() {\n    var options = this.options;\n    var line = options.line;\n    var lineBox = this.lineBox();\n    if (line.width > 0 && line.visible) {\n      var path = new draw.Path({\n        stroke: {\n          width: line.width,\n          color: line.color,\n          dashType: line.dashType\n        }\n\n        /* TODO\n        zIndex: line.zIndex,\n        */\n      });\n\n      path.moveTo(lineBox.x1, lineBox.y1).lineTo(lineBox.x2, lineBox.y2);\n      if (options._alignLines) {\n        alignPathToPixel(path);\n      }\n      var group = this._lineGroup = new draw.Group();\n      group.append(path);\n      this.visual.append(group);\n      this.createTicks(group);\n    }\n  };\n  Axis.prototype.getActualTickSize = function getActualTickSize() {\n    var options = this.options;\n    var tickSize = 0;\n    if (options.majorTicks.visible && options.minorTicks.visible) {\n      tickSize = Math.max(options.majorTicks.size, options.minorTicks.size);\n    } else if (options.majorTicks.visible) {\n      tickSize = options.majorTicks.size;\n    } else if (options.minorTicks.visible) {\n      tickSize = options.minorTicks.size;\n    }\n    return tickSize;\n  };\n  Axis.prototype.createBackground = function createBackground() {\n    var ref = this;\n    var options = ref.options;\n    var box = ref.box;\n    var background = options.background;\n    if (background) {\n      this._backgroundPath = draw.Path.fromRect(box.toRect(), {\n        fill: {\n          color: background\n        },\n        stroke: null\n      });\n      this.visual.append(this._backgroundPath);\n    }\n  };\n  Axis.prototype.createPlotBands = function createPlotBands() {\n    var this$1 = this;\n    var options = this.options;\n    var plotBands = options.plotBands || [];\n    var vertical = options.vertical;\n    var plotArea = this.plotArea;\n    if (plotBands.length === 0) {\n      return;\n    }\n    var group = this._plotbandGroup = new draw.Group({\n      zIndex: -1\n    });\n    var altAxis = grep(this.pane.axes, function (axis) {\n      return axis.options.vertical !== this$1.options.vertical;\n    })[0];\n    for (var idx = 0; idx < plotBands.length; idx++) {\n      var item = plotBands[idx];\n      var slotX = void 0,\n        slotY = void 0;\n      var labelOptions = item.label;\n      var label = void 0;\n      if (vertical) {\n        slotX = (altAxis || plotArea.axisX).lineBox();\n        slotY = this$1.getSlot(item.from, item.to, true);\n      } else {\n        slotX = this$1.getSlot(item.from, item.to, true);\n        slotY = (altAxis || plotArea.axisY).lineBox();\n      }\n      if (labelOptions) {\n        labelOptions.vAlign = labelOptions.position || LEFT;\n        label = this$1.createPlotBandLabel(labelOptions, item, new Box(slotX.x1, slotY.y1, slotX.x2, slotY.y2));\n      }\n      if (slotX.width() !== 0 && slotY.height() !== 0) {\n        var bandRect = new geom.Rect([slotX.x1, slotY.y1], [slotX.width(), slotY.height()]);\n        var path = draw.Path.fromRect(bandRect, {\n          fill: {\n            color: item.color,\n            opacity: item.opacity\n          },\n          stroke: null\n        });\n        group.append(path);\n        if (label) {\n          group.append(label);\n        }\n      }\n    }\n    this.appendVisual(group);\n  };\n  Axis.prototype.createPlotBandLabel = function createPlotBandLabel(label, item, box) {\n    if (label.visible === false) {\n      return null;\n    }\n    var text = label.text;\n    var textbox;\n    if (defined(label) && label.visible) {\n      var labelTemplate = getTemplate(label);\n      if (labelTemplate) {\n        text = labelTemplate({\n          text: text,\n          item: item\n        });\n      } else if (label.format) {\n        text = this.chartService.format.auto(label.format, text);\n      }\n      if (!label.color) {\n        label.color = this.options.labels.color;\n      }\n    }\n    textbox = new TextBox(text, label);\n    textbox.reflow(box);\n    textbox.renderVisual();\n    return textbox.visual;\n  };\n  Axis.prototype.createGridLines = function createGridLines(altAxis) {\n    var options = this.options;\n    var minorGridLines = options.minorGridLines;\n    var majorGridLines = options.majorGridLines;\n    var minorUnit = options.minorUnit;\n    var vertical = options.vertical;\n    var axisLineVisible = altAxis.options.line.visible;\n    var majorUnit = majorGridLines.visible ? options.majorUnit : 0;\n    var lineBox = altAxis.lineBox();\n    var linePos = lineBox[vertical ? \"y1\" : \"x1\"];\n    var lineOptions = {\n      lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n      lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n      vertical: vertical\n    };\n    var majorTicks = [];\n    var container = this.gridLinesVisual();\n    function render(tickPositions, gridLine, skipUnit) {\n      var count = tickPositions.length;\n      var step = Math.max(1, gridLine.step);\n      if (gridLine.visible) {\n        for (var i = gridLine.skip; i < count; i += step) {\n          var pos = round(tickPositions[i]);\n          if (!inArray(pos, majorTicks)) {\n            if (i % skipUnit !== 0 && (!axisLineVisible || linePos !== pos)) {\n              lineOptions.position = pos;\n              container.append(createAxisGridLine(lineOptions, gridLine));\n              majorTicks.push(pos);\n            }\n          }\n        }\n      }\n    }\n    render(this.getMajorTickPositions(), majorGridLines);\n    render(this.getMinorTickPositions(), minorGridLines, majorUnit / minorUnit);\n    return container.children;\n  };\n  Axis.prototype.reflow = function reflow(box) {\n    var ref = this;\n    var options = ref.options;\n    var labels = ref.labels;\n    var title = ref.title;\n    var vertical = options.vertical;\n    var count = labels.length;\n    var sizeFn = vertical ? WIDTH : HEIGHT;\n    var titleSize = title ? title.box[sizeFn]() : 0;\n    var space = this.getActualTickSize() + options.margin + titleSize;\n    var rootBox = (this.getRoot() || {}).box || box;\n    var boxSize = rootBox[sizeFn]();\n    var maxLabelSize = 0;\n    for (var i = 0; i < count; i++) {\n      var labelSize = labels[i].box[sizeFn]();\n      if (labelSize + space <= boxSize) {\n        maxLabelSize = Math.max(maxLabelSize, labelSize);\n      }\n    }\n    if (vertical) {\n      this.box = new Box(box.x1, box.y1, box.x1 + maxLabelSize + space, box.y2);\n    } else {\n      this.box = new Box(box.x1, box.y1, box.x2, box.y1 + maxLabelSize + space);\n    }\n    this.arrangeTitle();\n    this.arrangeLabels();\n    this.arrangeNotes();\n  };\n  Axis.prototype.getLabelsTickPositions = function getLabelsTickPositions() {\n    return this.getMajorTickPositions();\n  };\n  Axis.prototype.labelTickIndex = function labelTickIndex(label) {\n    return label.index;\n  };\n  Axis.prototype.arrangeLabels = function arrangeLabels() {\n    var this$1 = this;\n    var ref = this;\n    var options = ref.options;\n    var labels = ref.labels;\n    var labelsBetweenTicks = this.labelsBetweenTicks();\n    var vertical = options.vertical;\n    var mirror = options.labels.mirror;\n    var tickPositions = this.getLabelsTickPositions();\n    for (var idx = 0; idx < labels.length; idx++) {\n      var label = labels[idx];\n      var tickIx = this$1.labelTickIndex(label);\n      var labelSize = vertical ? label.box.height() : label.box.width();\n      var firstTickPosition = tickPositions[tickIx];\n      var nextTickPosition = tickPositions[tickIx + 1];\n      var positionStart = void 0,\n        positionEnd = void 0;\n      if (vertical) {\n        if (labelsBetweenTicks) {\n          var middle = firstTickPosition + (nextTickPosition - firstTickPosition) / 2;\n          positionStart = middle - labelSize / 2;\n        } else {\n          positionStart = firstTickPosition - labelSize / 2;\n        }\n        positionEnd = positionStart;\n      } else {\n        if (labelsBetweenTicks) {\n          positionStart = firstTickPosition;\n          positionEnd = nextTickPosition;\n        } else {\n          positionStart = firstTickPosition - labelSize / 2;\n          positionEnd = positionStart + labelSize;\n        }\n      }\n      this$1.positionLabel(label, mirror, positionStart, positionEnd);\n    }\n  };\n  Axis.prototype.positionLabel = function positionLabel(label, mirror, positionStart, positionEnd) {\n    if (positionEnd === void 0) positionEnd = positionStart;\n    var options = this.options;\n    var vertical = options.vertical;\n    var lineBox = this.lineBox();\n    var labelOffset = this.getActualTickSize() + options.margin;\n    var labelBox;\n    if (vertical) {\n      var labelX = lineBox.x2;\n      if (mirror) {\n        labelX += labelOffset;\n        label.options.rotationOrigin = LEFT;\n      } else {\n        labelX -= labelOffset + label.box.width();\n        label.options.rotationOrigin = RIGHT;\n      }\n      labelBox = label.box.move(labelX, positionStart);\n    } else {\n      var labelY = lineBox.y1;\n      if (mirror) {\n        labelY -= labelOffset + label.box.height();\n        label.options.rotationOrigin = BOTTOM;\n      } else {\n        labelY += labelOffset;\n        label.options.rotationOrigin = TOP;\n      }\n      labelBox = new Box(positionStart, labelY, positionEnd, labelY + label.box.height());\n    }\n    label.reflow(labelBox);\n  };\n  Axis.prototype.autoRotateLabelAngle = function autoRotateLabelAngle(labelBox, slotWidth) {\n    if (labelBox.width() < slotWidth) {\n      return 0;\n    }\n    if (labelBox.height() > slotWidth) {\n      return -90;\n    }\n    return -45;\n  };\n  Axis.prototype.autoRotateLabels = function autoRotateLabels() {\n    var this$1 = this;\n    if (!this.options.autoRotateLabels || this.options.vertical) {\n      return false;\n    }\n    var tickPositions = this.getMajorTickPositions();\n    var labels = this.labels;\n    var limit = Math.min(labels.length, tickPositions.length - 1);\n    var angle = 0;\n    for (var idx = 0; idx < limit; idx++) {\n      var width = Math.abs(tickPositions[idx + 1] - tickPositions[idx]);\n      var labelBox = labels[idx].box;\n      var labelAngle = this$1.autoRotateLabelAngle(labelBox, width);\n      if (labelAngle !== 0) {\n        angle = labelAngle;\n      }\n      if (angle === -90) {\n        break;\n      }\n    }\n    if (angle !== 0) {\n      for (var idx$1 = 0; idx$1 < labels.length; idx$1++) {\n        labels[idx$1].options.rotation = angle;\n        labels[idx$1].reflow(new Box());\n      }\n      return true;\n    }\n  };\n  Axis.prototype.arrangeTitle = function arrangeTitle() {\n    var ref = this;\n    var options = ref.options;\n    var title = ref.title;\n    var mirror = options.labels.mirror;\n    var vertical = options.vertical;\n    if (title) {\n      if (vertical) {\n        title.options.align = mirror ? RIGHT : LEFT;\n        title.options.vAlign = title.options.position;\n      } else {\n        title.options.align = title.options.position;\n        title.options.vAlign = mirror ? TOP : BOTTOM;\n      }\n      title.reflow(this.box);\n    }\n  };\n  Axis.prototype.arrangeNotes = function arrangeNotes() {\n    var this$1 = this;\n    for (var idx = 0; idx < this.notes.length; idx++) {\n      var item = this$1.notes[idx];\n      var value = item.options.value;\n      var slot = void 0;\n      if (defined(value)) {\n        if (this$1.shouldRenderNote(value)) {\n          item.show();\n        } else {\n          item.hide();\n        }\n        slot = this$1.noteSlot(value);\n      } else {\n        item.hide();\n      }\n      item.reflow(slot || this$1.lineBox());\n    }\n  };\n  Axis.prototype.noteSlot = function noteSlot(value) {\n    return this.getSlot(value);\n  };\n  Axis.prototype.alignTo = function alignTo(secondAxis) {\n    var lineBox = secondAxis.lineBox();\n    var vertical = this.options.vertical;\n    var pos = vertical ? Y : X;\n    this.box.snapTo(lineBox, pos);\n    if (vertical) {\n      this.box.shrink(0, this.lineBox().height() - lineBox.height());\n    } else {\n      this.box.shrink(this.lineBox().width() - lineBox.width(), 0);\n    }\n    this.box[pos + 1] -= this.lineBox()[pos + 1] - lineBox[pos + 1];\n    this.box[pos + 2] -= this.lineBox()[pos + 2] - lineBox[pos + 2];\n  };\n  Axis.prototype.axisLabelText = function axisLabelText(value, options, context) {\n    var this$1 = this;\n    var text;\n    var tmpl = getTemplate(options);\n    var defaultText = function defaultText() {\n      if (!options.format) {\n        return value;\n      }\n      return this$1.chartService.format.localeAuto(options.format, [value], options.culture);\n    };\n    if (tmpl) {\n      var templateContext = Object.assign({}, context, {\n        get text() {\n          return defaultText();\n        },\n        value: value,\n        format: options.format,\n        culture: options.culture\n      });\n      text = tmpl(templateContext);\n    } else {\n      text = defaultText();\n    }\n    return text;\n  };\n  Axis.prototype.slot = function slot(from, to, limit) {\n    var slot = this.getSlot(from, to, limit);\n    if (slot) {\n      return slot.toRect();\n    }\n  };\n  Axis.prototype.contentBox = function contentBox() {\n    var box = this.box.clone();\n    var labels = this.labels;\n    if (labels.length) {\n      var axis = this.options.vertical ? Y : X;\n      if (this.chartService.isPannable(axis)) {\n        var offset = this.maxLabelOffset();\n        box[axis + 1] -= offset.start;\n        box[axis + 2] += offset.end;\n      } else {\n        if (labels[0].options.visible) {\n          box.wrap(labels[0].box);\n        }\n        var lastLabel = labels[labels.length - 1];\n        if (lastLabel.options.visible) {\n          box.wrap(lastLabel.box);\n        }\n      }\n    }\n    return box;\n  };\n  Axis.prototype.maxLabelOffset = function maxLabelOffset() {\n    var this$1 = this;\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var reverse = ref.reverse;\n    var labelsBetweenTicks = this.labelsBetweenTicks();\n    var tickPositions = this.getLabelsTickPositions();\n    var offsetField = vertical ? Y : X;\n    var labels = this.labels;\n    var startPosition = reverse ? 1 : 0;\n    var endPosition = reverse ? 0 : 1;\n    var maxStartOffset = 0;\n    var maxEndOffset = 0;\n    for (var idx = 0; idx < labels.length; idx++) {\n      var label = labels[idx];\n      var tickIx = this$1.labelTickIndex(label);\n      var startTick = void 0,\n        endTick = void 0;\n      if (labelsBetweenTicks) {\n        startTick = tickPositions[tickIx + startPosition];\n        endTick = tickPositions[tickIx + endPosition];\n      } else {\n        startTick = endTick = tickPositions[tickIx];\n      }\n      maxStartOffset = Math.max(maxStartOffset, startTick - label.box[offsetField + 1]);\n      maxEndOffset = Math.max(maxEndOffset, label.box[offsetField + 2] - endTick);\n    }\n    return {\n      start: maxStartOffset,\n      end: maxEndOffset\n    };\n  };\n  Axis.prototype.limitRange = function limitRange(from, to, min, max, offset) {\n    var options = this.options;\n    if (from < min && offset < 0 && (!defined(options.min) || options.min <= min) || max < to && offset > 0 && (!defined(options.max) || max <= options.max)) {\n      return null;\n    }\n    if (to < min && offset > 0 || max < from && offset < 0) {\n      return {\n        min: from,\n        max: to\n      };\n    }\n    var rangeSize = to - from;\n    var minValue = from;\n    var maxValue = to;\n    if (from < min && offset < 0) {\n      minValue = limitValue(from, min, max);\n      maxValue = limitValue(from + rangeSize, min + rangeSize, max);\n    } else if (to > max && offset > 0) {\n      maxValue = limitValue(to, min, max);\n      minValue = limitValue(to - rangeSize, min, max - rangeSize);\n    }\n    return {\n      min: minValue,\n      max: maxValue\n    };\n  };\n  Axis.prototype.valueRange = function valueRange() {\n    return {\n      min: this.seriesMin,\n      max: this.seriesMax\n    };\n  };\n  Axis.prototype.lineDir = function lineDir() {\n    /*\n     * Axis line direction:\n     *   * Vertical: up.\n     *   * Horizontal: right.\n     */\n\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var reverse = ref.reverse;\n    return (vertical ? -1 : 1) * (reverse ? -1 : 1);\n  };\n  Axis.prototype.lineInfo = function lineInfo() {\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var lineBox = this.lineBox();\n    var lineSize = vertical ? lineBox.height() : lineBox.width();\n    var axis = vertical ? Y : X;\n    var axisDir = this.lineDir();\n    var startEdge = axisDir === 1 ? 1 : 2;\n    var axisOrigin = axis + startEdge.toString();\n    var lineStart = lineBox[axisOrigin];\n    return {\n      axis: axis,\n      axisOrigin: axisOrigin,\n      axisDir: axisDir,\n      lineBox: lineBox,\n      lineSize: lineSize,\n      lineStart: lineStart\n    };\n  };\n  Axis.prototype.pointOffset = function pointOffset(point) {\n    var ref = this.lineInfo();\n    var axis = ref.axis;\n    var axisDir = ref.axisDir;\n    var axisOrigin = ref.axisOrigin;\n    var lineBox = ref.lineBox;\n    var lineSize = ref.lineSize;\n    var relative = axisDir > 0 ? point[axis] - lineBox[axisOrigin] : lineBox[axisOrigin] - point[axis];\n    var offset = relative / lineSize;\n    return offset;\n  };\n\n  // Computes the axis range change (delta) for a given scale factor.\n  // The delta is subtracted from the axis range:\n  //   * delta > 0 reduces the axis range (zoom-in)\n  //   * delta < 0 expands the axis range (zoom-out)\n  Axis.prototype.scaleToDelta = function scaleToDelta(rawScale, range) {\n    // Scale >= 1 would result in axis range of 0.\n    // Scale <= -1 would reverse the scale direction.\n    var MAX_SCALE = 0.999;\n    var scale = limitValue(rawScale, -MAX_SCALE, MAX_SCALE);\n    var delta;\n    if (scale > 0) {\n      delta = range * Math.min(1, scale);\n    } else {\n      delta = range - range / (1 + scale);\n    }\n    return delta;\n  };\n  Axis.prototype.labelsBetweenTicks = function labelsBetweenTicks() {\n    return !this.options.justified;\n  };\n\n  //add legacy fields to the options that are no longer generated by default\n  Axis.prototype.prepareUserOptions = function prepareUserOptions() {};\n  return Axis;\n}(ChartElement);\nsetDefaultOptions(Axis, {\n  labels: {\n    visible: true,\n    rotation: 0,\n    mirror: false,\n    step: 1,\n    skip: 0\n  },\n  line: {\n    width: 1,\n    color: BLACK,\n    visible: true\n  },\n  title: {\n    visible: true,\n    position: CENTER\n  },\n  majorTicks: {\n    align: OUTSIDE,\n    size: 4,\n    skip: 0,\n    step: 1\n  },\n  minorTicks: {\n    align: OUTSIDE,\n    size: 3,\n    skip: 0,\n    step: 1\n  },\n  axisCrossingValue: 0,\n  majorTickType: OUTSIDE,\n  minorTickType: NONE,\n  majorGridLines: {\n    skip: 0,\n    step: 1\n  },\n  minorGridLines: {\n    visible: false,\n    width: 1,\n    color: BLACK,\n    skip: 0,\n    step: 1\n  },\n  // TODO: Move to line or labels options\n  margin: 5,\n  visible: true,\n  reverse: false,\n  justified: true,\n  notes: {\n    label: {\n      text: \"\"\n    }\n  },\n  _alignLines: true,\n  _deferLabels: false\n});\nexport default Axis;","map":null,"metadata":{},"sourceType":"module"}
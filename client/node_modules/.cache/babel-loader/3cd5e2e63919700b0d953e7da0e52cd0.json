{"ast":null,"code":"import { Point, Segment } from '../../geometry';\nimport { last, round } from '../../util';\nvar WEIGHT = 0.333;\nvar EXTREMUM_ALLOWED_DEVIATION = 0.01;\nvar X = \"x\";\nvar Y = \"y\";\nexport function pointsToCurve(pointsIn, closed) {\n  var points = pointsIn.slice(0);\n  var segments = [];\n  var length = points.length;\n  if (length > 2) {\n    removeDuplicates(0, points);\n    length = points.length;\n  }\n  if (length < 2 || length === 2 && points[0].equals(points[1])) {\n    return segments;\n  }\n  var p0 = points[0];\n  var p1 = points[1];\n  var p2 = points[2];\n  segments.push(new Segment(p0));\n  while (p0.equals(points[length - 1])) {\n    closed = true;\n    points.pop();\n    length--;\n  }\n  if (length === 2) {\n    var tangent = getTangent(p0, p1, X, Y);\n    last(segments).controlOut(firstControlPoint(tangent, p0, p1, X, Y));\n    segments.push(new Segment(p1, secondControlPoint(tangent, p0, p1, X, Y)));\n    return segments;\n  }\n  var initialControlPoint, lastControlPoint;\n  if (closed) {\n    p0 = points[length - 1];\n    p1 = points[0];\n    p2 = points[1];\n    var controlPoints = getControlPoints(p0, p1, p2);\n    initialControlPoint = controlPoints[1];\n    lastControlPoint = controlPoints[0];\n  } else {\n    var tangent$1 = getTangent(p0, p1, X, Y);\n    initialControlPoint = firstControlPoint(tangent$1, p0, p1, X, Y);\n  }\n  var cp0 = initialControlPoint;\n  for (var idx = 0; idx <= length - 3; idx++) {\n    removeDuplicates(idx, points);\n    length = points.length;\n    if (idx + 3 <= length) {\n      p0 = points[idx];\n      p1 = points[idx + 1];\n      p2 = points[idx + 2];\n      var controlPoints$1 = getControlPoints(p0, p1, p2);\n      last(segments).controlOut(cp0);\n      cp0 = controlPoints$1[1];\n      var cp1 = controlPoints$1[0];\n      segments.push(new Segment(p1, cp1));\n    }\n  }\n  if (closed) {\n    p0 = points[length - 2];\n    p1 = points[length - 1];\n    p2 = points[0];\n    var controlPoints$2 = getControlPoints(p0, p1, p2);\n    last(segments).controlOut(cp0);\n    segments.push(new Segment(p1, controlPoints$2[0]));\n    last(segments).controlOut(controlPoints$2[1]);\n    segments.push(new Segment(p2, lastControlPoint));\n  } else {\n    var tangent$2 = getTangent(p1, p2, X, Y);\n    last(segments).controlOut(cp0);\n    segments.push(new Segment(p2, secondControlPoint(tangent$2, p1, p2, X, Y)));\n  }\n  return segments;\n}\nexport function pointsToClosedCurve(pointsIn) {\n  return pointsToCurve(pointsIn, true);\n}\nexport function removeDuplicates(idx, points) {\n  while (points[idx + 1] && (points[idx].equals(points[idx + 1]) || points[idx + 1].equals(points[idx + 2]))) {\n    points.splice(idx + 1, 1);\n  }\n}\nexport function invertAxis(p0, p1, p2) {\n  var invertAxis = false;\n  if (p0.x === p1.x) {\n    invertAxis = true;\n  } else if (p1.x === p2.x) {\n    if (p1.y < p2.y && p0.y <= p1.y || p2.y < p1.y && p1.y <= p0.y) {\n      invertAxis = true;\n    }\n  } else {\n    var fn = lineFunction(p0, p1);\n    var y2 = calculateFunction(fn, p2.x);\n    if (!(p0.y <= p1.y && p2.y <= y2) && !(p1.y <= p0.y && p2.y >= y2)) {\n      invertAxis = true;\n    }\n  }\n  return invertAxis;\n}\nexport function isLine(p0, p1, p2) {\n  var fn = lineFunction(p0, p1);\n  var y2 = calculateFunction(fn, p2.x);\n  return p0.x === p1.x && p1.x === p2.x || round(y2, 1) === round(p2.y, 1);\n}\nexport function lineFunction(p1, p2) {\n  var a = (p2.y - p1.y) / (p2.x - p1.x);\n  var b = p1.y - a * p1.x;\n  return [b, a];\n}\nexport function getControlPoints(p0, p1, p2) {\n  var xField = X;\n  var yField = Y;\n  var restrict = false;\n  var switchOrientation = false;\n  var tangent;\n  if (isLine(p0, p1, p2)) {\n    tangent = getTangent(p0, p1, X, Y);\n  } else {\n    var monotonic = {\n      x: isMonotonicByField(p0, p1, p2, X),\n      y: isMonotonicByField(p0, p1, p2, Y)\n    };\n    if (monotonic.x && monotonic.y) {\n      tangent = getTangent(p0, p2, X, Y);\n      restrict = true;\n    } else {\n      if (invertAxis(p0, p1, p2)) {\n        xField = Y;\n        yField = X;\n      }\n      if (monotonic[xField]) {\n        tangent = 0;\n      } else {\n        var sign;\n        if (p2[yField] < p0[yField] && p0[yField] <= p1[yField] || p0[yField] < p2[yField] && p1[yField] <= p0[yField]) {\n          sign = numberSign((p2[yField] - p0[yField]) * (p1[xField] - p0[xField]));\n        } else {\n          sign = -numberSign((p2[xField] - p0[xField]) * (p1[yField] - p0[yField]));\n        }\n        tangent = EXTREMUM_ALLOWED_DEVIATION * sign;\n        switchOrientation = true;\n      }\n    }\n  }\n  var secondCP = secondControlPoint(tangent, p0, p1, xField, yField);\n  if (switchOrientation) {\n    var oldXField = xField;\n    xField = yField;\n    yField = oldXField;\n  }\n  var firstCP = firstControlPoint(tangent, p1, p2, xField, yField);\n  if (restrict) {\n    restrictControlPoint(p0, p1, secondCP, tangent);\n    restrictControlPoint(p1, p2, firstCP, tangent);\n  }\n  return [secondCP, firstCP];\n}\nexport function restrictControlPoint(p1, p2, cp, tangent) {\n  if (p1.y < p2.y) {\n    if (p2.y < cp.y) {\n      cp.x = p1.x + (p2.y - p1.y) / tangent;\n      cp.y = p2.y;\n    } else if (cp.y < p1.y) {\n      cp.x = p2.x - (p2.y - p1.y) / tangent;\n      cp.y = p1.y;\n    }\n  } else {\n    if (cp.y < p2.y) {\n      cp.x = p1.x - (p1.y - p2.y) / tangent;\n      cp.y = p2.y;\n    } else if (p1.y < cp.y) {\n      cp.x = p2.x + (p1.y - p2.y) / tangent;\n      cp.y = p1.y;\n    }\n  }\n}\nexport function getTangent(p0, p1, xField, yField) {\n  var x = p1[xField] - p0[xField];\n  var y = p1[yField] - p0[yField];\n  var tangent;\n  if (x === 0) {\n    tangent = 0;\n  } else {\n    tangent = y / x;\n  }\n  return tangent;\n}\nexport function isMonotonicByField(p0, p1, p2, field) {\n  return p2[field] > p1[field] && p1[field] > p0[field] || p2[field] < p1[field] && p1[field] < p0[field];\n}\nexport function firstControlPoint(tangent, p0, p3, xField, yField) {\n  var t1 = p0[xField];\n  var t2 = p3[xField];\n  var distance = (t2 - t1) * WEIGHT;\n  return point(t1 + distance, p0[yField] + distance * tangent, xField, yField);\n}\nexport function secondControlPoint(tangent, p0, p3, xField, yField) {\n  var t1 = p0[xField];\n  var t2 = p3[xField];\n  var distance = (t2 - t1) * WEIGHT;\n  return point(t2 - distance, p3[yField] - distance * tangent, xField, yField);\n}\nexport function point(xValue, yValue, xField, yField) {\n  var controlPoint = new Point();\n  controlPoint[xField] = xValue;\n  controlPoint[yField] = yValue;\n  return controlPoint;\n}\nexport function calculateFunction(fn, x) {\n  var length = fn.length;\n  var result = 0;\n  for (var i = 0; i < length; i++) {\n    result += Math.pow(x, i) * fn[i];\n  }\n  return result;\n}\nexport function numberSign(value) {\n  return value <= 0 ? -1 : 1;\n}","map":null,"metadata":{},"sourceType":"module"}
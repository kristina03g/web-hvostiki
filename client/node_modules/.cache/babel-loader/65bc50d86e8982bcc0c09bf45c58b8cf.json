{"ast":null,"code":"/* eslint-disable no-multi-spaces, key-spacing, indent, camelcase, space-before-blocks, eqeqeq, brace-style */\n/* eslint-disable space-infix-ops, space-before-function-paren, array-bracket-spacing, object-curly-spacing */\n/* eslint-disable no-nested-ternary, max-params, default-case, no-else-return, no-empty */\n/* eslint-disable no-param-reassign, no-var, block-scoped-var */\n\nimport { BinaryStream, ucs2encode, base64ToUint8Array, HAS_TYPED_ARRAYS } from \"./utils\";\nimport { support } from '../common';\nimport { TTFFont } from \"./ttf\";\nimport { deflate, supportsDeflate } from './deflate';\nimport { encodeUTF16BE, BOM } from \"../util/encode-utf\";\nimport { encodeBase64 } from \"../util\";\nvar browser = support.browser;\nvar NL = \"\\n\";\nvar RESOURCE_COUNTER = 0;\nvar PAPER_SIZE = {\n  a0: [2383.94, 3370.39],\n  a1: [1683.78, 2383.94],\n  a2: [1190.55, 1683.78],\n  a3: [841.89, 1190.55],\n  a4: [595.28, 841.89],\n  a5: [419.53, 595.28],\n  a6: [297.64, 419.53],\n  a7: [209.76, 297.64],\n  a8: [147.40, 209.76],\n  a9: [104.88, 147.40],\n  a10: [73.70, 104.88],\n  b0: [2834.65, 4008.19],\n  b1: [2004.09, 2834.65],\n  b2: [1417.32, 2004.09],\n  b3: [1000.63, 1417.32],\n  b4: [708.66, 1000.63],\n  b5: [498.90, 708.66],\n  b6: [354.33, 498.90],\n  b7: [249.45, 354.33],\n  b8: [175.75, 249.45],\n  b9: [124.72, 175.75],\n  b10: [87.87, 124.72],\n  c0: [2599.37, 3676.54],\n  c1: [1836.85, 2599.37],\n  c2: [1298.27, 1836.85],\n  c3: [918.43, 1298.27],\n  c4: [649.13, 918.43],\n  c5: [459.21, 649.13],\n  c6: [323.15, 459.21],\n  c7: [229.61, 323.15],\n  c8: [161.57, 229.61],\n  c9: [113.39, 161.57],\n  c10: [79.37, 113.39],\n  executive: [521.86, 756.00],\n  folio: [612.00, 936.00],\n  legal: [612.00, 1008.00],\n  letter: [612.00, 792.00],\n  tabloid: [792.00, 1224.00]\n};\nfunction makeOutput() {\n  var indentLevel = 0,\n    output = BinaryStream();\n  function out() {\n    var arguments$1 = arguments;\n    for (var i = 0; i < arguments.length; ++i) {\n      var x = arguments$1[i];\n      if (x === undefined) {\n        throw new Error(\"Cannot output undefined to PDF\");\n      } else if (x instanceof PDFValue) {\n        x.beforeRender(out);\n        x.render(out);\n      } else if (isArray(x)) {\n        renderArray(x, out);\n      } else if (isDate(x)) {\n        renderDate(x, out);\n      } else if (typeof x == \"number\") {\n        if (isNaN(x)) {\n          throw new Error(\"Cannot output NaN to PDF\");\n        }\n        // make sure it doesn't end up in exponent notation\n        var num = x.toFixed(7);\n        if (num.indexOf(\".\") >= 0) {\n          num = num.replace(/\\.?0+$/, \"\");\n        }\n        if (num == \"-0\") {\n          num = \"0\";\n        }\n        output.writeString(num);\n      } else if (/string|boolean/.test(typeof x)) {\n        output.writeString(String(x));\n      } else if (typeof x.get == \"function\") {\n        output.write(x.get());\n      } else if (typeof x == \"object\") {\n        if (!x) {\n          output.writeString(\"null\");\n        } else {\n          out(new PDFDictionary(x));\n        }\n      }\n    }\n  }\n  out.writeData = function (data) {\n    output.write(data);\n  };\n  out.withIndent = function (f) {\n    ++indentLevel;\n    f(out);\n    --indentLevel;\n  };\n  out.indent = function () {\n    out(NL, pad(\"\", indentLevel * 2, \"  \"));\n    out.apply(null, arguments);\n  };\n  out.offset = function () {\n    return output.offset();\n  };\n  out.toString = function () {\n    throw new Error(\"FIX CALLER\");\n  };\n  out.get = function () {\n    return output.get();\n  };\n  out.stream = function () {\n    return output;\n  };\n  return out;\n}\nfunction wrapObject(value, id) {\n  var beforeRender = value.beforeRender;\n  var renderValue = value.render;\n  value.beforeRender = function () {};\n  value.render = function (out) {\n    out(id, \" 0 R\");\n  };\n  value.renderFull = function (out) {\n    value._offset = out.offset();\n    out(id, \" 0 obj \");\n    beforeRender.call(value, out);\n    renderValue.call(value, out);\n    out(\" endobj\");\n  };\n}\nfunction getPaperOptions(getOption) {\n  if (typeof getOption != \"function\") {\n    var options = getOption;\n    getOption = function getOption(key, def) {\n      return key in options ? options[key] : def;\n    };\n  }\n  var paperSize = getOption(\"paperSize\", PAPER_SIZE.a4);\n  if (!paperSize) {\n    return {};\n  }\n  if (typeof paperSize == \"string\") {\n    paperSize = PAPER_SIZE[paperSize.toLowerCase()];\n    if (paperSize == null) {\n      throw new Error(\"Unknown paper size\");\n    }\n  }\n  paperSize[0] = unitsToPoints(paperSize[0]);\n  paperSize[1] = unitsToPoints(paperSize[1]);\n  if (getOption(\"landscape\", false)) {\n    paperSize = [Math.max(paperSize[0], paperSize[1]), Math.min(paperSize[0], paperSize[1])];\n  }\n  var margin = getOption(\"margin\");\n  if (margin) {\n    if (typeof margin == \"string\" || typeof margin == \"number\") {\n      margin = unitsToPoints(margin, 0);\n      margin = {\n        left: margin,\n        top: margin,\n        right: margin,\n        bottom: margin\n      };\n    } else {\n      margin = {\n        left: unitsToPoints(margin.left, 0),\n        top: unitsToPoints(margin.top, 0),\n        right: unitsToPoints(margin.right, 0),\n        bottom: unitsToPoints(margin.bottom, 0)\n      };\n    }\n    if (getOption(\"addMargin\")) {\n      paperSize[0] += margin.left + margin.right;\n      paperSize[1] += margin.top + margin.bottom;\n    }\n  }\n  return {\n    paperSize: paperSize,\n    margin: margin\n  };\n}\nvar FONT_CACHE = {\n  \"Times-Roman\": true,\n  \"Times-Bold\": true,\n  \"Times-Italic\": true,\n  \"Times-BoldItalic\": true,\n  \"Helvetica\": true,\n  \"Helvetica-Bold\": true,\n  \"Helvetica-Oblique\": true,\n  \"Helvetica-BoldOblique\": true,\n  \"Courier\": true,\n  \"Courier-Bold\": true,\n  \"Courier-Oblique\": true,\n  \"Courier-BoldOblique\": true,\n  \"Symbol\": true,\n  \"ZapfDingbats\": true\n};\nfunction loadBinary(url, cont) {\n  // IE throws Accesss denied error for Data URIs\n  var m;\n  if (browser.msie && (m = /^data:.*?;base64,/i.exec(url))) {\n    cont(base64ToUint8Array(url.substr(m[0].length)));\n    return;\n  }\n  function error() {\n    if (window.console) {\n      if (window.console.error) {\n        window.console.error(\"Cannot load URL: %s\", url);\n      } else {\n        window.console.log(\"Cannot load URL: %s\", url);\n      }\n    }\n    cont(null);\n  }\n  var req = new XMLHttpRequest();\n  req.open('GET', url, true);\n  if (HAS_TYPED_ARRAYS) {\n    req.responseType = \"arraybuffer\";\n  }\n  req.onload = function () {\n    if (req.status == 200 || req.status == 304) {\n      if (HAS_TYPED_ARRAYS) {\n        cont(new Uint8Array(req.response));\n      } else {\n        cont(new window.VBArray(req.responseBody).toArray()); // IE9 only\n      }\n    } else {\n      error();\n    }\n  };\n  req.onerror = error;\n  req.send(null);\n}\nfunction loadFont(url, cont) {\n  var font = FONT_CACHE[url];\n  if (font) {\n    cont(font);\n  } else {\n    loadBinary(url, function (data) {\n      if (data == null) {\n        throw new Error(\"Cannot load font from \" + url);\n      } else {\n        var font = new TTFFont(data);\n        FONT_CACHE[url] = font;\n        cont(font);\n      }\n    });\n  }\n}\nvar IMAGE_CACHE = {};\nfunction clearImageCache() {\n  IMAGE_CACHE = {};\n}\nfunction loadImage(url, size, cont, options) {\n  var img = IMAGE_CACHE[url],\n    bloburl,\n    blob;\n  if (img) {\n    cont(img);\n  } else {\n    img = new Image();\n    if (!/^data:/i.test(url)) {\n      img.crossOrigin = \"Anonymous\";\n    }\n    if (HAS_TYPED_ARRAYS && !/^data:/i.test(url)) {\n      // IE10 fails to load images from another domain even when the server sends the\n      // proper CORS headers.  a XHR, however, will be able to load the data.\n      // http://stackoverflow.com/a/19734516/154985\n      //\n      // On the other hand, it's worth doing it this way for all browsers which support\n      // responseType = \"blob\" (HAS_TYPED_ARRAYS will be true), because we can inspect the\n      // mime type and if it's a JPEG (very common case) we can save a lot of time in\n      // _load below.\n      var xhr = new XMLHttpRequest();\n      xhr.onload = function () {\n        blob = xhr.response;\n        if (browser.mozilla && blob.type == \"image/svg+xml\") {\n          // Firefox won't render SVGs that don't contain width and height attributes.\n          var reader = new FileReader();\n          reader.onload = function () {\n            var doc = new window.DOMParser().parseFromString(this.result, \"image/svg+xml\");\n            var svg = doc.documentElement;\n            if (svg.getAttribute(\"width\") && svg.getAttribute(\"height\")) {\n              // we're good, continue with the existing blob.\n              bloburl = URL.createObjectURL(blob);\n              _load(bloburl);\n            } else {\n              svg.setAttribute(\"width\", size.width);\n              svg.setAttribute(\"height\", size.height);\n              var xml = new window.XMLSerializer().serializeToString(svg);\n              var dataURL = \"data:image/svg+xml;base64,\" + encodeBase64(xml);\n              _load(dataURL);\n            }\n          };\n          reader.readAsText(blob);\n        } else {\n          bloburl = URL.createObjectURL(blob);\n          _load(bloburl);\n        }\n      };\n      xhr.onerror = _onerror;\n      xhr.open(\"GET\", url, true);\n      xhr.responseType = \"blob\";\n      xhr.send();\n    } else {\n      _load(url);\n    }\n  }\n  function _load(url) {\n    img.src = url;\n    if (img.complete && !browser.msie) {\n      // IE, bless its little heart, says img.complete == true even though the image is\n      // not loaded (width=0), therefore we must go the onload route (ticket 929635).\n      _onload.call(img);\n    } else {\n      img.onload = _onload;\n      img.onerror = _onerror;\n    }\n  }\n  function _trycanvas() {\n    if (!size) {\n      size = {\n        width: img.width,\n        height: img.height\n      };\n    }\n    var canvas = document.createElement(\"canvas\");\n    canvas.width = size.width;\n    canvas.height = size.height;\n    var ctx = canvas.getContext(\"2d\");\n    ctx.drawImage(img, 0, 0, size.width, size.height);\n    var imgdata;\n    try {\n      imgdata = ctx.getImageData(0, 0, size.width, size.height);\n    } catch (ex) {\n      // it tainted the canvas -- can't draw it.\n      _onerror();\n      return;\n    } finally {\n      if (bloburl) {\n        URL.revokeObjectURL(bloburl);\n      }\n    }\n\n    // in case it contains transparency, we must separate rgb data from the alpha\n    // channel and create a PDFRawImage image with opacity.  otherwise we can use a\n    // PDFJpegImage.\n    //\n    // to do this in one step, we create the rgb and alpha streams anyway, even if\n    // we might end up not using them if hasAlpha remains false.\n\n    var hasAlpha = false,\n      rgb = BinaryStream(),\n      alpha = BinaryStream();\n    var rawbytes = imgdata.data;\n    var i = 0;\n    while (i < rawbytes.length) {\n      rgb.writeByte(rawbytes[i++]);\n      rgb.writeByte(rawbytes[i++]);\n      rgb.writeByte(rawbytes[i++]);\n      var a = rawbytes[i++];\n      if (a < 255) {\n        hasAlpha = true;\n      }\n      alpha.writeByte(a);\n    }\n    if (hasAlpha || options.keepPNG) {\n      img = new PDFRawImage(size.width, size.height, rgb, alpha);\n    } else {\n      // no transparency, encode as JPEG.\n      var data = canvas.toDataURL(\"image/jpeg\", options.jpegQuality);\n      data = data.substr(data.indexOf(\";base64,\") + 8);\n      var stream = BinaryStream();\n      stream.writeBase64(data);\n      img = new PDFJpegImage(stream);\n    }\n    cont(IMAGE_CACHE[url] = img);\n  }\n  function _onerror() {\n    cont(IMAGE_CACHE[url] = \"ERROR\");\n  }\n  function _onload() {\n    if (size) {\n      var svg = blob && blob.type === 'image/svg+xml' || /^data:image\\/svg\\+xml;/i.test(this.src.substring(0, 19));\n      var upscale = size.width >= img.width || size.height >= img.height;\n\n      // Use the original image if requested size is bigger than the source,\n      // unless it's an SVG that can be upscaled.\n      if (!svg && upscale) {\n        size = null;\n      }\n    }\n    if (!size && blob && /^image\\/jpe?g$/i.test(blob.type)) {\n      // If we know we got a JPEG, we can skip the process of rendering it to a\n      // canvas, getting the pixel data, searching for transparency we know we won't\n      // find, getting back a data URI and then decoding the BASE64 to finally get the\n      // binary we already have.  Also, we avoid downgrading the image quality, with\n      // the possible drawback of making a bigger PDF; still, seems legit.\n      //\n      // Besides saving a lot of work, this also reuses the buffer memory\n      // (BinaryStream does not create a copy), potentially saving some GC cycles.\n      var reader = new FileReader();\n      reader.onload = function () {\n        try {\n          var img = new PDFJpegImage(BinaryStream(new Uint8Array(this.result)));\n          URL.revokeObjectURL(bloburl);\n          cont(IMAGE_CACHE[url] = img);\n        } catch (ex) {\n          // if there's an error parsing the JPEG stream, it could be due to a\n          // misconfigured server (improper content-type:\n          // https://github.com/telerik/kendo-ui-core/issues/4184).  If that's the case,\n          // the canvas will still be able to draw it.\n          _trycanvas();\n        }\n      };\n      reader.readAsArrayBuffer(blob);\n    } else {\n      _trycanvas();\n    }\n  }\n}\nfunction manyLoader(loadOne) {\n  return function (urls, callback) {\n    var n = urls.length,\n      i = n;\n    if (n === 0) {\n      return callback();\n    }\n    function next() {\n      if (--n === 0) {\n        callback();\n      }\n    }\n    while (i-- > 0) {\n      loadOne(urls[i], next);\n    }\n  };\n}\nvar loadFonts = manyLoader(loadFont);\nvar loadImages = function loadImages(images, callback, options) {\n  options = Object.assign({\n    jpegQuality: 0.92,\n    keepPNG: false\n  }, options);\n  var urls = Object.keys(images),\n    n = urls.length;\n  if (n === 0) {\n    return callback();\n  }\n  function next() {\n    if (--n === 0) {\n      callback();\n    }\n  }\n  urls.forEach(function (url) {\n    loadImage(url, images[url], next, options);\n  });\n};\nvar PDFDocument = function PDFDocument(options) {\n  var self = this;\n  var out = makeOutput();\n  var objcount = 0;\n  var objects = [];\n  function getOption(name, defval) {\n    return options && options[name] != null ? options[name] : defval;\n  }\n  self.getOption = getOption;\n  self.attach = function (value) {\n    if (objects.indexOf(value) < 0) {\n      wrapObject(value, ++objcount);\n      objects.push(value);\n    }\n    return value;\n  };\n  self.pages = [];\n  self.FONTS = {};\n  self.IMAGES = {};\n  self.GRAD_COL_FUNCTIONS = {}; // cache for color gradient functions\n  self.GRAD_OPC_FUNCTIONS = {}; // cache for opacity gradient functions\n  self.GRAD_COL = {}; // cache for whole color gradient objects\n  self.GRAD_OPC = {}; // cache for whole opacity gradient objects\n\n  var catalog = self.attach(new PDFCatalog());\n  var pageTree = self.attach(new PDFPageTree());\n  if (getOption(\"autoPrint\")) {\n    var nameTree = {};\n    nameTree.JavaScript = new PDFDictionary({\n      Names: [new PDFString(\"JS\"), self.attach(new PDFDictionary({\n        S: _(\"JavaScript\"),\n        JS: new PDFString(\"print(true);\")\n      }))]\n    });\n    catalog.props.Names = new PDFDictionary(nameTree);\n  }\n  catalog.setPages(pageTree);\n  var info = self.attach(new PDFDictionary({\n    Producer: new PDFString(getOption(\"producer\", \"Kendo UI PDF Generator\"), true),\n    // XXX: kendo.version?\n    Title: new PDFString(getOption(\"title\", \"\"), true),\n    Author: new PDFString(getOption(\"author\", \"\"), true),\n    Subject: new PDFString(getOption(\"subject\", \"\"), true),\n    Keywords: new PDFString(getOption(\"keywords\", \"\"), true),\n    Creator: new PDFString(getOption(\"creator\", \"Kendo UI PDF Generator\"), true),\n    CreationDate: getOption(\"date\", new Date())\n  }));\n  self.addPage = function (options) {\n    var paperOptions = getPaperOptions(function (name, defval) {\n      return options && options[name] != null ? options[name] : defval;\n    });\n    var paperSize = paperOptions.paperSize;\n    var margin = paperOptions.margin;\n    var contentWidth = paperSize[0];\n    var contentHeight = paperSize[1];\n    if (margin) {\n      contentWidth -= margin.left + margin.right;\n      contentHeight -= margin.top + margin.bottom;\n    }\n    var content = new PDFStream(makeOutput(), null, true);\n    var props = {\n      Contents: self.attach(content),\n      Parent: pageTree,\n      MediaBox: [0, 0, paperSize[0], paperSize[1]]\n    };\n    var page = new PDFPage(self, props);\n    page._content = content;\n    pageTree.addPage(self.attach(page));\n\n    // canvas-like coord. system.  (0,0) is upper-left.\n    // text must be vertically mirorred before drawing.\n    page.transform(1, 0, 0, -1, 0, paperSize[1]);\n    if (margin) {\n      page.translate(margin.left, margin.top);\n      // XXX: clip to right/bottom margin.  Make this optional?\n      page.rect(0, 0, contentWidth, contentHeight);\n      page.clip();\n    }\n    self.pages.push(page);\n    return page;\n  };\n  self.render = function () {\n    var i;\n    /// file header\n    out(\"%PDF-1.4\", NL, \"%\\xc2\\xc1\\xda\\xcf\\xce\", NL, NL);\n\n    /// file body\n    for (i = 0; i < objects.length; ++i) {\n      objects[i].renderFull(out);\n      out(NL, NL);\n    }\n\n    /// cross-reference table\n    var xrefOffset = out.offset();\n    out(\"xref\", NL, 0, \" \", objects.length + 1, NL);\n    out(\"0000000000 65535 f \", NL);\n    for (i = 0; i < objects.length; ++i) {\n      out(zeropad(objects[i]._offset, 10), \" 00000 n \", NL);\n    }\n    out(NL);\n\n    /// trailer\n    out(\"trailer\", NL);\n    out(new PDFDictionary({\n      Size: objects.length + 1,\n      Root: catalog,\n      Info: info\n    }), NL, NL);\n\n    /// end\n    out(\"startxref\", NL, xrefOffset, NL);\n    out(\"%%EOF\", NL);\n    return out.stream().offset(0);\n  };\n  self.loadFonts = loadFonts;\n  self.loadImages = loadImages;\n};\nPDFDocument.prototype.getFont = function getFont(url) {\n  var font = this.FONTS[url];\n  if (!font) {\n    font = FONT_CACHE[url];\n    if (!font) {\n      throw new Error(\"Font \" + url + \" has not been loaded\");\n    }\n    if (font === true) {\n      font = this.attach(new PDFStandardFont(url));\n    } else {\n      font = this.attach(new PDFFont(this, font));\n    }\n    this.FONTS[url] = font;\n  }\n  return font;\n};\nPDFDocument.prototype.getImage = function getImage(url) {\n  var img = this.IMAGES[url];\n  if (!img) {\n    img = IMAGE_CACHE[url];\n    if (!img) {\n      throw new Error(\"Image \" + url + \" has not been loaded\");\n    }\n    if (img === \"ERROR\") {\n      return null;\n    }\n    img = this.IMAGES[url] = this.attach(img.asStream(this));\n  }\n  return img;\n};\nPDFDocument.prototype.getOpacityGS = function getOpacityGS(opacity, forStroke) {\n  var id = parseFloat(opacity).toFixed(3);\n  opacity = parseFloat(id);\n  id += forStroke ? \"S\" : \"F\";\n  var cache = this._opacityGSCache || (this._opacityGSCache = {});\n  var gs = cache[id];\n  if (!gs) {\n    var props = {\n      Type: _(\"ExtGState\")\n    };\n    if (forStroke) {\n      props.CA = opacity;\n    } else {\n      props.ca = opacity;\n    }\n    gs = this.attach(new PDFDictionary(props));\n    gs._resourceName = _(\"GS\" + ++RESOURCE_COUNTER);\n    cache[id] = gs;\n  }\n  return gs;\n};\nPDFDocument.prototype.dict = function dict(props) {\n  return new PDFDictionary(props);\n};\nPDFDocument.prototype.name = function name(str) {\n  return _(str);\n};\nPDFDocument.prototype.stream = function stream(props, content) {\n  return new PDFStream(content, props);\n};\n\n/* -----[ utils ]----- */\n\nfunction pad(str, len, ch) {\n  while (str.length < len) {\n    str = ch + str;\n  }\n  return str;\n}\nfunction zeropad(n, len) {\n  return pad(String(n), len, \"0\");\n}\nfunction hasOwnProperty(obj, key) {\n  return Object.prototype.hasOwnProperty.call(obj, key);\n}\nvar isArray = Array.isArray || function (obj) {\n  return obj instanceof Array;\n};\nfunction isDate(obj) {\n  return obj instanceof Date;\n}\nfunction renderArray(a, out) {\n  out(\"[\");\n  if (a.length > 0) {\n    out.withIndent(function () {\n      for (var i = 0; i < a.length; ++i) {\n        if (i > 0 && i % 8 === 0) {\n          out.indent(a[i]);\n        } else {\n          out(\" \", a[i]);\n        }\n      }\n    });\n    //out.indent();\n  }\n\n  out(\" ]\");\n}\nfunction renderDate(date, out) {\n  out(\"(D:\", zeropad(date.getUTCFullYear(), 4), zeropad(date.getUTCMonth() + 1, 2), zeropad(date.getUTCDate(), 2), zeropad(date.getUTCHours(), 2), zeropad(date.getUTCMinutes(), 2), zeropad(date.getUTCSeconds(), 2), \"Z)\");\n}\nfunction mm2pt(mm) {\n  return mm * (72 / 25.4);\n}\nfunction cm2pt(cm) {\n  return mm2pt(cm * 10);\n}\nfunction in2pt(inch) {\n  return inch * 72;\n}\nfunction unitsToPoints(x, def) {\n  if (typeof x == \"number\") {\n    return x;\n  }\n  if (typeof x == \"string\") {\n    var m;\n    m = /^\\s*([0-9.]+)\\s*(mm|cm|in|pt)\\s*$/.exec(x);\n    if (m) {\n      var num = parseFloat(m[1]);\n      if (!isNaN(num)) {\n        if (m[2] == \"pt\") {\n          return num;\n        }\n        return {\n          \"mm\": mm2pt,\n          \"cm\": cm2pt,\n          \"in\": in2pt\n        }[m[2]](num);\n      }\n    }\n  }\n  if (def != null) {\n    return def;\n  }\n  throw new Error(\"Can't parse unit: \" + x);\n}\n\n/* -----[ PDF basic objects ]----- */\n\nvar PDFValue = function PDFValue() {};\nPDFValue.prototype.beforeRender = function beforeRender() {};\nvar PDFString = function (PDFValue) {\n  function PDFString(value, utf16be) {\n    PDFValue.call(this);\n    this.value = value;\n    this.utf16be = Boolean(utf16be);\n  }\n  if (PDFValue) PDFString.__proto__ = PDFValue;\n  PDFString.prototype = Object.create(PDFValue && PDFValue.prototype);\n  PDFString.prototype.constructor = PDFString;\n  PDFString.prototype.render = function render(out) {\n    var txt = this.value;\n    if (this.utf16be) {\n      txt = BOM + encodeUTF16BE(txt);\n      txt = txt.replace(/([\\(\\)\\\\])/g, \"\\\\$1\");\n      out(\"(\", txt, \")\");\n    } else {\n      // out.writeString truncates charcodes to 8 bits and\n      // 0x128 & 0xFF is 40, the code for open paren.\n      // therefore we need to do the chopping here to make\n      // sure we backslash all cases.\n      var data = [40]; // open PDF string '('\n      for (var i = 0; i < txt.length; ++i) {\n        var code = txt.charCodeAt(i) & 0xFF;\n        if (code == 40 || code == 41 || code == 92) {\n          // backslash before (, ) and \\\n          data.push(92);\n        }\n        data.push(code);\n      }\n      data.push(41); // ')' close PDF string\n      out.writeData(data);\n    }\n  };\n  PDFString.prototype.toString = function toString() {\n    return this.value;\n  };\n  return PDFString;\n}(PDFValue);\nvar PDFHexString = function (PDFString) {\n  function PDFHexString(value) {\n    PDFString.call(this, value);\n    this.value = value;\n  }\n  if (PDFString) PDFHexString.__proto__ = PDFString;\n  PDFHexString.prototype = Object.create(PDFString && PDFString.prototype);\n  PDFHexString.prototype.constructor = PDFHexString;\n  PDFHexString.prototype.render = function render(out) {\n    var this$1 = this;\n    out(\"<\");\n    for (var i = 0; i < this.value.length; ++i) {\n      out(zeropad(this$1.value.charCodeAt(i).toString(16), 4));\n    }\n    out(\">\");\n  };\n  return PDFHexString;\n}(PDFString);\n\n/// names\nvar PDFName = function (PDFValue) {\n  function PDFName(name) {\n    PDFValue.call(this);\n    this.name = name;\n  }\n  if (PDFValue) PDFName.__proto__ = PDFValue;\n  PDFName.prototype = Object.create(PDFValue && PDFValue.prototype);\n  PDFName.prototype.constructor = PDFName;\n  PDFName.get = function get(name) {\n    return _(name);\n  };\n  PDFName.prototype.render = function render(out) {\n    out(\"/\" + this.escape());\n  };\n  PDFName.prototype.escape = function escape() {\n    return this.name.replace(/[^\\x21-\\x7E]/g, function (c) {\n      return \"#\" + zeropad(c.charCodeAt(0).toString(16), 2);\n    });\n  };\n  PDFName.prototype.toString = function toString() {\n    return this.name;\n  };\n  return PDFName;\n}(PDFValue);\nvar PDFName_cache = {};\nfunction _(name) {\n  if (hasOwnProperty(PDFName_cache, name)) {\n    return PDFName_cache[name];\n  }\n  return PDFName_cache[name] = new PDFName(name);\n}\n\n/// dictionary\n\nvar PDFDictionary = function (PDFValue) {\n  function PDFDictionary(props) {\n    PDFValue.call(this);\n    this.props = props;\n  }\n  if (PDFValue) PDFDictionary.__proto__ = PDFValue;\n  PDFDictionary.prototype = Object.create(PDFValue && PDFValue.prototype);\n  PDFDictionary.prototype.constructor = PDFDictionary;\n  PDFDictionary.prototype.render = function render(out) {\n    var props = this.props,\n      empty = true;\n    out(\"<<\");\n    out.withIndent(function () {\n      for (var i in props) {\n        if (hasOwnProperty(props, i) && !/^_/.test(i)) {\n          empty = false;\n          out.indent(_(i), \" \", props[i]);\n        }\n      }\n    });\n    if (!empty) {\n      out.indent();\n    }\n    out(\">>\");\n  };\n  return PDFDictionary;\n}(PDFValue);\n\n/// streams\n\nvar PDFStream = function (PDFValue) {\n  function PDFStream(data, props, compress) {\n    PDFValue.call(this);\n    if (typeof data == \"string\") {\n      var tmp = BinaryStream();\n      tmp.write(data);\n      data = tmp;\n    }\n    this.data = data;\n    this.props = props || {};\n    this.compress = compress;\n  }\n  if (PDFValue) PDFStream.__proto__ = PDFValue;\n  PDFStream.prototype = Object.create(PDFValue && PDFValue.prototype);\n  PDFStream.prototype.constructor = PDFStream;\n  PDFStream.prototype.render = function render(out) {\n    var data = this.data.get(),\n      props = this.props;\n    if (this.compress && supportsDeflate()) {\n      if (!props.Filter) {\n        props.Filter = [];\n      } else if (!(props.Filter instanceof Array)) {\n        props.Filter = [props.Filter];\n      }\n      props.Filter.unshift(_(\"FlateDecode\"));\n      data = deflate(data);\n    }\n    props.Length = data.length;\n    out(new PDFDictionary(props), \" stream\", NL);\n    out.writeData(data);\n    out(NL, \"endstream\");\n  };\n  return PDFStream;\n}(PDFValue);\n\n/// catalog\n\nvar PDFCatalog = function (PDFDictionary) {\n  function PDFCatalog() {\n    PDFDictionary.call(this, {\n      Type: _(\"Catalog\")\n    });\n  }\n  if (PDFDictionary) PDFCatalog.__proto__ = PDFDictionary;\n  PDFCatalog.prototype = Object.create(PDFDictionary && PDFDictionary.prototype);\n  PDFCatalog.prototype.constructor = PDFCatalog;\n  PDFCatalog.prototype.setPages = function setPages(pagesObj) {\n    this.props.Pages = pagesObj;\n  };\n  return PDFCatalog;\n}(PDFDictionary);\n\n/// page tree\n\nvar PDFPageTree = function (PDFDictionary) {\n  function PDFPageTree() {\n    PDFDictionary.call(this, {\n      Type: _(\"Pages\"),\n      Kids: [],\n      Count: 0\n    });\n  }\n  if (PDFDictionary) PDFPageTree.__proto__ = PDFDictionary;\n  PDFPageTree.prototype = Object.create(PDFDictionary && PDFDictionary.prototype);\n  PDFPageTree.prototype.constructor = PDFPageTree;\n  PDFPageTree.prototype.addPage = function addPage(pageObj) {\n    this.props.Kids.push(pageObj);\n    this.props.Count++;\n  };\n  return PDFPageTree;\n}(PDFDictionary);\n\n/// images\n\n// JPEG\n\nvar SOF_CODES = [0xc0, 0xc1, 0xc2, 0xc3, 0xc5, 0xc6, 0xc7, 0xc9, 0xca, 0xcb, 0xcd, 0xce, 0xcf];\nvar PDFJpegImage = function PDFJpegImage(data) {\n  // we must determine the correct color space.  we'll parse a bit\n  // of the JPEG stream for this, it's still better than going\n  // through the canvas.\n  // https://github.com/telerik/kendo-ui-core/issues/2845\n  data.offset(0);\n  var width, height, colorSpace, bitsPerComponent;\n  var soi = data.readShort();\n  if (soi != 0xFFD8) {\n    // XXX: do we have some better options here?\n    throw new Error(\"Invalid JPEG image\");\n  }\n  while (!data.eof()) {\n    var ff = data.readByte();\n    if (ff != 0xFF) {\n      throw new Error(\"Invalid JPEG image\");\n    }\n    var marker = data.readByte();\n    var length = data.readShort();\n    if (SOF_CODES.indexOf(marker) >= 0) {\n      // \"start of frame\" marker\n      bitsPerComponent = data.readByte();\n      height = data.readShort();\n      width = data.readShort();\n      colorSpace = data.readByte();\n      break;\n    }\n    data.skip(length - 2);\n  }\n  if (colorSpace == null) {\n    throw new Error(\"Invalid JPEG image\");\n  }\n  var props = {\n    Type: _(\"XObject\"),\n    Subtype: _(\"Image\"),\n    Width: width,\n    Height: height,\n    BitsPerComponent: bitsPerComponent,\n    Filter: _(\"DCTDecode\")\n  };\n  switch (colorSpace) {\n    case 1:\n      props.ColorSpace = _(\"DeviceGray\");\n      break;\n    case 3:\n      props.ColorSpace = _(\"DeviceRGB\");\n      break;\n    case 4:\n      props.ColorSpace = _(\"DeviceCMYK\");\n      props.Decode = [1, 0, 1, 0, 1, 0, 1, 0]; // invert colors\n      break;\n  }\n  this.asStream = function () {\n    data.offset(0);\n    var stream = new PDFStream(data, props);\n    stream._resourceName = _(\"I\" + ++RESOURCE_COUNTER);\n    return stream;\n  };\n};\n\n// PDFRawImage will be used for images with transparency (PNG)\n\nvar PDFRawImage = function PDFRawImage(width, height, rgb, alpha) {\n  this.asStream = function (pdf) {\n    var mask = new PDFStream(alpha, {\n      Type: _(\"XObject\"),\n      Subtype: _(\"Image\"),\n      Width: width,\n      Height: height,\n      BitsPerComponent: 8,\n      ColorSpace: _(\"DeviceGray\")\n    }, true);\n    var stream = new PDFStream(rgb, {\n      Type: _(\"XObject\"),\n      Subtype: _(\"Image\"),\n      Width: width,\n      Height: height,\n      BitsPerComponent: 8,\n      ColorSpace: _(\"DeviceRGB\"),\n      SMask: pdf.attach(mask)\n    }, true);\n    stream._resourceName = _(\"I\" + ++RESOURCE_COUNTER);\n    return stream;\n  };\n};\n\n/// standard fonts\n\nvar PDFStandardFont = function (PDFDictionary) {\n  function PDFStandardFont(name) {\n    PDFDictionary.call(this, {\n      Type: _(\"Font\"),\n      Subtype: _(\"Type1\"),\n      BaseFont: _(name)\n    });\n    this._resourceName = _(\"F\" + ++RESOURCE_COUNTER);\n  }\n  if (PDFDictionary) PDFStandardFont.__proto__ = PDFDictionary;\n  PDFStandardFont.prototype = Object.create(PDFDictionary && PDFDictionary.prototype);\n  PDFStandardFont.prototype.constructor = PDFStandardFont;\n  PDFStandardFont.prototype.encodeText = function encodeText(str) {\n    return new PDFString(String(str));\n  };\n  return PDFStandardFont;\n}(PDFDictionary);\n\n/// TTF fonts\n\nvar PDFFont = function (PDFDictionary) {\n  function PDFFont(pdf, font, props) {\n    PDFDictionary.call(this, {});\n    props = this.props;\n    props.Type = _(\"Font\");\n    props.Subtype = _(\"Type0\");\n    props.Encoding = _(\"Identity-H\");\n    this._pdf = pdf;\n    this._font = font;\n    this._sub = font.makeSubset();\n    this._resourceName = _(\"F\" + ++RESOURCE_COUNTER);\n    var head = font.head;\n    this.name = font.psName;\n    var scale = this.scale = font.scale;\n    this.bbox = [head.xMin * scale, head.yMin * scale, head.xMax * scale, head.yMax * scale];\n    this.italicAngle = font.post.italicAngle;\n    this.ascent = font.ascent * scale;\n    this.descent = font.descent * scale;\n    this.lineGap = font.lineGap * scale;\n    this.capHeight = font.os2.capHeight || this.ascent;\n    this.xHeight = font.os2.xHeight || 0;\n    this.stemV = 0;\n    this.familyClass = (font.os2.familyClass || 0) >> 8;\n    this.isSerif = this.familyClass >= 1 && this.familyClass <= 7;\n    this.isScript = this.familyClass == 10;\n    this.flags = (font.post.isFixedPitch ? 1 : 0) | (this.isSerif ? 1 << 1 : 0) | (this.isScript ? 1 << 3 : 0) | (this.italicAngle !== 0 ? 1 << 6 : 0) | 1 << 5;\n  }\n  if (PDFDictionary) PDFFont.__proto__ = PDFDictionary;\n  PDFFont.prototype = Object.create(PDFDictionary && PDFDictionary.prototype);\n  PDFFont.prototype.constructor = PDFFont;\n  PDFFont.prototype.encodeText = function encodeText(text) {\n    return new PDFHexString(this._sub.encodeText(String(text)));\n  };\n  PDFFont.prototype.getTextWidth = function getTextWidth(fontSize, text) {\n    var this$1 = this;\n    var width = 0,\n      codeMap = this._font.cmap.codeMap;\n    for (var i = 0; i < text.length; ++i) {\n      var glyphId = codeMap[text.charCodeAt(i)];\n      width += this$1._font.widthOfGlyph(glyphId || 0);\n    }\n    return width * fontSize / 1000;\n  };\n  PDFFont.prototype.beforeRender = function beforeRender() {\n    var self = this;\n    var sub = self._sub;\n\n    // write the TTF data\n    var data = sub.render();\n    var fontStream = new PDFStream(BinaryStream(data), {\n      Length1: data.length\n    }, true);\n    var descriptor = self._pdf.attach(new PDFDictionary({\n      Type: _(\"FontDescriptor\"),\n      FontName: _(self._sub.psName),\n      FontBBox: self.bbox,\n      Flags: self.flags,\n      StemV: self.stemV,\n      ItalicAngle: self.italicAngle,\n      Ascent: self.ascent,\n      Descent: self.descent,\n      CapHeight: self.capHeight,\n      XHeight: self.xHeight,\n      FontFile2: self._pdf.attach(fontStream)\n    }));\n    var cmap = sub.ncid2ogid;\n    var firstChar = sub.firstChar;\n    var lastChar = sub.lastChar;\n    var charWidths = [];\n    (function loop(i, chunk) {\n      if (i <= lastChar) {\n        var gid = cmap[i];\n        if (gid == null) {\n          loop(i + 1);\n        } else {\n          if (!chunk) {\n            charWidths.push(i, chunk = []);\n          }\n          chunk.push(self._font.widthOfGlyph(gid));\n          loop(i + 1, chunk);\n        }\n      }\n    })(firstChar);\n\n    // As if two dictionaries weren't enough, we need another\n    // one, the \"descendant font\".  Only that one can be of\n    // Subtype CIDFontType2.  PDF is the X11 of document\n    // formats: portable but full of legacy that nobody cares\n    // about anymore.\n\n    var descendant = new PDFDictionary({\n      Type: _(\"Font\"),\n      Subtype: _(\"CIDFontType2\"),\n      BaseFont: _(self._sub.psName),\n      CIDSystemInfo: new PDFDictionary({\n        Registry: new PDFString(\"Adobe\"),\n        Ordering: new PDFString(\"Identity\"),\n        Supplement: 0\n      }),\n      FontDescriptor: descriptor,\n      FirstChar: firstChar,\n      LastChar: lastChar,\n      DW: Math.round(self._font.widthOfGlyph(0)),\n      W: charWidths,\n      CIDToGIDMap: self._pdf.attach(self._makeCidToGidMap())\n    });\n    var dict = self.props;\n    dict.BaseFont = _(self._sub.psName);\n    dict.DescendantFonts = [self._pdf.attach(descendant)];\n\n    // Compute the ToUnicode map so that apps can extract\n    // meaningful text from the PDF.\n    var unimap = new PDFToUnicodeCmap(firstChar, lastChar, sub.subset);\n    var unimapStream = new PDFStream(makeOutput(), null, true);\n    unimapStream.data(unimap);\n    dict.ToUnicode = self._pdf.attach(unimapStream);\n  };\n  PDFFont.prototype._makeCidToGidMap = function _makeCidToGidMap() {\n    return new PDFStream(BinaryStream(this._sub.cidToGidMap()), null, true);\n  };\n  return PDFFont;\n}(PDFDictionary);\nvar PDFToUnicodeCmap = function (PDFValue) {\n  function PDFToUnicodeCmap(firstChar, lastChar, map) {\n    PDFValue.call(this);\n    this.firstChar = firstChar;\n    this.lastChar = lastChar;\n    this.map = map;\n  }\n  if (PDFValue) PDFToUnicodeCmap.__proto__ = PDFValue;\n  PDFToUnicodeCmap.prototype = Object.create(PDFValue && PDFValue.prototype);\n  PDFToUnicodeCmap.prototype.constructor = PDFToUnicodeCmap;\n  PDFToUnicodeCmap.prototype.render = function render(out) {\n    out.indent(\"/CIDInit /ProcSet findresource begin\");\n    out.indent(\"12 dict begin\");\n    out.indent(\"begincmap\");\n    out.indent(\"/CIDSystemInfo <<\");\n    out.indent(\"  /Registry (Adobe)\");\n    out.indent(\"  /Ordering (UCS)\");\n    out.indent(\"  /Supplement 0\");\n    out.indent(\">> def\");\n    out.indent(\"/CMapName /Adobe-Identity-UCS def\");\n    out.indent(\"/CMapType 2 def\");\n    out.indent(\"1 begincodespacerange\");\n    out.indent(\"  <0000><ffff>\");\n    out.indent(\"endcodespacerange\");\n    var self = this;\n    out.indent(self.lastChar - self.firstChar + 1, \" beginbfchar\");\n    out.withIndent(function () {\n      for (var code = self.firstChar; code <= self.lastChar; ++code) {\n        var unicode = self.map[code];\n        var str = ucs2encode([unicode]);\n        out.indent(\"<\", zeropad(code.toString(16), 4), \">\", \"<\");\n        for (var i = 0; i < str.length; ++i) {\n          out(zeropad(str.charCodeAt(i).toString(16), 4));\n        }\n        out(\">\");\n      }\n    });\n    out.indent(\"endbfchar\");\n    out.indent(\"endcmap\");\n    out.indent(\"CMapName currentdict /CMap defineresource pop\");\n    out.indent(\"end\");\n    out.indent(\"end\");\n  };\n  return PDFToUnicodeCmap;\n}(PDFValue);\n\n/// gradients\n\nfunction makeHash(a) {\n  return a.map(function (x) {\n    return isArray(x) ? makeHash(x) : typeof x == \"number\" ? (Math.round(x * 1000) / 1000).toFixed(3) : x;\n  }).join(\" \");\n}\nfunction cacheColorGradientFunction(pdf, r1, g1, b1, r2, g2, b2) {\n  var hash = makeHash([r1, g1, b1, r2, g2, b2]);\n  var func = pdf.GRAD_COL_FUNCTIONS[hash];\n  if (!func) {\n    func = pdf.GRAD_COL_FUNCTIONS[hash] = pdf.attach(new PDFDictionary({\n      FunctionType: 2,\n      Domain: [0, 1],\n      Range: [0, 1, 0, 1, 0, 1],\n      N: 1,\n      C0: [r1, g1, b1],\n      C1: [r2, g2, b2]\n    }));\n  }\n  return func;\n}\nfunction cacheOpacityGradientFunction(pdf, a1, a2) {\n  var hash = makeHash([a1, a2]);\n  var func = pdf.GRAD_OPC_FUNCTIONS[hash];\n  if (!func) {\n    func = pdf.GRAD_OPC_FUNCTIONS[hash] = pdf.attach(new PDFDictionary({\n      FunctionType: 2,\n      Domain: [0, 1],\n      Range: [0, 1],\n      N: 1,\n      C0: [a1],\n      C1: [a2]\n    }));\n  }\n  return func;\n}\nfunction makeGradientFunctions(pdf, stops) {\n  var hasAlpha = false;\n  var opacities = [];\n  var colors = [];\n  var offsets = [];\n  var encode = [];\n  var i, prev, cur, prevColor, curColor;\n  for (i = 1; i < stops.length; ++i) {\n    prev = stops[i - 1];\n    cur = stops[i];\n    prevColor = prev.color;\n    curColor = cur.color;\n    colors.push(cacheColorGradientFunction(pdf, prevColor.r, prevColor.g, prevColor.b, curColor.r, curColor.g, curColor.b));\n    if (prevColor.a < 1 || curColor.a < 1) {\n      hasAlpha = true;\n    }\n    offsets.push(cur.offset);\n    encode.push(0, 1);\n  }\n  if (hasAlpha) {\n    for (i = 1; i < stops.length; ++i) {\n      prev = stops[i - 1];\n      cur = stops[i];\n      prevColor = prev.color;\n      curColor = cur.color;\n      opacities.push(cacheOpacityGradientFunction(pdf, prevColor.a, curColor.a));\n    }\n  }\n  offsets.pop();\n  return {\n    hasAlpha: hasAlpha,\n    colors: assemble(colors),\n    opacities: hasAlpha ? assemble(opacities) : null\n  };\n  function assemble(funcs) {\n    if (funcs.length == 1) {\n      return funcs[0];\n    }\n    return {\n      FunctionType: 3,\n      Functions: funcs,\n      Domain: [0, 1],\n      Bounds: offsets,\n      Encode: encode\n    };\n  }\n}\nfunction cacheColorGradient(pdf, isRadial, stops, coords, funcs, box) {\n  var shading, hash;\n  // if box is given then we have user-space coordinates, which\n  // means the gradient is designed for a certain position/size\n  // on page.  caching won't do any good.\n  if (!box) {\n    var a = [isRadial].concat(coords);\n    stops.forEach(function (x) {\n      a.push(x.offset, x.color.r, x.color.g, x.color.b);\n    });\n    hash = makeHash(a);\n    shading = pdf.GRAD_COL[hash];\n  }\n  if (!shading) {\n    shading = new PDFDictionary({\n      Type: _(\"Shading\"),\n      ShadingType: isRadial ? 3 : 2,\n      ColorSpace: _(\"DeviceRGB\"),\n      Coords: coords,\n      Domain: [0, 1],\n      Function: funcs,\n      Extend: [true, true]\n    });\n    pdf.attach(shading);\n    shading._resourceName = \"S\" + ++RESOURCE_COUNTER;\n    if (hash) {\n      pdf.GRAD_COL[hash] = shading;\n    }\n  }\n  return shading;\n}\nfunction cacheOpacityGradient(pdf, isRadial, stops, coords, funcs, box) {\n  var opacity, hash;\n  // if box is given then we have user-space coordinates, which\n  // means the gradient is designed for a certain position/size\n  // on page.  caching won't do any good.\n  if (!box) {\n    var a = [isRadial].concat(coords);\n    stops.forEach(function (x) {\n      a.push(x.offset, x.color.a);\n    });\n    hash = makeHash(a);\n    opacity = pdf.GRAD_OPC[hash];\n  }\n  if (!opacity) {\n    opacity = new PDFDictionary({\n      Type: _(\"ExtGState\"),\n      AIS: false,\n      CA: 1,\n      ca: 1,\n      SMask: {\n        Type: _(\"Mask\"),\n        S: _(\"Luminosity\"),\n        G: pdf.attach(new PDFStream(\"/a0 gs /s0 sh\", {\n          Type: _(\"XObject\"),\n          Subtype: _(\"Form\"),\n          FormType: 1,\n          BBox: box ? [box.left, box.top + box.height, box.left + box.width, box.top] : [0, 1, 1, 0],\n          Group: {\n            Type: _(\"Group\"),\n            S: _(\"Transparency\"),\n            CS: _(\"DeviceGray\"),\n            I: true\n          },\n          Resources: {\n            ExtGState: {\n              a0: {\n                CA: 1,\n                ca: 1\n              }\n            },\n            Shading: {\n              s0: {\n                ColorSpace: _(\"DeviceGray\"),\n                Coords: coords,\n                Domain: [0, 1],\n                ShadingType: isRadial ? 3 : 2,\n                Function: funcs,\n                Extend: [true, true]\n              }\n            }\n          }\n        }))\n      }\n    });\n    pdf.attach(opacity);\n    opacity._resourceName = \"O\" + ++RESOURCE_COUNTER;\n    if (hash) {\n      pdf.GRAD_OPC[hash] = opacity;\n    }\n  }\n  return opacity;\n}\nfunction cacheGradient(pdf, gradient, box) {\n  var isRadial = gradient.type == \"radial\";\n  var funcs = makeGradientFunctions(pdf, gradient.stops);\n  var coords = isRadial ? [gradient.start.x, gradient.start.y, gradient.start.r, gradient.end.x, gradient.end.y, gradient.end.r] : [gradient.start.x, gradient.start.y, gradient.end.x, gradient.end.y];\n  var shading = cacheColorGradient(pdf, isRadial, gradient.stops, coords, funcs.colors, gradient.userSpace && box);\n  var opacity = funcs.hasAlpha ? cacheOpacityGradient(pdf, isRadial, gradient.stops, coords, funcs.opacities, gradient.userSpace && box) : null;\n  return {\n    hasAlpha: funcs.hasAlpha,\n    shading: shading,\n    opacity: opacity\n  };\n}\n\n/// page object\n\nvar PDFPage = function (PDFDictionary) {\n  function PDFPage(pdf, props) {\n    PDFDictionary.call(this, props);\n    this._pdf = pdf;\n    this._rcount = 0;\n    this._textMode = false;\n    this._fontResources = {};\n    this._gsResources = {};\n    this._xResources = {};\n    this._patResources = {};\n    this._shResources = {};\n    this._opacity = 1;\n    this._matrix = [1, 0, 0, 1, 0, 0];\n    this._annotations = [];\n    this._font = null;\n    this._fontSize = null;\n    this._contextStack = [];\n    props = this.props;\n    props.Type = _(\"Page\");\n    props.ProcSet = [_(\"PDF\"), _(\"Text\"), _(\"ImageB\"), _(\"ImageC\"), _(\"ImageI\")];\n    props.Resources = new PDFDictionary({\n      Font: new PDFDictionary(this._fontResources),\n      ExtGState: new PDFDictionary(this._gsResources),\n      XObject: new PDFDictionary(this._xResources),\n      Pattern: new PDFDictionary(this._patResources),\n      Shading: new PDFDictionary(this._shResources)\n    });\n    props.Annots = this._annotations;\n  }\n  if (PDFDictionary) PDFPage.__proto__ = PDFDictionary;\n  PDFPage.prototype = Object.create(PDFDictionary && PDFDictionary.prototype);\n  PDFPage.prototype.constructor = PDFPage;\n  PDFPage.prototype._out = function _out() {\n    this._content.data.apply(null, arguments);\n  };\n  PDFPage.prototype.transform = function transform(a, b, c, d, e, f) {\n    if (!isIdentityMatrix(arguments)) {\n      this._matrix = mmul(arguments, this._matrix);\n      this._out(a, \" \", b, \" \", c, \" \", d, \" \", e, \" \", f, \" cm\");\n      // XXX: debug\n      // this._out(\" % current matrix: \", this._matrix);\n      this._out(NL);\n    }\n  };\n  PDFPage.prototype.translate = function translate(dx, dy) {\n    this.transform(1, 0, 0, 1, dx, dy);\n  };\n  PDFPage.prototype.scale = function scale(sx, sy) {\n    this.transform(sx, 0, 0, sy, 0, 0);\n  };\n  PDFPage.prototype.rotate = function rotate(angle) {\n    var cos = Math.cos(angle),\n      sin = Math.sin(angle);\n    this.transform(cos, sin, -sin, cos, 0, 0);\n  };\n  PDFPage.prototype.beginText = function beginText() {\n    this._textMode = true;\n    this._out(\"BT\", NL);\n  };\n  PDFPage.prototype.endText = function endText() {\n    this._textMode = false;\n    this._out(\"ET\", NL);\n  };\n  PDFPage.prototype._requireTextMode = function _requireTextMode() {\n    if (!this._textMode) {\n      throw new Error(\"Text mode required; call page.beginText() first\");\n    }\n  };\n  PDFPage.prototype._requireFont = function _requireFont() {\n    if (!this._font) {\n      throw new Error(\"No font selected; call page.setFont() first\");\n    }\n  };\n  PDFPage.prototype.setFont = function setFont(font, size) {\n    this._requireTextMode();\n    if (font == null) {\n      font = this._font;\n    } else if (!(font instanceof PDFFont)) {\n      font = this._pdf.getFont(font);\n    }\n    if (size == null) {\n      size = this._fontSize;\n    }\n    this._fontResources[font._resourceName] = font;\n    this._font = font;\n    this._fontSize = size;\n    this._out(font._resourceName, \" \", size, \" Tf\", NL);\n  };\n  PDFPage.prototype.setTextLeading = function setTextLeading(size) {\n    this._requireTextMode();\n    this._out(size, \" TL\", NL);\n  };\n  PDFPage.prototype.setTextRenderingMode = function setTextRenderingMode(mode) {\n    this._requireTextMode();\n    this._out(mode, \" Tr\", NL);\n  };\n  PDFPage.prototype.showText = function showText(text, requestedWidth) {\n    this._requireFont();\n    if (text.length > 1 && requestedWidth && this._font instanceof PDFFont) {\n      var outputWidth = this._font.getTextWidth(this._fontSize, text);\n      var scale = requestedWidth / outputWidth * 100;\n      this._out(scale, \" Tz \");\n    }\n    this._out(this._font.encodeText(text), \" Tj\", NL);\n  };\n  PDFPage.prototype.showTextNL = function showTextNL(text) {\n    this._requireFont();\n    this._out(this._font.encodeText(text), \" '\", NL);\n  };\n  PDFPage.prototype.addLink = function addLink(uri, box) {\n    var ll = this._toPage({\n      x: box.left,\n      y: box.bottom\n    });\n    var ur = this._toPage({\n      x: box.right,\n      y: box.top\n    });\n    this._annotations.push(new PDFDictionary({\n      Type: _(\"Annot\"),\n      Subtype: _(\"Link\"),\n      Rect: [ll.x, ll.y, ur.x, ur.y],\n      Border: [0, 0, 0],\n      A: new PDFDictionary({\n        Type: _(\"Action\"),\n        S: _(\"URI\"),\n        URI: new PDFString(uri)\n      })\n    }));\n  };\n  PDFPage.prototype.setStrokeColor = function setStrokeColor(r, g, b) {\n    this._out(r, \" \", g, \" \", b, \" RG\", NL);\n  };\n  PDFPage.prototype.setOpacity = function setOpacity(opacity) {\n    this.setFillOpacity(opacity);\n    this.setStrokeOpacity(opacity);\n    this._opacity *= opacity;\n  };\n  PDFPage.prototype.setStrokeOpacity = function setStrokeOpacity(opacity) {\n    if (opacity < 1) {\n      var gs = this._pdf.getOpacityGS(this._opacity * opacity, true);\n      this._gsResources[gs._resourceName] = gs;\n      this._out(gs._resourceName, \" gs\", NL);\n    }\n  };\n  PDFPage.prototype.setFillColor = function setFillColor(r, g, b) {\n    this._out(r, \" \", g, \" \", b, \" rg\", NL);\n  };\n  PDFPage.prototype.setFillOpacity = function setFillOpacity(opacity) {\n    if (opacity < 1) {\n      var gs = this._pdf.getOpacityGS(this._opacity * opacity, false);\n      this._gsResources[gs._resourceName] = gs;\n      this._out(gs._resourceName, \" gs\", NL);\n    }\n  };\n  PDFPage.prototype.gradient = function gradient(gradient$1, box) {\n    this.save();\n    this.rect(box.left, box.top, box.width, box.height);\n    this.clip();\n    if (!gradient$1.userSpace) {\n      this.transform(box.width, 0, 0, box.height, box.left, box.top);\n    }\n    var g = cacheGradient(this._pdf, gradient$1, box);\n    var sname = g.shading._resourceName,\n      oname;\n    this._shResources[sname] = g.shading;\n    if (g.hasAlpha) {\n      oname = g.opacity._resourceName;\n      this._gsResources[oname] = g.opacity;\n      this._out(\"/\" + oname + \" gs \");\n    }\n    this._out(\"/\" + sname + \" sh\", NL);\n    this.restore();\n  };\n  PDFPage.prototype.setDashPattern = function setDashPattern(dashArray, dashPhase) {\n    this._out(dashArray, \" \", dashPhase, \" d\", NL);\n  };\n  PDFPage.prototype.setLineWidth = function setLineWidth(width) {\n    this._out(width, \" w\", NL);\n  };\n  PDFPage.prototype.setLineCap = function setLineCap(lineCap) {\n    this._out(lineCap, \" J\", NL);\n  };\n  PDFPage.prototype.setLineJoin = function setLineJoin(lineJoin) {\n    this._out(lineJoin, \" j\", NL);\n  };\n  PDFPage.prototype.setMitterLimit = function setMitterLimit(mitterLimit) {\n    this._out(mitterLimit, \" M\", NL);\n  };\n  PDFPage.prototype.save = function save() {\n    this._contextStack.push(this._context());\n    this._out(\"q\", NL);\n  };\n  PDFPage.prototype.restore = function restore() {\n    this._out(\"Q\", NL);\n    this._context(this._contextStack.pop());\n  };\n\n  // paths\n  PDFPage.prototype.moveTo = function moveTo(x, y) {\n    this._out(x, \" \", y, \" m\", NL);\n  };\n  PDFPage.prototype.lineTo = function lineTo(x, y) {\n    this._out(x, \" \", y, \" l\", NL);\n  };\n  PDFPage.prototype.bezier = function bezier(x1, y1, x2, y2, x3, y3) {\n    this._out(x1, \" \", y1, \" \", x2, \" \", y2, \" \", x3, \" \", y3, \" c\", NL);\n  };\n  PDFPage.prototype.bezier1 = function bezier1(x1, y1, x3, y3) {\n    this._out(x1, \" \", y1, \" \", x3, \" \", y3, \" y\", NL);\n  };\n  PDFPage.prototype.bezier2 = function bezier2(x2, y2, x3, y3) {\n    this._out(x2, \" \", y2, \" \", x3, \" \", y3, \" v\", NL);\n  };\n  PDFPage.prototype.close = function close() {\n    this._out(\"h\", NL);\n  };\n  PDFPage.prototype.rect = function rect(x, y, w, h) {\n    this._out(x, \" \", y, \" \", w, \" \", h, \" re\", NL);\n  };\n  PDFPage.prototype.ellipse = function ellipse(x, y, rx, ry) {\n    function _X(v) {\n      return x + v;\n    }\n    function _Y(v) {\n      return y + v;\n    }\n\n    // how to get to the \"magic number\" is explained here:\n    // http://www.whizkidtech.redprince.net/bezier/circle/kappa/\n    var k = 0.5522847498307936;\n    this.moveTo(_X(0), _Y(ry));\n    this.bezier(_X(rx * k), _Y(ry), _X(rx), _Y(ry * k), _X(rx), _Y(0));\n    this.bezier(_X(rx), _Y(-ry * k), _X(rx * k), _Y(-ry), _X(0), _Y(-ry));\n    this.bezier(_X(-rx * k), _Y(-ry), _X(-rx), _Y(-ry * k), _X(-rx), _Y(0));\n    this.bezier(_X(-rx), _Y(ry * k), _X(-rx * k), _Y(ry), _X(0), _Y(ry));\n  };\n  PDFPage.prototype.circle = function circle(x, y, r) {\n    this.ellipse(x, y, r, r);\n  };\n  PDFPage.prototype.stroke = function stroke() {\n    this._out(\"S\", NL);\n  };\n  PDFPage.prototype.nop = function nop() {\n    this._out(\"n\", NL);\n  };\n  PDFPage.prototype.clip = function clip() {\n    this._out(\"W n\", NL);\n  };\n  PDFPage.prototype.clipStroke = function clipStroke() {\n    this._out(\"W S\", NL);\n  };\n  PDFPage.prototype.closeStroke = function closeStroke() {\n    this._out(\"s\", NL);\n  };\n  PDFPage.prototype.fill = function fill() {\n    this._out(\"f\", NL);\n  };\n  PDFPage.prototype.fillStroke = function fillStroke() {\n    this._out(\"B\", NL);\n  };\n  PDFPage.prototype.drawImage = function drawImage(url) {\n    var img = this._pdf.getImage(url);\n    if (img) {\n      // the result can be null for a cross-domain image\n      this._xResources[img._resourceName] = img;\n      this._out(img._resourceName, \" Do\", NL);\n    }\n  };\n  PDFPage.prototype.comment = function comment(txt) {\n    var self = this;\n    txt.split(/\\r?\\n/g).forEach(function (line) {\n      self._out(\"% \", line, NL);\n    });\n  };\n\n  // internal\n  PDFPage.prototype._context = function _context(val) {\n    if (val != null) {\n      this._opacity = val.opacity;\n      this._matrix = val.matrix;\n    } else {\n      return {\n        opacity: this._opacity,\n        matrix: this._matrix\n      };\n    }\n  };\n  PDFPage.prototype._toPage = function _toPage(p) {\n    var m = this._matrix;\n    var a = m[0],\n      b = m[1],\n      c = m[2],\n      d = m[3],\n      e = m[4],\n      f = m[5];\n    return {\n      x: a * p.x + c * p.y + e,\n      y: b * p.x + d * p.y + f\n    };\n  };\n  return PDFPage;\n}(PDFDictionary);\nfunction unquote(str) {\n  return str.replace(/^\\s*(['\"])(.*)\\1\\s*$/, \"$2\");\n}\nfunction parseFontDef(fontdef) {\n  // XXX: this is very crude for now and buggy.  Proper parsing is quite involved.\n  var rx = /^\\s*((normal|italic)\\s+)?((normal|small-caps)\\s+)?((normal|bold|\\d+)\\s+)?(([0-9.]+)(px|pt))(\\/(([0-9.]+)(px|pt)|normal))?\\s+(.*?)\\s*$/i;\n  var m = rx.exec(fontdef);\n  if (!m) {\n    return {\n      fontSize: 12,\n      fontFamily: \"sans-serif\"\n    };\n  }\n  var fontSize = m[8] ? parseInt(m[8], 10) : 12;\n  return {\n    italic: m[2] && m[2].toLowerCase() == \"italic\",\n    variant: m[4],\n    bold: m[6] && /bold|700/i.test(m[6]),\n    fontSize: fontSize,\n    lineHeight: m[12] ? m[12] == \"normal\" ? fontSize : parseInt(m[12], 10) : null,\n    fontFamily: m[14].split(/\\s*,\\s*/g).map(unquote)\n  };\n}\nfunction getFontURL(style) {\n  function mkFamily(name) {\n    if (style.bold) {\n      name += \"|bold\";\n    }\n    if (style.italic) {\n      name += \"|italic\";\n    }\n    return name.toLowerCase();\n  }\n  var fontFamily = style.fontFamily;\n  var name, url;\n  if (fontFamily instanceof Array) {\n    for (var i = 0; i < fontFamily.length; ++i) {\n      name = mkFamily(fontFamily[i]);\n      url = FONT_MAPPINGS[name];\n      if (url) {\n        break;\n      }\n    }\n  } else {\n    url = FONT_MAPPINGS[fontFamily.toLowerCase()];\n  }\n  while (typeof url == \"function\") {\n    url = url();\n  }\n  if (!url) {\n    url = \"Times-Roman\";\n  }\n  return url;\n}\nvar FONT_MAPPINGS = {\n  \"serif\": \"Times-Roman\",\n  \"serif|bold\": \"Times-Bold\",\n  \"serif|italic\": \"Times-Italic\",\n  \"serif|bold|italic\": \"Times-BoldItalic\",\n  \"sans-serif\": \"Helvetica\",\n  \"sans-serif|bold\": \"Helvetica-Bold\",\n  \"sans-serif|italic\": \"Helvetica-Oblique\",\n  \"sans-serif|bold|italic\": \"Helvetica-BoldOblique\",\n  \"monospace\": \"Courier\",\n  \"monospace|bold\": \"Courier-Bold\",\n  \"monospace|italic\": \"Courier-Oblique\",\n  \"monospace|bold|italic\": \"Courier-BoldOblique\",\n  \"zapfdingbats\": \"ZapfDingbats\",\n  \"zapfdingbats|bold\": \"ZapfDingbats\",\n  \"zapfdingbats|italic\": \"ZapfDingbats\",\n  \"zapfdingbats|bold|italic\": \"ZapfDingbats\"\n};\nfunction fontAlias(alias, name) {\n  alias = alias.toLowerCase();\n  FONT_MAPPINGS[alias] = function () {\n    return FONT_MAPPINGS[name];\n  };\n  FONT_MAPPINGS[alias + \"|bold\"] = function () {\n    return FONT_MAPPINGS[name + \"|bold\"];\n  };\n  FONT_MAPPINGS[alias + \"|italic\"] = function () {\n    return FONT_MAPPINGS[name + \"|italic\"];\n  };\n  FONT_MAPPINGS[alias + \"|bold|italic\"] = function () {\n    return FONT_MAPPINGS[name + \"|bold|italic\"];\n  };\n}\n\n// Let's define some common names to an appropriate replacement.\n// These are overridable via pdf.defineFont, should the user want to\n// include the proper versions.\n\nfontAlias(\"Times New Roman\", \"serif\");\nfontAlias(\"Courier New\", \"monospace\");\nfontAlias(\"Arial\", \"sans-serif\");\nfontAlias(\"Helvetica\", \"sans-serif\");\nfontAlias(\"Verdana\", \"sans-serif\");\nfontAlias(\"Tahoma\", \"sans-serif\");\nfontAlias(\"Georgia\", \"sans-serif\");\nfontAlias(\"Monaco\", \"monospace\");\nfontAlias(\"Andale Mono\", \"monospace\");\nfunction defineFont(name, url) {\n  if (arguments.length == 1) {\n    for (var i in name) {\n      if (hasOwnProperty(name, i)) {\n        defineFont(i, name[i]);\n      }\n    }\n  } else {\n    name = name.toLowerCase();\n    FONT_MAPPINGS[name] = url;\n\n    // special handling for DejaVu fonts: if they get defined,\n    // let them also replace the default families, for good\n    // Unicode support out of the box.\n    switch (name) {\n      case \"dejavu sans\":\n        FONT_MAPPINGS[\"sans-serif\"] = url;\n        break;\n      case \"dejavu sans|bold\":\n        FONT_MAPPINGS[\"sans-serif|bold\"] = url;\n        break;\n      case \"dejavu sans|italic\":\n        FONT_MAPPINGS[\"sans-serif|italic\"] = url;\n        break;\n      case \"dejavu sans|bold|italic\":\n        FONT_MAPPINGS[\"sans-serif|bold|italic\"] = url;\n        break;\n      case \"dejavu serif\":\n        FONT_MAPPINGS[\"serif\"] = url;\n        break;\n      case \"dejavu serif|bold\":\n        FONT_MAPPINGS[\"serif|bold\"] = url;\n        break;\n      case \"dejavu serif|italic\":\n        FONT_MAPPINGS[\"serif|italic\"] = url;\n        break;\n      case \"dejavu serif|bold|italic\":\n        FONT_MAPPINGS[\"serif|bold|italic\"] = url;\n        break;\n      case \"dejavu mono\":\n        FONT_MAPPINGS[\"monospace\"] = url;\n        break;\n      case \"dejavu mono|bold\":\n        FONT_MAPPINGS[\"monospace|bold\"] = url;\n        break;\n      case \"dejavu mono|italic\":\n        FONT_MAPPINGS[\"monospace|italic\"] = url;\n        break;\n      case \"dejavu mono|bold|italic\":\n        FONT_MAPPINGS[\"monospace|bold|italic\"] = url;\n        break;\n    }\n  }\n}\nfunction mmul(a, b) {\n  var a1 = a[0],\n    b1 = a[1],\n    c1 = a[2],\n    d1 = a[3],\n    e1 = a[4],\n    f1 = a[5];\n  var a2 = b[0],\n    b2 = b[1],\n    c2 = b[2],\n    d2 = b[3],\n    e2 = b[4],\n    f2 = b[5];\n  return [a1 * a2 + b1 * c2, a1 * b2 + b1 * d2, c1 * a2 + d1 * c2, c1 * b2 + d1 * d2, e1 * a2 + f1 * c2 + e2, e1 * b2 + f1 * d2 + f2];\n}\nfunction isIdentityMatrix(m) {\n  return m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 1 && m[4] === 0 && m[5] === 0;\n}\nvar TEXT_RENDERING_MODE = {\n  fill: 0,\n  stroke: 1,\n  fillAndStroke: 2,\n  invisible: 3,\n  fillAndClip: 4,\n  strokeAndClip: 5,\n  fillStrokeClip: 6,\n  clip: 7\n};\nexport { PDFDocument as Document, BinaryStream, defineFont, parseFontDef, getFontURL, loadFonts, loadImages, getPaperOptions, clearImageCache, TEXT_RENDERING_MODE };","map":null,"metadata":{},"sourceType":"module"}
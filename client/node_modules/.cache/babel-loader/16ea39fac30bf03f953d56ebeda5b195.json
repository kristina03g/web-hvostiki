{"ast":null,"code":"import GeometryElementsArray from './geometry-elements-array';\nimport Element from './element';\nimport { pointsToCurve } from './utils/points-to-curve';\nimport paintable from '../mixins/paintable';\nimport measurable from '../mixins/measurable';\nimport Arc from '../geometry/arc';\nimport Rect from '../geometry/rect';\nimport Segment from '../geometry/segment';\nimport Point from '../geometry/point';\nimport Size from '../geometry/size';\nimport lineIntersectionsCount from '../geometry/math/line-intersections-count';\nimport { defined, last, rad } from '../util';\nimport parsePath from '../parsing/parse-path';\nimport elementsBoundingBox from './utils/elements-bounding-box';\nimport elementsClippedBoundingBox from './utils/elements-clippend-bounding-box';\nimport limitValue from '../util/limit-value';\nvar SPACE = ' ';\nvar printPoints = function printPoints(precision) {\n  return function () {\n    var points = [],\n      len = arguments.length;\n    while (len--) points[len] = arguments[len];\n    return points.map(function (p) {\n      return p.toString(precision);\n    }).join(SPACE);\n    ;\n  };\n};\nvar segmentType = function segmentType(segmentStart, segmentEnd) {\n  return segmentStart.controlOut() && segmentEnd.controlIn() ? 'C' : 'L';\n};\nexport var Path = function (superclass) {\n  function Path(options) {\n    superclass.call(this, options);\n    this.segments = new GeometryElementsArray();\n    this.segments.addObserver(this);\n    if (!defined(this.options.stroke)) {\n      this.stroke('#000');\n      if (!defined(this.options.stroke.lineJoin)) {\n        this.options.set('stroke.lineJoin', 'miter');\n      }\n    }\n  }\n  if (superclass) Path.__proto__ = superclass;\n  Path.prototype = Object.create(superclass && superclass.prototype);\n  Path.prototype.constructor = Path;\n  var prototypeAccessors = {\n    nodeType: {\n      configurable: true\n    }\n  };\n  prototypeAccessors.nodeType.get = function () {\n    return 'Path';\n  };\n  Path.prototype.moveTo = function moveTo(x, y) {\n    this.suspend();\n    this.segments.elements([]);\n    this.resume();\n    this.lineTo(x, y);\n    return this;\n  };\n  Path.prototype.lineTo = function lineTo(x, y) {\n    var point = defined(y) ? new Point(x, y) : x;\n    var segment = new Segment(point);\n    this.segments.push(segment);\n    return this;\n  };\n  Path.prototype.curveTo = function curveTo(controlOut, controlIn, point) {\n    if (this.segments.length > 0) {\n      var lastSegment = last(this.segments);\n      var segment = new Segment(point, controlIn);\n      this.suspend();\n      lastSegment.controlOut(controlOut);\n      this.resume();\n      this.segments.push(segment);\n    }\n    return this;\n  };\n  Path.prototype.arc = function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n    if (this.segments.length > 0) {\n      var lastSegment = last(this.segments);\n      var anchor = lastSegment.anchor();\n      var start = rad(startAngle);\n      var center = new Point(anchor.x - radiusX * Math.cos(start), anchor.y - radiusY * Math.sin(start));\n      var arc = new Arc(center, {\n        startAngle: startAngle,\n        endAngle: endAngle,\n        radiusX: radiusX,\n        radiusY: radiusY,\n        anticlockwise: anticlockwise\n      });\n      this._addArcSegments(arc);\n    }\n    return this;\n  };\n  Path.prototype.arcTo = function arcTo(end, rx, ry, largeArc, swipe, rotation) {\n    if (this.segments.length > 0) {\n      var lastSegment = last(this.segments);\n      var anchor = lastSegment.anchor();\n      var arc = Arc.fromPoints(anchor, Point.create(end), rx, ry, largeArc, swipe, rotation);\n      this._addArcSegments(arc);\n    }\n    return this;\n  };\n  Path.prototype._addArcSegments = function _addArcSegments(arc) {\n    var this$1 = this;\n    this.suspend();\n    var curvePoints = arc.curvePoints();\n    for (var i = 1; i < curvePoints.length; i += 3) {\n      this$1.curveTo(curvePoints[i], curvePoints[i + 1], curvePoints[i + 2]);\n    }\n    this.resume();\n    this.geometryChange();\n  };\n  Path.prototype.close = function close() {\n    this.options.closed = true;\n    this.geometryChange();\n    return this;\n  };\n  Path.prototype.rawBBox = function rawBBox() {\n    return this._bbox();\n  };\n  Path.prototype.toString = function toString(digits) {\n    var output = '';\n    var segments = this.segments;\n    var length = segments.length;\n    if (length > 0) {\n      var parts = [];\n      var print = printPoints(digits);\n      var currentType;\n      for (var i = 1; i < length; i++) {\n        var type = segmentType(segments[i - 1], segments[i]);\n        if (type !== currentType) {\n          currentType = type;\n          parts.push(type);\n        }\n        if (type === 'L') {\n          parts.push(print(segments[i].anchor()));\n        } else {\n          parts.push(print(segments[i - 1].controlOut(), segments[i].controlIn(), segments[i].anchor()));\n        }\n      }\n      output = 'M' + print(segments[0].anchor()) + SPACE + parts.join(SPACE);\n      if (this.options.closed) {\n        output += 'Z';\n      }\n    }\n    return output;\n  };\n  Path.prototype._containsPoint = function _containsPoint(point) {\n    var segments = this.segments;\n    var length = segments.length;\n    var intersectionsCount = 0;\n    var previous, current;\n    for (var idx = 1; idx < length; idx++) {\n      previous = segments[idx - 1];\n      current = segments[idx];\n      intersectionsCount += previous._intersectionsTo(current, point);\n    }\n    if (this.options.closed || !segments[0].anchor().equals(segments[length - 1].anchor())) {\n      intersectionsCount += lineIntersectionsCount(segments[0].anchor(), segments[length - 1].anchor(), point);\n    }\n    return intersectionsCount % 2 !== 0;\n  };\n  Path.prototype._isOnPath = function _isOnPath(point, width) {\n    var segments = this.segments;\n    var length = segments.length;\n    var pathWidth = width || this.options.stroke.width;\n    if (length > 1) {\n      if (segments[0]._isOnPathTo(segments[1], point, pathWidth, 'start')) {\n        return true;\n      }\n      for (var idx = 2; idx <= length - 2; idx++) {\n        if (segments[idx - 1]._isOnPathTo(segments[idx], point, pathWidth)) {\n          return true;\n        }\n      }\n      if (segments[length - 2]._isOnPathTo(segments[length - 1], point, pathWidth, 'end')) {\n        return true;\n      }\n    }\n    return false;\n  };\n  Path.prototype._bbox = function _bbox(matrix) {\n    var segments = this.segments;\n    var length = segments.length;\n    var boundingBox;\n    if (length === 1) {\n      var anchor = segments[0].anchor().transformCopy(matrix);\n      boundingBox = new Rect(anchor, Size.ZERO);\n    } else if (length > 0) {\n      for (var i = 1; i < length; i++) {\n        var segmentBox = segments[i - 1].bboxTo(segments[i], matrix);\n        if (boundingBox) {\n          boundingBox = Rect.union(boundingBox, segmentBox);\n        } else {\n          boundingBox = segmentBox;\n        }\n      }\n    }\n    return boundingBox;\n  };\n  Path.parse = function parse(str, options) {\n    return MultiPath.parse(str, options);\n  };\n  Path.fromRect = function fromRect(rect, options) {\n    var path = new Path(options);\n    var ref = rect.cornerRadius;\n    var rx = ref[0];\n    var ry = ref[1];\n    if (rx === 0 && ry === 0) {\n      path.moveTo(rect.topLeft()).lineTo(rect.topRight()).lineTo(rect.bottomRight()).lineTo(rect.bottomLeft()).close();\n    } else {\n      var origin = rect.origin;\n      var x = origin.x;\n      var y = origin.y;\n      var width = rect.width();\n      var height = rect.height();\n      rx = limitValue(rx, 0, width / 2);\n      ry = limitValue(ry, 0, height / 2);\n      path.moveTo(x + rx, y).lineTo(x + width - rx, y).arcTo([x + width, y + ry], rx, ry, false).lineTo(x + width, y + height - ry).arcTo([x + width - rx, y + height], rx, ry, false).lineTo(x + rx, y + height).arcTo([x, y + height - ry], rx, ry, false).lineTo(x, y + ry).arcTo([x + rx, y], rx, ry, false);\n    }\n    return path;\n  };\n  Path.fromPoints = function fromPoints(points, options) {\n    if (points) {\n      var path = new Path(options);\n      for (var i = 0; i < points.length; i++) {\n        var point = Point.create(points[i]);\n        if (point) {\n          if (i === 0) {\n            path.moveTo(point);\n          } else {\n            path.lineTo(point);\n          }\n        }\n      }\n      return path;\n    }\n  };\n  Path.curveFromPoints = function curveFromPoints(points, options) {\n    if (points) {\n      var segments = pointsToCurve(points);\n      var path = new Path(options);\n      path.segments.push.apply(path.segments, segments);\n      return path;\n    }\n  };\n  Path.fromArc = function fromArc(arc, options) {\n    var path = new Path(options);\n    var startAngle = arc.startAngle;\n    var start = arc.pointAt(startAngle);\n    path.moveTo(start.x, start.y);\n    path.arc(startAngle, arc.endAngle, arc.radiusX, arc.radiusY, arc.anticlockwise);\n    return path;\n  };\n  Object.defineProperties(Path.prototype, prototypeAccessors);\n  return Path;\n}(paintable(measurable(Element)));\nexport var MultiPath = function (superclass) {\n  function MultiPath(options) {\n    superclass.call(this, options);\n    this.paths = new GeometryElementsArray();\n    this.paths.addObserver(this);\n    if (!defined(this.options.stroke)) {\n      this.stroke('#000');\n    }\n  }\n  if (superclass) MultiPath.__proto__ = superclass;\n  MultiPath.prototype = Object.create(superclass && superclass.prototype);\n  MultiPath.prototype.constructor = MultiPath;\n  var prototypeAccessors$1 = {\n    nodeType: {\n      configurable: true\n    }\n  };\n  MultiPath.parse = function parse(str, options) {\n    var instance = new MultiPath(options);\n    return parsePath(instance, str);\n  };\n  MultiPath.prototype.toString = function toString(digits) {\n    var paths = this.paths;\n    var output = '';\n    if (paths.length > 0) {\n      var result = [];\n      for (var i = 0; i < paths.length; i++) {\n        result.push(paths[i].toString(digits));\n      }\n      output = result.join(SPACE);\n    }\n    return output;\n  };\n  prototypeAccessors$1.nodeType.get = function () {\n    return 'MultiPath';\n  };\n  MultiPath.prototype.moveTo = function moveTo(x, y) {\n    var path = new Path();\n    path.moveTo(x, y);\n    this.paths.push(path);\n    return this;\n  };\n  MultiPath.prototype.lineTo = function lineTo(x, y) {\n    if (this.paths.length > 0) {\n      last(this.paths).lineTo(x, y);\n    }\n    return this;\n  };\n  MultiPath.prototype.curveTo = function curveTo(controlOut, controlIn, point) {\n    if (this.paths.length > 0) {\n      last(this.paths).curveTo(controlOut, controlIn, point);\n    }\n    return this;\n  };\n  MultiPath.prototype.arc = function arc(startAngle, endAngle, radiusX, radiusY, anticlockwise) {\n    if (this.paths.length > 0) {\n      last(this.paths).arc(startAngle, endAngle, radiusX, radiusY, anticlockwise);\n    }\n    return this;\n  };\n  MultiPath.prototype.arcTo = function arcTo(end, rx, ry, largeArc, swipe, rotation) {\n    if (this.paths.length > 0) {\n      last(this.paths).arcTo(end, rx, ry, largeArc, swipe, rotation);\n    }\n    return this;\n  };\n  MultiPath.prototype.close = function close() {\n    if (this.paths.length > 0) {\n      last(this.paths).close();\n    }\n    return this;\n  };\n  MultiPath.prototype._bbox = function _bbox(matrix) {\n    return elementsBoundingBox(this.paths, true, matrix);\n  };\n  MultiPath.prototype.rawBBox = function rawBBox() {\n    return elementsBoundingBox(this.paths, false);\n  };\n  MultiPath.prototype._containsPoint = function _containsPoint(point) {\n    var paths = this.paths;\n    for (var idx = 0; idx < paths.length; idx++) {\n      if (paths[idx]._containsPoint(point)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  MultiPath.prototype._isOnPath = function _isOnPath(point) {\n    var paths = this.paths;\n    var width = this.options.stroke.width;\n    for (var idx = 0; idx < paths.length; idx++) {\n      if (paths[idx]._isOnPath(point, width)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  MultiPath.prototype._clippedBBox = function _clippedBBox(transformation) {\n    return elementsClippedBoundingBox(this.paths, this.currentTransform(transformation));\n  };\n  Object.defineProperties(MultiPath.prototype, prototypeAccessors$1);\n  return MultiPath;\n}(paintable(measurable(Element)));","map":null,"metadata":{},"sourceType":"module"}
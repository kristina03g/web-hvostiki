{"ast":null,"code":"import { geometry as g, throttle } from '@progress/kendo-drawing';\nimport { addClass, setDefaultOptions, valueOrDefault, defined, mousewheelDelta, limitValue, deepExtend, elementOffset, isArray, round } from '../common';\nimport { EPSG3857 } from './crs';\nimport { Attribution } from './attribution';\nimport { Navigator } from './navigator';\nimport { ZoomControl } from './zoom';\nimport { Location } from './location';\nimport { Extent } from './extent';\nimport { Tooltip } from './tooltip/tooltip';\nimport { TileLayer } from './layers/tile';\nimport { BubbleLayer } from './layers/bubble';\nimport { ShapeLayer } from './layers/shape';\nimport { MarkerLayer } from './layers/marker';\nimport { removeChildren, setDefaultEvents, proxy, now, on, off, getSupportedFeatures, convertToHtml, renderPos } from './utils';\nimport { Scroller } from './scroller/scroller';\nimport { Observable } from './scroller/observable';\nimport MapService from './../services/map-service';\nimport { CENTER_CHANGE, INIT, ZOOM_CHANGE } from './constants';\nvar math = Math,\n  min = math.min,\n  pow = math.pow,\n  Point = g.Point,\n  MARKER = \"marker\",\n  LOCATION = \"location\",\n  FRICTION = 0.9,\n  FRICTION_MOBILE = 0.93,\n  MOUSEWHEEL = 'wheel',\n  MOUSEWHEEL_THROTTLE = 50,\n  VELOCITY_MULTIPLIER = 5,\n  DEFAULT_ZOOM_RATE = 1;\nvar layersMap = {\n  bubble: BubbleLayer,\n  shape: ShapeLayer,\n  tile: TileLayer\n};\nlayersMap[MARKER] = MarkerLayer;\nvar Map = function (Observable) {\n  function Map(element, options, themeOptions, context) {\n    if (options === void 0) options = {};\n    if (themeOptions === void 0) themeOptions = {};\n    if (context === void 0) context = {};\n    Observable.call(this);\n    this._init(element, options, themeOptions, context);\n  }\n  if (Observable) Map.__proto__ = Observable;\n  Map.prototype = Object.create(Observable && Observable.prototype);\n  Map.prototype.constructor = Map;\n  Map.prototype.destroy = function destroy() {\n    var this$1 = this;\n    this.scroller.destroy();\n    if (this._tooltip) {\n      this._tooltip.destroy();\n    }\n    if (this.navigator) {\n      this.navigator.destroy();\n    }\n    if (this.attribution) {\n      this.attribution.destroy();\n    }\n    if (this.zoomControl) {\n      this.zoomControl.destroy();\n    }\n    if (isArray(this.markers)) {\n      this.markers.forEach(function (markerLayer) {\n        markerLayer.destroy();\n      });\n    } else {\n      this.markers.destroy();\n    }\n    for (var i = 0; i < this.layers.length; i++) {\n      this$1.layers[i].destroy();\n    }\n    off(this.element, MOUSEWHEEL, this._mousewheelHandler);\n    Observable.prototype.destroy.call(this);\n  };\n  Map.prototype._init = function _init(element, options, themeOptions, context) {\n    if (options === void 0) options = {};\n    if (themeOptions === void 0) themeOptions = {};\n    if (context === void 0) context = {};\n    this.support = getSupportedFeatures();\n    this.context = context;\n    this.initObserver(context);\n    this.initServices(context);\n    this._notifyObserver(INIT);\n    this._initOptions(options);\n    this._setEvents(options);\n    this.crs = new EPSG3857();\n    this._initElement(element);\n    this._viewOrigin = this._getOrigin();\n    this._tooltip = this._createTooltip();\n    this._initScroller();\n    this._initMarkers();\n    this._initControls();\n    this._initLayers();\n    this._reset();\n    var mousewheelThrottled = throttle(this._mousewheel.bind(this), MOUSEWHEEL_THROTTLE);\n    this._mousewheelHandler = function (e) {\n      e.preventDefault();\n      mousewheelThrottled(e);\n    };\n    on(this.element, MOUSEWHEEL, this._mousewheelHandler);\n  };\n  Map.prototype._initOptions = function _initOptions(options) {\n    this.options = deepExtend({}, this.options, options);\n  };\n  Map.prototype._initElement = function _initElement(element) {\n    this.element = element;\n    addClass(element, \"k-map\");\n    element.style.position = \"relative\";\n    element.setAttribute(\"data-role\", \"map\");\n    removeChildren(element);\n    var div = convertToHtml(\"<div />\");\n    this.element.appendChild(div);\n  };\n  Map.prototype.initServices = function initServices(context) {\n    if (context === void 0) context = {};\n    this.widgetService = new MapService(this, context);\n  };\n  Map.prototype.initObserver = function initObserver(context) {\n    if (context === void 0) context = {};\n    this.observers = [];\n    this.addObserver(context.observer);\n  };\n  Map.prototype.addObserver = function addObserver(observer) {\n    if (observer) {\n      this.observers.push(observer);\n    }\n  };\n  Map.prototype.removeObserver = function removeObserver(observer) {\n    var index = this.observers.indexOf(observer);\n    if (index >= 0) {\n      this.observers.splice(index, 1);\n    }\n  };\n  Map.prototype.requiresHandlers = function requiresHandlers(eventNames) {\n    var observers = this.observers;\n    for (var idx = 0; idx < observers.length; idx++) {\n      if (observers[idx].requiresHandlers(eventNames)) {\n        return true;\n      }\n    }\n  };\n  Map.prototype.trigger = function trigger(name, args) {\n    if (args === void 0) args = {};\n    args.sender = this;\n    var observers = this.observers;\n    var isDefaultPrevented = false;\n    for (var idx = 0; idx < observers.length; idx++) {\n      if (observers[idx].trigger(name, args)) {\n        isDefaultPrevented = true;\n      }\n    }\n    if (!isDefaultPrevented) {\n      Observable.prototype.trigger.call(this, name, args);\n    }\n    return isDefaultPrevented;\n  };\n  Map.prototype._notifyObserver = function _notifyObserver(name, args) {\n    if (args === void 0) args = {};\n    args.sender = this;\n    var observers = this.observers;\n    var isDefaultPrevented = false;\n    for (var idx = 0; idx < observers.length; idx++) {\n      if (observers[idx].trigger(name, args)) {\n        isDefaultPrevented = true;\n      }\n    }\n    return isDefaultPrevented;\n  };\n  Map.prototype.zoom = function zoom(level) {\n    var options = this.options;\n    var result;\n    if (defined(level)) {\n      var zoomLevel = math.round(limitValue(level, options.minZoom, options.maxZoom));\n      if (options.zoom !== zoomLevel) {\n        options.zoom = zoomLevel;\n        this.widgetService.notify(ZOOM_CHANGE, {\n          zoom: options.zoom\n        });\n        this._reset();\n      }\n      result = this;\n    } else {\n      result = options.zoom;\n    }\n    return result;\n  };\n  Map.prototype.center = function center(center$1) {\n    var result;\n    if (center$1) {\n      var current = Location.create(center$1);\n      var previous = Location.create(this.options.center);\n      if (!current.equals(previous)) {\n        this.options.center = current.toArray();\n        this.widgetService.notify(CENTER_CHANGE, {\n          center: this.options.center\n        });\n        this._reset();\n      }\n      result = this;\n    } else {\n      result = Location.create(this.options.center);\n    }\n    return result;\n  };\n  Map.prototype.extent = function extent(extent$1) {\n    var result;\n    if (extent$1) {\n      this._setExtent(extent$1);\n      result = this;\n    } else {\n      result = this._getExtent();\n    }\n    return result;\n  };\n  Map.prototype.setOptions = function setOptions(options) {\n    if (options === void 0) options = {};\n    var element = this.element;\n    this.destroy();\n    removeChildren(element);\n    this._init(element, options, {}, this.context);\n    this._reset();\n  };\n  Map.prototype.locationToLayer = function locationToLayer(location, zoom) {\n    var clamp = !this.options.wraparound;\n    var locationObject = Location.create(location);\n    return this.crs.toPoint(locationObject, this._layerSize(zoom), clamp);\n  };\n  Map.prototype.layerToLocation = function layerToLocation(point, zoom) {\n    var clamp = !this.options.wraparound;\n    var pointObject = Point.create(point);\n    return this.crs.toLocation(pointObject, this._layerSize(zoom), clamp);\n  };\n  Map.prototype.locationToView = function locationToView(location) {\n    var locationObject = Location.create(location);\n    var origin = this.locationToLayer(this._viewOrigin);\n    var point = this.locationToLayer(locationObject);\n    return point.translateWith(origin.scale(-1));\n  };\n  Map.prototype.viewToLocation = function viewToLocation(point, zoom) {\n    var origin = this.locationToLayer(this._getOrigin(), zoom);\n    var pointObject = Point.create(point);\n    var pointResult = pointObject.clone().translateWith(origin);\n    return this.layerToLocation(pointResult, zoom);\n  };\n  Map.prototype.eventOffset = function eventOffset(e) {\n    var x;\n    var y;\n    var offset = elementOffset(this.element);\n    if (e.x && e.x[LOCATION] || e.y && e.y[LOCATION]) {\n      x = e.x[LOCATION] - offset.left;\n      y = e.y[LOCATION] - offset.top;\n    } else {\n      var event = e.originalEvent || e;\n      x = valueOrDefault(event.pageX, event.clientX) - offset.left;\n      y = valueOrDefault(event.pageY, event.clientY) - offset.top;\n    }\n    var point = new g.Point(x, y);\n    return point;\n  };\n  Map.prototype.eventToView = function eventToView(e) {\n    var cursor = this.eventOffset(e);\n    return this.locationToView(this.viewToLocation(cursor));\n  };\n  Map.prototype.eventToLayer = function eventToLayer(e) {\n    return this.locationToLayer(this.eventToLocation(e));\n  };\n  Map.prototype.eventToLocation = function eventToLocation(e) {\n    var cursor = this.eventOffset(e);\n    return this.viewToLocation(cursor);\n  };\n  Map.prototype.viewSize = function viewSize() {\n    var element = this.element;\n    var scale = this._layerSize();\n    var width = element.clientWidth;\n    if (!this.options.wraparound) {\n      width = min(scale, width);\n    }\n    return {\n      width: width,\n      height: min(scale, element.clientHeight)\n    };\n  };\n  Map.prototype.exportVisual = function exportVisual() {\n    this._reset();\n    return false;\n  };\n  Map.prototype.hideTooltip = function hideTooltip() {\n    if (this._tooltip) {\n      this._tooltip.hide();\n    }\n  };\n  Map.prototype._setOrigin = function _setOrigin(origin, zoom) {\n    var size = this.viewSize(),\n      topLeft;\n    var originLocation = this._origin = Location.create(origin);\n    topLeft = this.locationToLayer(originLocation, zoom);\n    topLeft.x += size.width / 2;\n    topLeft.y += size.height / 2;\n    this.options.center = this.layerToLocation(topLeft, zoom).toArray();\n    this.widgetService.notify(CENTER_CHANGE, {\n      center: this.options.center\n    });\n    return this;\n  };\n  Map.prototype._getOrigin = function _getOrigin(invalidate) {\n    var size = this.viewSize(),\n      topLeft;\n    if (invalidate || !this._origin) {\n      topLeft = this.locationToLayer(this.center());\n      topLeft.x -= size.width / 2;\n      topLeft.y -= size.height / 2;\n      this._origin = this.layerToLocation(topLeft);\n    }\n    return this._origin;\n  };\n  Map.prototype._setExtent = function _setExtent(newExtent) {\n    var this$1 = this;\n    var raw = Extent.create(newExtent);\n    var se = raw.se.clone();\n    if (this.options.wraparound && se.lng < 0 && newExtent.nw.lng > 0) {\n      se.lng = 180 + (180 + se.lng);\n    }\n    var extent = new Extent(raw.nw, se);\n    this.center(extent.center());\n    var width = this.element.clientWidth;\n    var height = this.element.clientHeight;\n    var zoom;\n    for (zoom = this.options.maxZoom; zoom >= this.options.minZoom; zoom--) {\n      var topLeft = this$1.locationToLayer(extent.nw, zoom);\n      var bottomRight = this$1.locationToLayer(extent.se, zoom);\n      var layerWidth = math.abs(bottomRight.x - topLeft.x);\n      var layerHeight = math.abs(bottomRight.y - topLeft.y);\n      if (layerWidth <= width && layerHeight <= height) {\n        break;\n      }\n    }\n    this.zoom(zoom);\n  };\n  Map.prototype._getExtent = function _getExtent() {\n    var nw = this._getOrigin();\n    var bottomRight = this.locationToLayer(nw);\n    var size = this.viewSize();\n    bottomRight.x += size.width;\n    bottomRight.y += size.height;\n    var se = this.layerToLocation(bottomRight);\n    return new Extent(nw, se);\n  };\n  Map.prototype._zoomAround = function _zoomAround(pivot, level) {\n    this._setOrigin(this.layerToLocation(pivot, level), level);\n    this.zoom(level);\n  };\n  Map.prototype._initControls = function _initControls() {\n    var controls = this.options.controls;\n    if (controls.attribution) {\n      this._createAttribution(controls.attribution);\n    }\n    if (!this.support.mobileOS) {\n      if (controls.navigator) {\n        this._createNavigator(controls.navigator);\n      }\n      if (controls.zoom) {\n        this._createZoomControl(controls.zoom);\n      }\n    }\n  };\n  Map.prototype._createControlElement = function _createControlElement(options, defaultPosition) {\n    var pos = options.position || defaultPosition;\n    var posSelector = '.' + renderPos(pos).replace(' ', '.');\n    var wrap = this.element.querySelector('.k-map-controls' + posSelector) || [];\n    if (wrap.length === 0) {\n      var div$1 = document.createElement(\"div\");\n      addClass(div$1, 'k-map-controls ' + renderPos(pos));\n      wrap = div$1;\n      this.element.appendChild(wrap);\n    }\n    var div = document.createElement(\"div\");\n    wrap.appendChild(div);\n    return div;\n  };\n  Map.prototype._createAttribution = function _createAttribution(options) {\n    var element = this._createControlElement(options, 'bottomRight');\n    this.attribution = new Attribution(element, options);\n  };\n  Map.prototype._createNavigator = function _createNavigator(options) {\n    var element = this._createControlElement(options, 'topLeft');\n    var navigator = this.navigator = new Navigator(element, options);\n    this._navigatorPan = this._navigatorPan.bind(this);\n    navigator.bind('pan', this._navigatorPan);\n    this._navigatorCenter = this._navigatorCenter.bind(this);\n    navigator.bind('center', this._navigatorCenter);\n  };\n  Map.prototype._navigatorPan = function _navigatorPan(e) {\n    var scroller = this.scroller;\n    var x = scroller.scrollLeft + e.x;\n    var y = scroller.scrollTop - e.y;\n    var bounds = this._virtualSize;\n    var width = this.element.clientWidth;\n    var height = this.element.clientHeight;\n\n    // TODO: Move limits to scroller\n    x = limitValue(x, bounds.x.min, bounds.x.max - width);\n    y = limitValue(y, bounds.y.min, bounds.y.max - height);\n    this.scroller.one('scroll', proxy(this._scrollEnd, this));\n    this.scroller.scrollTo(-x, -y);\n  };\n  Map.prototype._navigatorCenter = function _navigatorCenter() {\n    this.center(this.options.center);\n  };\n  Map.prototype._createZoomControl = function _createZoomControl(options) {\n    var element = this._createControlElement(options, 'topLeft');\n    var zoomControl = this.zoomControl = new ZoomControl(element, options);\n    this._zoomControlChange = this._zoomControlChange.bind(this);\n    zoomControl.bind('change', this._zoomControlChange);\n  };\n  Map.prototype._zoomControlChange = function _zoomControlChange(e) {\n    if (!this.trigger('zoomStart', {\n      originalEvent: e\n    })) {\n      this.zoom(this.zoom() + e.delta);\n      this.trigger('zoomEnd', {\n        originalEvent: e\n      });\n    }\n  };\n  Map.prototype._initScroller = function _initScroller() {\n    var friction = this.support.mobileOS ? FRICTION_MOBILE : FRICTION;\n    var zoomable = this.options.zoomable !== false;\n    var scroller = this.scroller = new Scroller(this.element.children[0], {\n      friction: friction,\n      velocityMultiplier: VELOCITY_MULTIPLIER,\n      zoom: zoomable,\n      mousewheelScrolling: false,\n      supportDoubleTap: true\n    });\n    scroller.bind('scroll', proxy(this._scroll, this));\n    scroller.bind('scrollEnd', proxy(this._scrollEnd, this));\n    scroller.userEvents.bind('gesturestart', proxy(this._scaleStart, this));\n    scroller.userEvents.bind('gestureend', proxy(this._scale, this));\n    scroller.userEvents.bind('doubleTap', proxy(this._doubleTap, this));\n    scroller.userEvents.bind('tap', proxy(this._tap, this));\n    this.scrollElement = scroller.scrollElement;\n  };\n  Map.prototype._initLayers = function _initLayers() {\n    var this$1 = this;\n    var defs = this.options.layers,\n      layers = this.layers = [];\n    for (var i = 0; i < defs.length; i++) {\n      var options = defs[i];\n      var layer = this$1._createLayer(options);\n      layers.push(layer);\n    }\n  };\n  Map.prototype._createLayer = function _createLayer(options) {\n    var type = options.type || 'shape';\n    var layerDefaults = this.options.layerDefaults[type];\n    var layerOptions = type === MARKER ? deepExtend({}, this.options.markerDefaults, options) : deepExtend({}, layerDefaults, options);\n    var layerConstructor = layersMap[type];\n    var layer = new layerConstructor(this, layerOptions);\n    if (type === MARKER) {\n      this.markers = layer;\n    }\n    return layer;\n  };\n  Map.prototype._createTooltip = function _createTooltip() {\n    return new Tooltip(this.widgetService, this.options.tooltip);\n  };\n\n  /* eslint-disable arrow-body-style */\n  Map.prototype._initMarkers = function _initMarkers() {\n    var markerLayers = (this.options.layers || []).filter(function (x) {\n      return x && x.type === MARKER;\n    });\n    if (markerLayers.length > 0) {\n      // render the markers from options.layers\n      // instead of options.markers\n      return;\n    }\n    this.markers = new MarkerLayer(this, this.options.markerDefaults);\n    this.markers.add(this.options.markers);\n  };\n  /* eslint-enable arrow-body-style */\n\n  Map.prototype._scroll = function _scroll(e) {\n    var origin = this.locationToLayer(this._viewOrigin).round();\n    var movable = e.sender.movable;\n    var offset = new g.Point(movable.x, movable.y).scale(-1).scale(1 / movable.scale);\n    origin.x += offset.x;\n    origin.y += offset.y;\n    this._scrollOffset = offset;\n    this._tooltip.offset = offset;\n    this.hideTooltip();\n    this._setOrigin(this.layerToLocation(origin));\n    this.trigger('pan', {\n      originalEvent: e,\n      origin: this._getOrigin(),\n      center: this.center()\n    });\n  };\n  Map.prototype._scrollEnd = function _scrollEnd(e) {\n    if (!this._scrollOffset || !this._panComplete()) {\n      return;\n    }\n    this._scrollOffset = null;\n    this._panEndTimestamp = now();\n    this.trigger('panEnd', {\n      originalEvent: e,\n      origin: this._getOrigin(),\n      center: this.center()\n    });\n  };\n  Map.prototype._panComplete = function _panComplete() {\n    return now() - (this._panEndTimestamp || 0) > 50;\n  };\n  Map.prototype._scaleStart = function _scaleStart(e) {\n    if (this.trigger('zoomStart', {\n      originalEvent: e\n    })) {\n      var touch = e.touches[1];\n      if (touch) {\n        touch.cancel();\n      }\n    }\n  };\n  Map.prototype._scale = function _scale(e) {\n    var scale = this.scroller.movable.scale;\n    var zoom = this._scaleToZoom(scale);\n    var gestureCenter = new g.Point(e.center.x, e.center.y);\n    var centerLocation = this.viewToLocation(gestureCenter, zoom);\n    var centerPoint = this.locationToLayer(centerLocation, zoom);\n    var originPoint = centerPoint.translate(-gestureCenter.x, -gestureCenter.y);\n    this._zoomAround(originPoint, zoom);\n    this.trigger('zoomEnd', {\n      originalEvent: e\n    });\n  };\n  Map.prototype._scaleToZoom = function _scaleToZoom(scaleDelta) {\n    var scale = this._layerSize() * scaleDelta;\n    var tiles = scale / this.options.minSize;\n    var zoom = math.log(tiles) / math.log(2);\n    return math.round(zoom);\n  };\n  Map.prototype._reset = function _reset() {\n    if (this.attribution) {\n      this.attribution.filter(this.center(), this.zoom());\n    }\n    this._viewOrigin = this._getOrigin(true);\n    this._resetScroller();\n    this.hideTooltip();\n    this.trigger('beforeReset');\n    this.trigger('reset');\n  };\n  Map.prototype._resetScroller = function _resetScroller() {\n    var scroller = this.scroller;\n    var x = scroller.dimensions.x;\n    var y = scroller.dimensions.y;\n    var scale = this._layerSize();\n    var nw = this.extent().nw;\n    var topLeft = this.locationToLayer(nw).round();\n    scroller.movable.round = true;\n    scroller.reset();\n    scroller.userEvents.cancel();\n    var zoom = this.zoom();\n    scroller.dimensions.forcedMinScale = pow(2, this.options.minZoom - zoom);\n    scroller.dimensions.maxScale = pow(2, this.options.maxZoom - zoom);\n    var xBounds = {\n      min: -topLeft.x,\n      max: scale - topLeft.x\n    };\n    var yBounds = {\n      min: -topLeft.y,\n      max: scale - topLeft.y\n    };\n    if (this.options.wraparound) {\n      xBounds.max = 20 * scale;\n      xBounds.min = -xBounds.max;\n    }\n    if (this.options.pannable === false) {\n      var viewSize = this.viewSize();\n      xBounds.min = yBounds.min = 0;\n      xBounds.max = viewSize.width;\n      yBounds.max = viewSize.height;\n    }\n    x.makeVirtual();\n    y.makeVirtual();\n    x.virtualSize(xBounds.min, xBounds.max);\n    y.virtualSize(yBounds.min, yBounds.max);\n    this._virtualSize = {\n      x: xBounds,\n      y: yBounds\n    };\n  };\n\n  // kept for API compatibility, not used\n  Map.prototype._renderLayers = function _renderLayers() {};\n  Map.prototype._layerSize = function _layerSize(zoom) {\n    var newZoom = valueOrDefault(zoom, this.options.zoom);\n    return this.options.minSize * pow(2, newZoom);\n  };\n  Map.prototype._tap = function _tap(e) {\n    if (!this._panComplete()) {\n      return;\n    }\n    var cursor = this.eventOffset(e);\n    this.hideTooltip();\n    this.trigger('click', {\n      originalEvent: e,\n      location: this.viewToLocation(cursor)\n    });\n  };\n  Map.prototype._doubleTap = function _doubleTap(e) {\n    var options = this.options;\n    if (options.zoomable !== false) {\n      if (!this.trigger('zoomStart', {\n        originalEvent: e\n      })) {\n        var toZoom = this.zoom() + DEFAULT_ZOOM_RATE;\n        var cursor = this.eventOffset(e);\n        var location = this.viewToLocation(cursor);\n        var postZoom = this.locationToLayer(location, toZoom);\n        var origin = postZoom.translate(-cursor.x, -cursor.y);\n        this._zoomAround(origin, toZoom);\n        this.trigger('zoomEnd', {\n          originalEvent: e\n        });\n      }\n    }\n  };\n  Map.prototype._mousewheel = function _mousewheel(e) {\n    var delta = mousewheelDelta(e) > 0 ? -1 : 1;\n    var options = this.options;\n    var fromZoom = this.zoom();\n    var toZoom = limitValue(fromZoom + delta, options.minZoom, options.maxZoom);\n    if (options.zoomable !== false && toZoom !== fromZoom) {\n      if (!this.trigger('zoomStart', {\n        originalEvent: e\n      })) {\n        var cursor = this.eventOffset(e);\n        var location = this.viewToLocation(cursor);\n        var postZoom = this.locationToLayer(location, toZoom);\n        var origin = postZoom.translate(-cursor.x, -cursor.y);\n        this._zoomAround(origin, toZoom);\n        this.trigger('zoomEnd', {\n          originalEvent: e\n        });\n      }\n    }\n  };\n  Map.prototype._toDocumentCoordinates = function _toDocumentCoordinates(point) {\n    var offset = elementOffset(this.element);\n    return {\n      left: round(point.x + offset.left),\n      top: round(point.y + offset.top)\n    };\n  };\n  return Map;\n}(Observable);\nsetDefaultOptions(Map, {\n  name: 'Map',\n  controls: {\n    attribution: true,\n    navigator: {\n      panStep: 100\n    },\n    zoom: true\n  },\n  layers: [],\n  layerDefaults: {\n    shape: {\n      style: {\n        fill: {\n          color: '#fff'\n        },\n        stroke: {\n          color: '#aaa',\n          width: 0.5\n        }\n      }\n    },\n    bubble: {\n      style: {\n        fill: {\n          color: '#fff',\n          opacity: 0.5\n        },\n        stroke: {\n          color: '#aaa',\n          width: 0.5\n        }\n      }\n    },\n    marker: {\n      shape: 'pinTarget',\n      tooltip: {\n        position: 'top'\n      }\n    }\n  },\n  center: [0, 0],\n  zoom: 3,\n  minSize: 256,\n  minZoom: 1,\n  maxZoom: 19,\n  markers: [],\n  markerDefaults: {\n    shape: 'pinTarget',\n    tooltip: {\n      position: 'top'\n    }\n  },\n  wraparound: true,\n  // If set to true, GeoJSON layer \"Point\" features will be rendered as markers.\n  // Otherwise, the points will be rendered as circles.\n  // Defaults to `true` for KUI/jQuery, `false` everywhere else.\n  renderPointsAsMarkers: false\n});\nsetDefaultEvents(Map, ['beforeReset', 'click', 'markerActivate', 'markerClick', 'markerCreated',\n// Events for implementing custom tooltips.\n'markerMouseEnter', 'markerMouseLeave', 'pan', 'panEnd', 'reset', 'shapeClick', 'shapeCreated', 'shapeFeatureCreated', 'shapeMouseEnter', 'shapeMouseLeave', 'zoomEnd', 'zoomStart']);\nexport default Map;","map":null,"metadata":{},"sourceType":"module"}
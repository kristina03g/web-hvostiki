{"ast":null,"code":"import Axis from './axis';\nimport AxisLabel from './axis-label';\nimport Box from './box';\nimport createAxisTick from './utils/create-axis-tick';\nimport createAxisGridLine from './utils/create-axis-grid-line';\nimport limitCoordinate from './utils/limit-coordinate';\nimport { DEFAULT_PRECISION, BLACK } from '../common/constants';\nimport { deepExtend, defined, inArray, limitValue, round, setDefaultOptions, valueOrDefault } from '../common';\nvar DEFAULT_MAJOR_UNIT = 10;\nvar MIN_VALUE_RANGE = 1e-6;\nvar LogarithmicAxis = function (Axis) {\n  function LogarithmicAxis(seriesMin, seriesMax, options, chartService) {\n    var axisOptions = deepExtend({\n      majorUnit: DEFAULT_MAJOR_UNIT,\n      min: seriesMin,\n      max: seriesMax\n    }, options);\n    var base = axisOptions.majorUnit;\n    var autoMax = autoAxisMax(seriesMax, base);\n    var autoMin = autoAxisMin(seriesMin, seriesMax, axisOptions);\n    var range = initRange(autoMin, autoMax, axisOptions, options);\n    axisOptions.max = range.max;\n    axisOptions.min = range.min;\n    axisOptions.minorUnit = options.minorUnit || round(base - 1, DEFAULT_PRECISION);\n    Axis.call(this, axisOptions, chartService);\n    this.totalMin = defined(options.min) ? Math.min(autoMin, options.min) : autoMin;\n    this.totalMax = defined(options.max) ? Math.max(autoMax, options.max) : autoMax;\n    this.logMin = round(log(range.min, base), DEFAULT_PRECISION);\n    this.logMax = round(log(range.max, base), DEFAULT_PRECISION);\n    this.seriesMin = seriesMin;\n    this.seriesMax = seriesMax;\n    this.createLabels();\n  }\n  if (Axis) LogarithmicAxis.__proto__ = Axis;\n  LogarithmicAxis.prototype = Object.create(Axis && Axis.prototype);\n  LogarithmicAxis.prototype.constructor = LogarithmicAxis;\n  LogarithmicAxis.prototype.clone = function clone() {\n    return new LogarithmicAxis(this.seriesMin, this.seriesMax, Object.assign({}, this.options), this.chartService);\n  };\n  LogarithmicAxis.prototype.startValue = function startValue() {\n    return this.options.min;\n  };\n  LogarithmicAxis.prototype.getSlot = function getSlot(a, b, limit) {\n    var ref = this;\n    var options = ref.options;\n    var logMin = ref.logMin;\n    var logMax = ref.logMax;\n    var base = options.majorUnit;\n    var min = options.min;\n    var max = options.max;\n    var ref$1 = this.lineInfo();\n    var axis = ref$1.axis;\n    var axisDir = ref$1.axisDir;\n    var lineBox = ref$1.lineBox;\n    var lineSize = ref$1.lineSize;\n    var lineStart = ref$1.lineStart;\n    var step = axisDir * (lineSize / (logMax - logMin));\n    var start = valueOrDefault(a, b || 1);\n    var end = valueOrDefault(b, a || 1);\n    if (start <= 0 || end <= 0) {\n      return null;\n    }\n    if (limit) {\n      start = limitValue(start, min, max);\n      end = limitValue(end, min, max);\n    }\n    start = log(start, base);\n    end = log(end, base);\n    var p1 = Math.min(start, end) - logMin;\n    var p2 = Math.max(start, end) - logMin;\n    var slotBox = new Box(lineBox.x1, lineBox.y1, lineBox.x1, lineBox.y1);\n    slotBox[axis + 1] = limitCoordinate(lineStart + step * (axisDir > 0 ? p1 : p2));\n    slotBox[axis + 2] = limitCoordinate(lineStart + step * (axisDir > 0 ? p2 : p1));\n    return slotBox;\n  };\n  LogarithmicAxis.prototype.getValue = function getValue(point) {\n    var ref = this;\n    var options = ref.options;\n    var logMin = ref.logMin;\n    var logMax = ref.logMax;\n    var base = options.majorUnit;\n    var ref$1 = this.lineInfo();\n    var axis = ref$1.axis;\n    var axisDir = ref$1.axisDir;\n    var lineStart = ref$1.lineStart;\n    var lineSize = ref$1.lineSize;\n    var step = (logMax - logMin) / lineSize;\n    var offset = axisDir * (point[axis] - lineStart);\n    var valueOffset = offset * step;\n    if (offset < 0 || offset > lineSize) {\n      return null;\n    }\n    var value = logMin + valueOffset;\n    return round(Math.pow(base, value), DEFAULT_PRECISION);\n  };\n  LogarithmicAxis.prototype.range = function range() {\n    var options = this.options;\n    return {\n      min: options.min,\n      max: options.max\n    };\n  };\n  LogarithmicAxis.prototype.translateRange = function translateRange(delta) {\n    var ref = this;\n    var options = ref.options;\n    var logMin = ref.logMin;\n    var logMax = ref.logMax;\n    var reverse = options.reverse;\n    var vertical = options.vertical;\n    var base = options.majorUnit;\n    var lineBox = this.lineBox();\n    var size = vertical ? lineBox.height() : lineBox.width();\n    var scale = size / (logMax - logMin);\n    var offset = round(delta / scale, DEFAULT_PRECISION);\n    if ((vertical || reverse) && !(vertical && reverse)) {\n      offset = -offset;\n    }\n    return {\n      min: Math.pow(base, logMin + offset),\n      max: Math.pow(base, logMax + offset),\n      offset: offset\n    };\n  };\n  LogarithmicAxis.prototype.labelsCount = function labelsCount() {\n    var floorMax = Math.floor(this.logMax);\n    var count = Math.floor(floorMax - this.logMin) + 1;\n    return count;\n  };\n  LogarithmicAxis.prototype.getMajorTickPositions = function getMajorTickPositions() {\n    var ticks = [];\n    this.traverseMajorTicksPositions(function (position) {\n      ticks.push(position);\n    }, {\n      step: 1,\n      skip: 0\n    });\n    return ticks;\n  };\n  LogarithmicAxis.prototype.createTicks = function createTicks(lineGroup) {\n    var options = this.options;\n    var majorTicks = options.majorTicks;\n    var minorTicks = options.minorTicks;\n    var vertical = options.vertical;\n    var mirror = options.labels.mirror;\n    var lineBox = this.lineBox();\n    var ticks = [];\n    var tickLineOptions = {\n      // TODO\n      // _alignLines: options._alignLines,\n      vertical: vertical\n    };\n    function render(tickPosition, tickOptions) {\n      tickLineOptions.tickX = mirror ? lineBox.x2 : lineBox.x2 - tickOptions.size;\n      tickLineOptions.tickY = mirror ? lineBox.y1 - tickOptions.size : lineBox.y1;\n      tickLineOptions.position = tickPosition;\n      lineGroup.append(createAxisTick(tickLineOptions, tickOptions));\n    }\n    if (majorTicks.visible) {\n      this.traverseMajorTicksPositions(render, majorTicks);\n    }\n    if (minorTicks.visible) {\n      this.traverseMinorTicksPositions(render, minorTicks);\n    }\n    return ticks;\n  };\n  LogarithmicAxis.prototype.createGridLines = function createGridLines(altAxis) {\n    var options = this.options;\n    var minorGridLines = options.minorGridLines;\n    var majorGridLines = options.majorGridLines;\n    var vertical = options.vertical;\n    var lineBox = altAxis.lineBox();\n    var lineOptions = {\n      lineStart: lineBox[vertical ? \"x1\" : \"y1\"],\n      lineEnd: lineBox[vertical ? \"x2\" : \"y2\"],\n      vertical: vertical\n    };\n    var majorTicks = [];\n    var container = this.gridLinesVisual();\n    function render(tickPosition, gridLine) {\n      if (!inArray(tickPosition, majorTicks)) {\n        lineOptions.position = tickPosition;\n        container.append(createAxisGridLine(lineOptions, gridLine));\n        majorTicks.push(tickPosition);\n      }\n    }\n    if (majorGridLines.visible) {\n      this.traverseMajorTicksPositions(render, majorGridLines);\n    }\n    if (minorGridLines.visible) {\n      this.traverseMinorTicksPositions(render, minorGridLines);\n    }\n    return container.children;\n  };\n  LogarithmicAxis.prototype.traverseMajorTicksPositions = function traverseMajorTicksPositions(callback, tickOptions) {\n    var ref = this.lineInfo();\n    var lineStart = ref.lineStart;\n    var step = ref.step;\n    var ref$1 = this;\n    var logMin = ref$1.logMin;\n    var logMax = ref$1.logMax;\n    for (var power = Math.ceil(logMin) + tickOptions.skip; power <= logMax; power += tickOptions.step) {\n      var position = round(lineStart + step * (power - logMin), DEFAULT_PRECISION);\n      callback(position, tickOptions);\n    }\n  };\n  LogarithmicAxis.prototype.traverseMinorTicksPositions = function traverseMinorTicksPositions(callback, tickOptions) {\n    var this$1 = this;\n    var ref = this.options;\n    var min = ref.min;\n    var max = ref.max;\n    var minorUnit = ref.minorUnit;\n    var base = ref.majorUnit;\n    var ref$1 = this.lineInfo();\n    var lineStart = ref$1.lineStart;\n    var step = ref$1.step;\n    var ref$2 = this;\n    var logMin = ref$2.logMin;\n    var logMax = ref$2.logMax;\n    var start = Math.floor(logMin);\n    for (var power = start; power < logMax; power++) {\n      var minorOptions = this$1._minorIntervalOptions(power);\n      for (var idx = tickOptions.skip; idx < minorUnit; idx += tickOptions.step) {\n        var value = minorOptions.value + idx * minorOptions.minorStep;\n        if (value > max) {\n          break;\n        }\n        if (value >= min) {\n          var position = round(lineStart + step * (log(value, base) - logMin), DEFAULT_PRECISION);\n          callback(position, tickOptions);\n        }\n      }\n    }\n  };\n  LogarithmicAxis.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {\n    var power = Math.ceil(this.logMin + index);\n    var value = Math.pow(this.options.majorUnit, power);\n    var text = this.axisLabelText(value, labelOptions, labelContext);\n    return new AxisLabel(value, text, index, null, labelOptions);\n  };\n  LogarithmicAxis.prototype.shouldRenderNote = function shouldRenderNote(value) {\n    var range = this.range();\n    return range.min <= value && value <= range.max;\n  };\n  LogarithmicAxis.prototype.pan = function pan(delta) {\n    var range = this.translateRange(delta);\n    return this.limitRange(range.min, range.max, this.totalMin, this.totalMax, range.offset);\n  };\n  LogarithmicAxis.prototype.pointsRange = function pointsRange(start, end) {\n    var startValue = this.getValue(start);\n    var endValue = this.getValue(end);\n    var min = Math.min(startValue, endValue);\n    var max = Math.max(startValue, endValue);\n    return {\n      min: min,\n      max: max\n    };\n  };\n  LogarithmicAxis.prototype.scaleRange = function scaleRange(scale, cursor) {\n    var ref = this.options;\n    var base = ref.majorUnit;\n    var logMin = log(this.options.min, base);\n    var logMax = log(this.options.max, base);\n    var position = Math.abs(this.pointOffset(cursor));\n    var range = logMax - logMin;\n    var delta = this.scaleToDelta(scale, range);\n    var min = Math.pow(base, logMin + position * delta);\n    var max = Math.pow(base, logMax - (1 - position) * delta);\n    if (max - min < MIN_VALUE_RANGE) {\n      max = min + MIN_VALUE_RANGE;\n    }\n    return {\n      min: min,\n      max: max\n    };\n  };\n  LogarithmicAxis.prototype.zoomRange = function zoomRange(scale, cursor) {\n    var range = this.scaleRange(scale, cursor);\n    var ref = this;\n    var totalMin = ref.totalMin;\n    var totalMax = ref.totalMax;\n    return {\n      min: limitValue(range.min, totalMin, totalMax),\n      max: limitValue(range.max, totalMin, totalMax)\n    };\n  };\n  LogarithmicAxis.prototype._minorIntervalOptions = function _minorIntervalOptions(power) {\n    var ref = this.options;\n    var minorUnit = ref.minorUnit;\n    var base = ref.majorUnit;\n    var value = Math.pow(base, power);\n    var nextValue = Math.pow(base, power + 1);\n    var difference = nextValue - value;\n    var minorStep = difference / minorUnit;\n    return {\n      value: value,\n      minorStep: minorStep\n    };\n  };\n  LogarithmicAxis.prototype.lineInfo = function lineInfo() {\n    var info = Axis.prototype.lineInfo.call(this);\n    info.step = info.axisDir * (info.lineSize / (this.logMax - this.logMin));\n    return info;\n  };\n  return LogarithmicAxis;\n}(Axis);\nfunction initRange(autoMin, autoMax, axisOptions, options) {\n  var min = axisOptions.min;\n  var max = axisOptions.max;\n  if (defined(axisOptions.axisCrossingValue) && axisOptions.axisCrossingValue <= 0) {\n    throwNegativeValuesError();\n  }\n  if (!defined(options.max)) {\n    max = autoMax;\n  } else if (options.max <= 0) {\n    throwNegativeValuesError();\n  }\n  if (!defined(options.min)) {\n    min = autoMin;\n  } else if (options.min <= 0) {\n    throwNegativeValuesError();\n  }\n  return {\n    min: min,\n    max: max\n  };\n}\nfunction autoAxisMin(min, max, options) {\n  var base = options.majorUnit;\n  var autoMin = min;\n  if (min <= 0) {\n    autoMin = max <= 1 ? Math.pow(base, -2) : 1;\n  } else if (!options.narrowRange) {\n    autoMin = Math.pow(base, Math.floor(log(min, base)));\n  }\n  return autoMin;\n}\nfunction autoAxisMax(max, base) {\n  var logMaxRemainder = round(log(max, base), DEFAULT_PRECISION) % 1;\n  var autoMax;\n  if (max <= 0) {\n    autoMax = base;\n  } else if (logMaxRemainder !== 0 && (logMaxRemainder < 0.3 || logMaxRemainder > 0.9)) {\n    autoMax = Math.pow(base, log(max, base) + 0.2);\n  } else {\n    autoMax = Math.pow(base, Math.ceil(log(max, base)));\n  }\n  return autoMax;\n}\nfunction throwNegativeValuesError() {\n  throw new Error(\"Non positive values cannot be used for a logarithmic axis\");\n}\nfunction log(x, base) {\n  return Math.log(x) / Math.log(base);\n}\nsetDefaultOptions(LogarithmicAxis, {\n  type: \"log\",\n  majorUnit: DEFAULT_MAJOR_UNIT,\n  minorUnit: 1,\n  axisCrossingValue: 1,\n  vertical: true,\n  majorGridLines: {\n    visible: true,\n    width: 1,\n    color: BLACK\n  },\n  zIndex: 1,\n  _deferLabels: true\n});\nexport default LogarithmicAxis;","map":null,"metadata":{},"sourceType":"module"}
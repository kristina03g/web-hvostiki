{"ast":null,"code":"var __extends = this && this.__extends || function () {\n  var _extendStatics = function extendStatics(d, b) {\n    _extendStatics = Object.setPrototypeOf || {\n      __proto__: []\n    } instanceof Array && function (d, b) {\n      d.__proto__ = b;\n    } || function (d, b) {\n      for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p];\n    };\n    return _extendStatics(d, b);\n  };\n  return function (d, b) {\n    if (typeof b !== \"function\" && b !== null) throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\n    _extendStatics(d, b);\n    function __() {\n      this.constructor = d;\n    }\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\n  };\n}();\nvar __rest = this && this.__rest || function (s, e) {\n  var t = {};\n  for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0) t[p] = s[p];\n  if (s != null && typeof Object.getOwnPropertySymbols === \"function\") for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\n    if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i])) t[p[i]] = s[p[i]];\n  }\n  return t;\n};\nimport * as React from 'react';\nimport * as PropTypes from 'prop-types';\nimport { registerForIntl, provideIntlService } from '@progress/kendo-react-intl';\nimport { DomEventsBuilder as ChartDomEventsBuilder, InstanceObserver } from '@progress/kendo-charts';\nimport { canUseDOM } from '@progress/kendo-react-common';\nimport { hasParent } from './utils/main';\nimport { DomEventsBuilder } from './events/dom-events-builder';\nimport { create as createEvent } from './events/chart-event-builder';\nimport { toDomEvent } from './events/dom-event';\nimport { loadTheme } from './theming/theme-service';\nimport createStore from './store/store';\nimport { optionsReducer, themeReducer, observersReducer } from './store/reducer';\nimport { toggle } from './utils/main';\nimport './defaults';\nimport { SeriesTooltip } from './tooltip/Series';\nimport { CrosshairTooltipContainer } from './tooltip/CrosshairContainer';\nimport { ChartContext } from './ChartContext';\nimport { validatePackage } from '@progress/kendo-react-common';\nimport { packageMetadata } from './package-metadata';\n/**\n * @hidden\n */\nvar BaseChart = /** @class */function (_super) {\n  __extends(BaseChart, _super);\n  function BaseChart(props) {\n    var _this = _super.call(this, props) || this;\n    /**\n     * @hidden\n     */\n    _this.chartInstance = null;\n    /**\n     * @hidden\n     */\n    _this.surface = null;\n    _this._element = null;\n    _this.optionsStore = {};\n    _this.optionsUnsubscriber = Function.prototype;\n    _this.themeStore = {};\n    _this.themeUnsubscriber = Function.prototype;\n    _this.observersStore = {};\n    _this.suppressTransitions = false;\n    /* Chart handlers */\n    /**\n     * @hidden\n     */\n    _this.onRender = function (e) {\n      if (_this.chartInstance !== null) {\n        _this.surface = e.sender.surface;\n        _this.trigger('render', e);\n      }\n    };\n    /**\n     * @hidden\n     */\n    _this.onLegendItemClick = function (e) {\n      if (_this.chartInstance !== null) {\n        /**\n         * In \"controlled\" state the user should toggle the series data visibility\n         */\n        if (_this.props.onLegendItemClick) {\n          _this.trigger('legendItemClick', e);\n        } else {\n          var series = _this.optionsStore.getState().series;\n          if (!series) {\n            return;\n          }\n          var payload = {};\n          var seriesIndex = e.seriesIndex,\n            pointIndex = e.pointIndex;\n          var seriesByIndex = series[seriesIndex];\n          if (pointIndex === undefined) {\n            payload = Object.assign({}, seriesByIndex, {\n              visible: toggle(seriesByIndex.visible)\n            });\n          } else {\n            var pv = seriesByIndex.pointVisibility = seriesByIndex.pointVisibility || [];\n            pv[pointIndex] = toggle(pv[pointIndex]);\n            payload = Object.assign({}, seriesByIndex);\n          }\n          _this.optionsStore.dispatch({\n            chartCollectionIdxKey: \"series_\".concat(seriesIndex),\n            payload: payload\n          });\n          _this.suppressTransitions = true;\n        }\n      }\n    };\n    /* Dom event handlers */\n    /**\n     * @hidden\n     */\n    _this.onWindowResize = function () {\n      if (_this.chartInstance !== null) {\n        _this.chartInstance.resize();\n      }\n    };\n    /**\n     * @hidden\n     */\n    _this.onChartMouseLeave = function (e) {\n      var domEvent = toDomEvent(_this, e);\n      var isDefaultPrevented = _this.triggerDomEvent('onMouseLeave', domEvent);\n      if (isDefaultPrevented) {\n        e.preventDefault();\n      } else if (_this.chartInstance !== null) {\n        _this.chartInstance.hideElements();\n      }\n    };\n    /**\n     * @hidden\n     */\n    _this.onChildMouseLeave = function (e) {\n      var syntheticEvent = e.syntheticEvent;\n      if (_this.chartInstance && !hasParent(syntheticEvent.relatedTarget, _this.element)) {\n        _this.chartInstance.hideElements();\n      }\n      return false;\n    };\n    validatePackage(packageMetadata);\n    _this.optionsStore = createStore(optionsReducer);\n    _this.observersStore = createStore(observersReducer);\n    _this.childrenObserver = new InstanceObserver(_this, {\n      onMouseLeave: 'onChildMouseLeave'\n    });\n    _this.contextValue = {\n      optionsStore: _this.optionsStore,\n      observersStore: _this.observersStore,\n      childrenObserver: _this.childrenObserver\n    };\n    _this.themeStore = createStore(themeReducer);\n    _this.chartObserver = new InstanceObserver(_this, {\n      render: 'onRender',\n      legendItemClick: 'onLegendItemClick'\n    });\n    return _this;\n  }\n  Object.defineProperty(BaseChart.prototype, \"element\", {\n    /**\n     * @hidden\n     */\n    get: function get() {\n      return this._element;\n    },\n    enumerable: false,\n    configurable: true\n  });\n  /**\n   * @hidden\n   */\n  BaseChart.prototype.componentDidMount = function () {\n    var _a;\n    var doc = ((_a = this._element) === null || _a === void 0 ? void 0 : _a.ownerDocument) || document;\n    loadTheme(this.themeStore, this.instantiateCoreChart.bind(this), doc);\n    this.optionsUnsubscriber = this.optionsStore.subscribe(this.refresh.bind(this));\n    this.themeUnsubscriber = this.themeStore.subscribe(this.refresh.bind(this));\n    window.addEventListener('resize', this.onWindowResize);\n  };\n  /**\n   * @hidden\n   */\n  BaseChart.prototype.componentWillUnmount = function () {\n    this.optionsUnsubscriber();\n    this.themeUnsubscriber();\n    if (this.chartInstance !== null) {\n      this.chartInstance.destroy();\n      this.chartInstance = null;\n    }\n    window.removeEventListener('resize', this.onWindowResize);\n  };\n  /**\n   * @hidden\n   */\n  BaseChart.prototype.componentDidUpdate = function (prevProps) {\n    var _a = this.props,\n      dir = _a.dir,\n      children = _a.children,\n      spreadProps = __rest(_a, [\"dir\", \"children\"]);\n    if (this.chartInstance !== null) {\n      var currentIntlService = provideIntlService(this);\n      var chartService = this.chartInstance.chartService;\n      var localeChanged = currentIntlService.locale !== chartService._intlService.locale;\n      var shouldUpdate = Object.entries(prevProps).filter(function (keyValue) {\n        return keyValue[0] !== 'dir' && keyValue[0] !== 'children';\n      }).some(function (keyValue) {\n        var key = keyValue[0],\n          value = keyValue[1];\n        return !(spreadProps.hasOwnProperty(key) && spreadProps[key] === value);\n      });\n      if (localeChanged) {\n        this.chartInstance.chartService._intlService = currentIntlService;\n        this.chartInstance.chartService.format._intlService = currentIntlService;\n        if (!shouldUpdate) {\n          this.chartInstance.noTransitionsRedraw();\n        }\n      }\n      if (shouldUpdate) {\n        this.refresh();\n      }\n      if (prevProps.dir !== dir) {\n        this.chartInstance.setDirection(this.getDirection(dir));\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n  BaseChart.prototype.render = function () {\n    var _this = this;\n    var _a = this.props,\n      _b = _a.style,\n      style = _b === void 0 ? {} : _b,\n      className = _a.className,\n      wrapper = _a.wrapper,\n      children = _a.children;\n    var chartStyles = Object.assign({}, style, {\n      position: 'relative'\n    });\n    var content = React.createElement(wrapper, {\n      className: className,\n      style: chartStyles,\n      key: 'chartElement'\n    }, React.createElement(\"div\", {\n      onMouseLeave: this.onChartMouseLeave,\n      ref: function ref(el) {\n        return _this._element = el;\n      },\n      className: \"k-chart-surface\"\n    }, children));\n    return React.createElement(ChartContext.Provider, {\n      value: this.contextValue\n    }, React.createElement(SeriesTooltip, {\n      key: \"seriesTooltip\"\n    }), React.createElement(CrosshairTooltipContainer, {\n      key: \"crosshairTooltips\"\n    }), content);\n  };\n  /**\n   * @hidden\n   */\n  BaseChart.prototype.getDirection = function (dir) {\n    var _this = this;\n    var directionFromWindow = function directionFromWindow() {\n      return canUseDOM && window.getComputedStyle(_this.element).direction;\n    };\n    var direction = dir !== undefined ? dir : directionFromWindow() || 'ltr';\n    return direction === 'rtl';\n  };\n  /**\n   * @hidden\n   */\n  BaseChart.prototype.getChartOptions = function () {\n    var _a = this.props,\n      renderAs = _a.renderAs,\n      pannable = _a.pannable,\n      zoomable = _a.zoomable,\n      paneDefaults = _a.paneDefaults,\n      panes = _a.panes,\n      transitions = _a.transitions,\n      seriesColors = _a.seriesColors,\n      seriesDefaults = _a.seriesDefaults,\n      axisDefaults = _a.axisDefaults,\n      deriveOptionsFromParent = _a.deriveOptionsFromParent;\n    var chartOptions = {};\n    // undefined clears chart defaults which leads to several issues\n    if (renderAs !== undefined) {\n      chartOptions.renderAs = renderAs;\n    }\n    if (pannable !== undefined) {\n      chartOptions.pannable = pannable;\n    }\n    if (zoomable !== undefined) {\n      chartOptions.zoomable = zoomable;\n    }\n    if (paneDefaults !== undefined) {\n      chartOptions.paneDefaults = paneDefaults;\n    }\n    if (panes !== undefined) {\n      chartOptions.panes = panes;\n    }\n    if (transitions !== undefined) {\n      chartOptions.transitions = transitions;\n    }\n    if (seriesColors !== undefined) {\n      chartOptions.seriesColors = seriesColors;\n    }\n    if (seriesDefaults !== undefined) {\n      chartOptions.seriesDefaults = seriesDefaults;\n    }\n    if (axisDefaults !== undefined) {\n      chartOptions.axisDefaults = axisDefaults;\n    }\n    chartOptions = Object.assign(chartOptions, this.optionsStore.getState());\n    if (deriveOptionsFromParent) {\n      chartOptions = deriveOptionsFromParent(chartOptions);\n    }\n    return chartOptions;\n  };\n  /**\n   * @hidden\n   */\n  BaseChart.prototype.refresh = function () {\n    if (this.chartInstance !== null) {\n      var themeOptions = this.themeStore.getState();\n      var chartOptions = this.getChartOptions();\n      var transitions = chartOptions.transitions;\n      if (this.suppressTransitions) {\n        chartOptions.transitions = false;\n      }\n      if (this.props.onRefresh) {\n        this.props.onRefresh.call(undefined, chartOptions, themeOptions, this.chartInstance);\n      } else {\n        this.chartInstance.setOptions(chartOptions, themeOptions);\n      }\n      if (this.suppressTransitions) {\n        chartOptions.transitions = transitions;\n        this.suppressTransitions = false;\n      }\n    }\n  };\n  /**\n   * @hidden\n   */\n  BaseChart.prototype.instantiateCoreChart = function () {\n    var _a = this.props,\n      dir = _a.dir,\n      chartConstructor = _a.chartConstructor;\n    var chartOptions = this.getChartOptions();\n    this.chartInstance = new chartConstructor(this.element, chartOptions, this.themeStore.getState(), {\n      rtl: this.getDirection(dir),\n      intlService: provideIntlService(this),\n      observer: this.chartObserver,\n      sender: this\n    });\n  };\n  /* Triggers public dom event handlers */\n  /**\n   * @hidden\n   */\n  BaseChart.prototype.trigger = function (name, e) {\n    var target = this.props.getTarget();\n    var eventObject = createEvent(name, e, target);\n    var handler = 'on' + name.charAt(0).toUpperCase() + name.slice(1);\n    var observers = this.observersStore.getState();\n    var isDefaultPrevented = false;\n    for (var idx = 0; idx < observers.length; idx++) {\n      if (observers[idx].trigger(name, e)) {\n        isDefaultPrevented = true;\n      }\n    }\n    /* We have not prevented the event internally, now pass it to the user */\n    if (isDefaultPrevented === false && eventObject && this.props.hasOwnProperty(handler)) {\n      this.props[handler].call(undefined, eventObject);\n      return eventObject.isDefaultPrevented && eventObject.isDefaultPrevented();\n    }\n    return isDefaultPrevented;\n  };\n  /* Used by (event)InstanceObserver to check the wrapper for supported events */\n  /**\n   * @hidden\n   */\n  BaseChart.prototype.requiresHandlers = function (names) {\n    for (var idx = 0; idx < names.length; idx++) {\n      var name_1 = names[idx];\n      var handler = 'on' + name_1.charAt(0).toUpperCase() + name_1.slice(1);\n      if (this.props.hasOwnProperty(handler)) {\n        return true;\n      }\n    }\n    return false;\n  };\n  /* Triggers private dom event handlers */\n  /**\n   * @hidden\n   */\n  BaseChart.prototype.triggerDomEvent = function (name, e) {\n    var observers = this.observersStore.getState();\n    var isDefaultPrevented = false;\n    for (var idx = 0; idx < observers.length; idx++) {\n      if (observers[idx].trigger(name, e)) {\n        isDefaultPrevented = true;\n      }\n    }\n    return isDefaultPrevented;\n  };\n  /**\n   * @hidden\n   */\n  BaseChart.propTypes = {\n    dir: PropTypes.string,\n    renderAs: PropTypes.oneOf(['svg', 'canvas'])\n  };\n  /**\n   * @hidden\n   */\n  BaseChart.defaultProps = {\n    renderAs: 'svg'\n  };\n  return BaseChart;\n}(React.Component);\nexport { BaseChart };\nregisterForIntl(BaseChart);\nChartDomEventsBuilder.register(DomEventsBuilder);","map":null,"metadata":{},"sourceType":"module"}
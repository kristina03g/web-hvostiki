{"ast":null,"code":"import { intersect } from \"./algorithms\";\nimport { getWindow, autoScrollVelocity, scrollableViewPort, getScrollableParent, isPointerInsideContainer, getDocument } from \"./utils\";\n/** @hidden */\nexport var DRAG_AND_DROP_DISPATCH_ACTION;\n(function (DRAG_AND_DROP_DISPATCH_ACTION) {\n  DRAG_AND_DROP_DISPATCH_ACTION[\"POINTER_DOWN\"] = \"pointerdown\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"POINTER_MOVE\"] = \"pointermove\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"POINTER_UP\"] = \"pointerup\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"POINTER_CANCEL\"] = \"pointercancel\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"MOUSE_DOWN\"] = \"mousedown\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"MOUSE_MOVE\"] = \"mousemove\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"MOUSE_UP\"] = \"mouseup\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"CONTEXT_MENU\"] = \"contextmenu\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"TOUCH_START\"] = \"touchstart\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"TOUCH_MOVE\"] = \"touchmove\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"TOUCH_END\"] = \"touchend\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"TOUCH_CANCEL\"] = \"touchcancel\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"SCROLL\"] = \"scroll\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"START\"] = \"KENDO_DRAG_AND_DROP_START\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"MOVE\"] = \"KENDO_DRAG_AND_DROP_MOVE\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"END\"] = \"KENDO_DRAG_AND_DROP_END\";\n  DRAG_AND_DROP_DISPATCH_ACTION[\"CANCEL\"] = \"KENDO_DRAG_AND_DROP_CANCEL\";\n})(DRAG_AND_DROP_DISPATCH_ACTION || (DRAG_AND_DROP_DISPATCH_ACTION = {}));\nvar isTouchEvent = function isTouchEvent(event) {\n  return /^touch/.test(event.type);\n};\nvar isScrollEvent = function isScrollEvent(event) {\n  return /^(scroll)/.test(event.type);\n};\n/** @hidden */\nexport var normalizeEvent = function normalizeEvent(event, state) {\n  return isTouchEvent(event) ? {\n    pageX: event.changedTouches[0].pageX,\n    pageY: event.changedTouches[0].pageY,\n    clientX: event.changedTouches[0].clientX,\n    clientY: event.changedTouches[0].clientY,\n    scrollX: state.scrollOffset.x,\n    scrollY: state.scrollOffset.y,\n    offsetX: state.offset.x,\n    offsetY: state.offset.y,\n    type: event.type,\n    originalEvent: event,\n    isTouch: true,\n    altKey: false,\n    ctrlKey: false,\n    shiftKey: false,\n    metaKey: false\n  } : isScrollEvent(event) ? {\n    pageX: state.pageOffset.x,\n    pageY: state.pageOffset.y,\n    clientX: state.clientOffset.x,\n    clientY: state.clientOffset.y,\n    scrollX: state.scrollOffset.x,\n    scrollY: state.scrollOffset.y,\n    offsetX: state.offset.x,\n    offsetY: state.offset.y,\n    type: event.type,\n    originalEvent: event,\n    altKey: false,\n    ctrlKey: false,\n    shiftKey: false,\n    metaKey: false\n  } : {\n    pageX: event.pageX,\n    pageY: event.pageY,\n    clientX: event.clientX,\n    clientY: event.clientY,\n    offsetX: event.offsetX,\n    offsetY: event.offsetY,\n    scrollX: state.scrollOffset.x,\n    scrollY: state.scrollOffset.y,\n    type: event.type,\n    ctrlKey: event.ctrlKey,\n    shiftKey: event.shiftKey,\n    altKey: event.altKey,\n    metaKey: event.metaKey,\n    originalEvent: event\n  };\n};\nvar noop = function noop() {};\n/** @hidden */\nexport var dispatchDragAndDrop = function dispatchDragAndDrop(state, action, callbacks) {\n  if (callbacks === void 0) {\n    callbacks = {};\n  }\n  var _a = callbacks.onIsPressedChange,\n    onIsPressedChange = _a === void 0 ? noop : _a,\n    _b = callbacks.onIsScrollingChange,\n    onIsScrollingChange = _b === void 0 ? noop : _b,\n    _c = callbacks.onVelocityChange,\n    onVelocityChange = _c === void 0 ? noop : _c,\n    _d = callbacks.onOffsetChange,\n    onOffsetChange = _d === void 0 ? noop : _d,\n    _e = callbacks.onPageOffsetChange,\n    onPageOffsetChange = _e === void 0 ? noop : _e,\n    _f = callbacks.onClientOffsetChange,\n    onClientOffsetChange = _f === void 0 ? noop : _f,\n    _g = callbacks.onScrollOffsetChange,\n    onScrollOffsetChange = _g === void 0 ? noop : _g,\n    _h = callbacks.onInitialScrollOffsetChange,\n    onInitialScrollOffsetChange = _h === void 0 ? noop : _h;\n  var drag = action.payload;\n  var element = drag.element;\n  var hint = drag.hint;\n  var autoScrollDirection = state.autoScrollDirection;\n  var overrideScrollableParent = state.scrollableParent;\n  var event = normalizeEvent(action.event, state);\n  switch (event.type) {\n    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_DOWN && (!event.originalEvent.isPrimary || event.originalEvent.button !== 0)) {\n        break;\n      }\n    // In rare cases where the `which` attribute is available in the mouse event\n    // we check if the `left button` is explicitly clicked:\n    // https://developer.mozilla.org/en-US/docs/Web/API/UIEvent/which#return_value\n    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_DOWN && event.originalEvent.which && event.originalEvent.which > 1 || state.ignoreMouse) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_START && event.originalEvent.touches.length !== 1) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.START:\n      {\n        var scrollableParent_1 = overrideScrollableParent || getScrollableParent(action.payload.element);\n        onInitialScrollOffsetChange(scrollableParent_1 instanceof Window ? {\n          x: scrollableParent_1.scrollX,\n          y: scrollableParent_1.scrollY\n        } : {\n          x: scrollableParent_1.scrollLeft,\n          y: scrollableParent_1.scrollTop\n        });\n        onClientOffsetChange({\n          x: event.clientX,\n          y: event.clientY\n        });\n        onPageOffsetChange({\n          x: event.pageX,\n          y: event.pageY\n        });\n        onOffsetChange({\n          x: event.offsetX,\n          y: event.offsetY\n        });\n        onIsPressedChange(true);\n        if (drag.onPress) {\n          drag.onPress(event);\n        }\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.SCROLL:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.SCROLL && !state.pressed) {\n        break;\n      }\n      var scrollableParent = overrideScrollableParent || getScrollableParent(element);\n      var scrollOffset = scrollableParent instanceof Window ? {\n        x: scrollableParent.scrollX,\n        y: scrollableParent.scrollY\n      } : {\n        x: scrollableParent.scrollLeft,\n        y: scrollableParent.scrollTop\n      };\n      event.scrollX = scrollOffset.x - state.initialScrollOffset.x;\n      event.scrollY = scrollOffset.y - state.initialScrollOffset.y;\n      onScrollOffsetChange({\n        x: event.scrollX,\n        y: event.scrollY\n      });\n    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_MOVE && !event.originalEvent.isPrimary) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_MOVE:\n    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_MOVE && event.originalEvent.touches.length !== 1) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.MOVE:\n      {\n        if (state.pressed) {\n          if (state.autoScroll && event.originalEvent.type !== 'scroll') {\n            if (element) {\n              var document_1 = getDocument(element);\n              var scrollableParent_2 = overrideScrollableParent || getScrollableParent(document_1.elementFromPoint(event.clientX, event.clientY));\n              var newVelocity = autoScrollVelocity(event.clientX, event.clientY, scrollableViewPort(scrollableParent_2, getWindow(element)));\n              onVelocityChange({\n                x: autoScrollDirection && autoScrollDirection.horizontal === false ? 0 : newVelocity.x,\n                y: autoScrollDirection && autoScrollDirection.vertical === false ? 0 : newVelocity.y\n              });\n              onIsScrollingChange(newVelocity.y !== 0 || newVelocity.x !== 0);\n            }\n          }\n          if (!state.drag && drag.onDragStart) {\n            drag.onDragStart(event);\n          }\n          if (drag.onDrag) {\n            drag.onDrag(event);\n          }\n          var dropElement_1 = intersect(hint || element, state.drops.map(function (drop) {\n            return drop && drop.element;\n          }).filter(function (d) {\n            return d !== (hint || element);\n          }));\n          var drop = state.drops.find(function (drop) {\n            return drop.element === dropElement_1;\n          });\n          if (drop && dropElement_1 && isPointerInsideContainer(event.clientX, event.clientY, overrideScrollableParent || getScrollableParent(dropElement_1)) && dropElement_1 !== element) {\n            if ((state.drop && state.drop.element) !== dropElement_1) {\n              if (state.drop && state.drop.onDragLeave) {\n                state.drop.onDragLeave(event);\n              }\n              if (drop.onDragEnter) {\n                drop.onDragEnter(event);\n              }\n            } else {\n              if (drop.onDragOver) {\n                drop.onDragOver(event);\n              }\n            }\n          } else if (state.drop && state.drop.onDragLeave) {\n            state.drop.onDragLeave(event);\n          }\n        }\n        onClientOffsetChange({\n          x: event.clientX,\n          y: event.clientY\n        });\n        onPageOffsetChange({\n          x: event.pageX,\n          y: event.pageY\n        });\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.POINTER_UP && !event.originalEvent.isPrimary) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.MOUSE_UP:\n    // the last finger has been lifted, and the user is not doing gesture.\n    // there might be a better way to handle this.\n    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END:\n      if (event.type === DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_END && event.originalEvent.touches.length !== 1) {\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.END:\n      {\n        onIsPressedChange(false);\n        onIsScrollingChange(false);\n        onScrollOffsetChange({\n          x: 0,\n          y: 0\n        });\n        if (drag.onRelease) {\n          drag.onRelease(event);\n        }\n        if (state.drop && state.drop.onDrop) {\n          state.drop.onDrop(event);\n        }\n        if (state.drag && drag.onDragEnd) {\n          drag.onDragEnd(event);\n        }\n        break;\n      }\n    case DRAG_AND_DROP_DISPATCH_ACTION.POINTER_CANCEL:\n    case DRAG_AND_DROP_DISPATCH_ACTION.CONTEXT_MENU:\n    case DRAG_AND_DROP_DISPATCH_ACTION.TOUCH_CANCEL:\n    case DRAG_AND_DROP_DISPATCH_ACTION.CANCEL:\n      {\n        onIsPressedChange(false);\n        onIsScrollingChange(false);\n        onScrollOffsetChange({\n          x: 0,\n          y: 0\n        });\n        if (drag.onDragEnd) {\n          drag.onDragEnd(event);\n        }\n        if (state.drop && state.drop.onDragLeave) {\n          state.drop.onDragLeave(event);\n        }\n        break;\n      }\n    default:\n      break;\n  }\n};","map":null,"metadata":{},"sourceType":"module"}
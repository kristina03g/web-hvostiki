{"ast":null,"code":"import { drawing as draw, throttle, geometry } from '@progress/kendo-drawing';\nimport { RootElement, Title, CategoryAxis, Point } from '../core';\nimport Highlight from './highlight';\nimport Pannable from './pan-and-zoom/pannable';\nimport ZoomSelection from './pan-and-zoom/zoom-selection';\nimport MousewheelZoom from './pan-and-zoom/mousewheel-zoom';\nimport Legend from './legend/legend';\nimport PlotAreaFactory from './plotarea/plotarea-factory';\nimport Selection from './selection';\nimport SeriesBinder from './series-binder';\nimport Tooltip from './tooltip/tooltip';\nimport SharedTooltip from './tooltip/shared-tooltip';\nimport CategoricalPlotArea from './plotarea/categorical-plotarea';\nimport PlotAreaBase from './plotarea/plotarea-base';\nimport { ChartService, DomEventsBuilder } from '../services';\nimport getField from './utils/get-field';\nimport isDateAxis from './utils/is-date-axis';\nimport getDateField from './utils/get-date-field';\nimport { ChartPane, ChartPlotArea, findAxisByName } from './api-elements';\nimport { X, Y, VALUE, DEFAULT_WIDTH, DEFAULT_HEIGHT, DEFAULT_SERIES_OPACITY } from '../common/constants';\nimport { addClass, Class, setDefaultOptions, deepExtend, defined, find, isObject, isFunction, elementSize, elementOffset, elementScale, elementStyles, eventCoordinates, bindEvents, unbindEvents, mousewheelDelta, FontLoader, inArray, last, round, HashMap, valueOrDefault } from '../common';\nimport { dateComparer } from '../date-utils';\nimport { DRAG_START, DRAG, DRAG_END, ZOOM_START, ZOOM, ZOOM_END, SELECT_START, SELECT, SELECT_END, PLOT_AREA_HOVER, PLOT_AREA_LEAVE, RENDER, CATEGORY, PIE, DONUT, FUNNEL, COLUMN, MOUSEWHEEL, MOUSEWHEEL_DELAY, MOUSEWHEEL_ZOOM_RATE, SHOW_TOOLTIP, SERIES_HOVER } from './constants';\nimport './animations';\nimport './register-charts';\nvar AXIS_NAMES = [CATEGORY, VALUE, X, Y];\nvar MOUSEMOVE = \"mousemove\";\nvar CONTEXTMENU = \"contextmenu\";\nvar MOUSELEAVE = \"mouseleave\";\nvar MOUSEMOVE_DELAY = 20;\nvar Chart = function (Class) {\n  function Chart(element, userOptions, themeOptions, context) {\n    var this$1 = this;\n    if (context === void 0) context = {};\n    Class.call(this);\n    this.observers = [];\n    this.addObserver(context.observer);\n    this.chartService = new ChartService(this, context);\n    this.chartService.theme = themeOptions;\n    this._initElement(element);\n    var options = deepExtend({}, this.options, userOptions);\n    this._originalOptions = deepExtend({}, options);\n    this._theme = themeOptions;\n    this._initTheme(options, themeOptions);\n    this._initHandlers();\n    this._initSurface();\n    this.bindCategories();\n    FontLoader.preloadFonts(userOptions, function () {\n      this$1.fontLoaded = true;\n      if (!this$1._destroyed) {\n        this$1.trigger('init');\n        this$1._redraw();\n        this$1._attachEvents();\n      }\n    });\n  }\n  if (Class) Chart.__proto__ = Class;\n  Chart.prototype = Object.create(Class && Class.prototype);\n  Chart.prototype.constructor = Chart;\n  Chart.prototype._initElement = function _initElement(element) {\n    this._setElementClass(element);\n    element.style.position = \"relative\";\n    while (element.firstChild) {\n      element.removeChild(element.firstChild);\n    }\n    this.element = element;\n  };\n  Chart.prototype._setElementClass = function _setElementClass(element) {\n    addClass(element, \"k-chart\");\n  };\n  Chart.prototype._initTheme = function _initTheme(options, themeOptions) {\n    var seriesCopies = [];\n    var series = options.series || [];\n    for (var i = 0; i < series.length; i++) {\n      seriesCopies.push(Object.assign({}, series[i]));\n    }\n    options.series = seriesCopies;\n    resolveAxisAliases(options);\n    this.applyDefaults(options, themeOptions);\n\n    // Clean up default if not overriden by data attributes\n    if (options.seriesColors === null) {\n      delete options.seriesColors;\n    }\n    this.options = deepExtend({}, themeOptions, options);\n    this.applySeriesColors();\n  };\n  Chart.prototype.getSize = function getSize() {\n    var chartArea = this.options.chartArea || {};\n    var width = chartArea.width ? parseInt(chartArea.width, 10) : Math.floor(this.element.offsetWidth);\n    var height = chartArea.height ? parseInt(chartArea.height, 10) : Math.floor(this.element.offsetHeight);\n    return {\n      width: width,\n      height: height\n    };\n  };\n  Chart.prototype.resize = function resize(force) {\n    var size = this.getSize();\n    var currentSize = this._size;\n    var hasSize = size.width > 0 || size.height > 0;\n    if (force || hasSize && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {\n      this._size = size;\n      this._resize(size, force);\n      this.trigger(\"resize\", size);\n    } else if (hasSize && this._selections && find(this._selections, function (s) {\n      return !s.visible;\n    })) {\n      this._destroySelections();\n      this._setupSelection();\n    }\n  };\n  Chart.prototype._resize = function _resize() {\n    this._noTransitionsRedraw();\n  };\n  Chart.prototype.redraw = function redraw(paneName) {\n    this.applyDefaults(this.options);\n    this.applySeriesColors();\n    if (paneName) {\n      var plotArea = this._model._plotArea;\n      var pane = plotArea.findPane(paneName);\n      plotArea.redraw(pane);\n    } else {\n      this._redraw();\n    }\n  };\n  Chart.prototype.getAxis = function getAxis(name) {\n    return findAxisByName(name, this._plotArea.axes);\n  };\n  Chart.prototype.findAxisByName = function findAxisByName(name) {\n    return this.getAxis(name);\n  };\n  Chart.prototype.findPaneByName = function findPaneByName(name) {\n    var panes = this._plotArea.panes;\n    for (var idx = 0; idx < panes.length; idx++) {\n      if (panes[idx].options.name === name) {\n        return new ChartPane(panes[idx]);\n      }\n    }\n  };\n  Chart.prototype.findPaneByIndex = function findPaneByIndex(idx) {\n    var panes = this._plotArea.panes;\n    if (panes[idx]) {\n      return new ChartPane(panes[idx]);\n    }\n  };\n  Chart.prototype.plotArea = function plotArea() {\n    return new ChartPlotArea(this._plotArea);\n  };\n  Chart.prototype.toggleHighlight = function toggleHighlight(show, filter) {\n    var plotArea = this._plotArea;\n    var firstSeries = (plotArea.srcSeries || plotArea.series || [])[0];\n    var points;\n    if (isFunction(filter)) {\n      points = plotArea.filterPoints(filter);\n    } else {\n      var seriesName, categoryName;\n      if (isObject(filter)) {\n        seriesName = filter.series;\n        categoryName = filter.category;\n      } else {\n        seriesName = categoryName = filter;\n      }\n      if (firstSeries.type === DONUT) {\n        points = pointByCategoryName(plotArea.pointsBySeriesName(seriesName), categoryName);\n      } else if (firstSeries.type === PIE || firstSeries.type === FUNNEL) {\n        points = pointByCategoryName((plotArea.charts[0] || {}).points, categoryName);\n      } else {\n        points = plotArea.pointsBySeriesName(seriesName);\n      }\n    }\n    if (points) {\n      this.togglePointsHighlight(show, points);\n    }\n  };\n  Chart.prototype.togglePointsHighlight = function togglePointsHighlight(show, points) {\n    var highlight = this._highlight;\n    for (var idx = 0; idx < points.length; idx++) {\n      highlight.togglePointHighlight(points[idx], show);\n    }\n  };\n  Chart.prototype.showTooltip = function showTooltip(filter) {\n    var shared = this._sharedTooltip();\n    var ref = this;\n    var tooltip = ref._tooltip;\n    var plotArea = ref._plotArea;\n    var point, categoryIndex;\n    if (isFunction(filter)) {\n      point = plotArea.findPoint(filter);\n      if (point && shared) {\n        categoryIndex = point.categoryIx;\n      }\n    } else if (shared && defined(filter)) {\n      categoryIndex = plotArea.categoryAxis.categoryIndex(filter);\n    }\n    if (shared) {\n      if (categoryIndex >= 0) {\n        var points = this._plotArea.pointsByCategoryIndex(categoryIndex);\n        tooltip.showAt(points);\n      }\n    } else if (point) {\n      tooltip.show(point);\n    }\n  };\n  Chart.prototype.hideTooltip = function hideTooltip() {\n    this._tooltip.hide();\n  };\n  Chart.prototype._initSurface = function _initSurface() {\n    var surface = this.surface;\n    var wrap = this._surfaceWrap();\n    var chartArea = this.options.chartArea || {};\n    if (chartArea.width) {\n      elementSize(wrap, {\n        width: chartArea.width\n      });\n    }\n    if (chartArea.height) {\n      elementSize(wrap, {\n        height: chartArea.height\n      });\n    }\n    if (!surface || surface.options.type !== this.options.renderAs) {\n      this._destroySurface();\n      this.surface = draw.Surface.create(wrap, {\n        type: this.options.renderAs\n      });\n      this.surface.bind(\"mouseenter\", this._surfaceMouseenterHandler);\n      this.surface.bind(\"mouseleave\", this._surfaceMouseleaveHandler);\n    } else {\n      this.surface.clear();\n      this.surface.resize();\n    }\n  };\n  Chart.prototype._surfaceWrap = function _surfaceWrap() {\n    return this.element;\n  };\n  Chart.prototype._redraw = function _redraw() {\n    var model = this._getModel();\n    this._size = {\n      width: model.options.width,\n      height: model.options.height\n    };\n    this._destroyView();\n    this._model = model;\n    this._plotArea = model._plotArea;\n    model.renderVisual();\n    if (this.options.transitions !== false) {\n      model.traverse(function (element) {\n        if (element.animation) {\n          element.animation.setup();\n        }\n      });\n    }\n    this._initSurface();\n    this.surface.draw(model.visual);\n    if (this.options.transitions !== false) {\n      model.traverse(function (element) {\n        if (element.animation) {\n          element.animation.play();\n        }\n      });\n    }\n    this._tooltip = this._createTooltip();\n    this._highlight = new Highlight();\n    this._setupSelection();\n    this._createPannable();\n    this._createZoomSelection();\n    this._createMousewheelZoom();\n    this.trigger(RENDER);\n    triggerPaneRender(this._plotArea.panes);\n    if (!this._navState) {\n      this._cancelDomEvents();\n    }\n  };\n  Chart.prototype.exportVisual = function exportVisual(exportOptions) {\n    var visual;\n    if (exportOptions && (exportOptions.width || exportOptions.height || exportOptions.options)) {\n      var currentOptions = this.options;\n      var options = deepExtend({}, exportOptions.options, {\n        chartArea: {\n          width: exportOptions.width,\n          height: exportOptions.height\n        }\n      });\n      clearMissingValues(this._originalOptions, options);\n      this.options = deepExtend({}, this._originalOptions, options);\n      this._initTheme(this.options, this._theme);\n      this.bindCategories();\n      var model = this._getModel();\n      model.renderVisual();\n      triggerPaneRender(model._plotArea.panes);\n      visual = model.visual;\n      this.options = currentOptions;\n    } else {\n      visual = this.surface.exportVisual();\n    }\n    return visual;\n  };\n  Chart.prototype._sharedTooltip = function _sharedTooltip() {\n    return this._plotArea instanceof CategoricalPlotArea && this.options.tooltip && this.options.tooltip.shared;\n  };\n  Chart.prototype._createPannable = function _createPannable() {\n    var options = this.options;\n    if (options.pannable !== false) {\n      this._pannable = new Pannable(this._plotArea, options.pannable);\n    }\n  };\n  Chart.prototype._createZoomSelection = function _createZoomSelection() {\n    var zoomable = this.options.zoomable;\n    var selection = (zoomable || {}).selection;\n    if (zoomable !== false && selection !== false) {\n      this._zoomSelection = new ZoomSelection(this, selection);\n    }\n  };\n  Chart.prototype._createMousewheelZoom = function _createMousewheelZoom() {\n    var zoomable = this.options.zoomable;\n    var mousewheel = (zoomable || {}).mousewheel;\n    if (zoomable !== false && mousewheel !== false) {\n      this._mousewheelZoom = new MousewheelZoom(this, mousewheel);\n    }\n  };\n  Chart.prototype._toggleDragZoomEvents = function _toggleDragZoomEvents() {\n    var pannable = this.options.pannable;\n    var zoomable = this.options.zoomable;\n    var selection = (zoomable || {}).selection;\n    var mousewheel = (zoomable || {}).mousewheel;\n    var allowDrag = !pannable && (zoomable === false || selection === false) && !this.requiresHandlers([DRAG_START, DRAG, DRAG_END]);\n    var allowZoom = (zoomable === false || mousewheel === false) && !this.requiresHandlers([ZOOM_START, ZOOM, ZOOM_END]);\n    var element = this.element;\n    if (this._dragZoomEnabled && allowDrag && allowZoom) {\n      element.style.touchAction = this._touchAction || '';\n      this._dragZoomEnabled = false;\n    } else if (!this._dragZoomEnabled && !(allowDrag && allowZoom)) {\n      element.style.touchAction = \"none\";\n      this._dragZoomEnabled = true;\n    }\n    this._toggleDomEvents(!allowDrag, !allowZoom);\n  };\n  Chart.prototype._toggleDomEvents = function _toggleDomEvents(drag, zoom) {\n    var domEvents = this.domEvents;\n    if (!domEvents) {\n      return;\n    }\n    if (domEvents.toggleDrag) {\n      domEvents.toggleDrag(drag);\n    }\n    if (domEvents.toggleZoom) {\n      domEvents.toggleZoom(zoom);\n    }\n  };\n  Chart.prototype._createTooltip = function _createTooltip() {\n    var ref = this;\n    var tooltipOptions = ref.options.tooltip;\n    var tooltip;\n    if (this._sharedTooltip()) {\n      tooltip = this._createSharedTooltip(tooltipOptions);\n    } else {\n      tooltip = new Tooltip(this.chartService, tooltipOptions);\n    }\n    return tooltip;\n  };\n  Chart.prototype._createSharedTooltip = function _createSharedTooltip(options) {\n    return new SharedTooltip(this._plotArea, options);\n  };\n  Chart.prototype.applyDefaults = function applyDefaults(options, themeOptions) {\n    applyAxisDefaults(options, themeOptions);\n    applySeriesDefaults(options, themeOptions);\n  };\n  Chart.prototype.applySeriesColors = function applySeriesColors() {\n    var options = this.options;\n    var series = options.series;\n    var colors = options.seriesColors || [];\n    for (var i = 0; i < series.length; i++) {\n      var currentSeries = series[i];\n      var seriesColor = colors[i % colors.length];\n      var defaults = currentSeries._defaults;\n      currentSeries.color = currentSeries.color || seriesColor;\n      if (defaults) {\n        defaults.color = defaults.color || seriesColor;\n      }\n    }\n  };\n  Chart.prototype._getModel = function _getModel() {\n    var options = this.options;\n    var plotArea = this._createPlotArea();\n    var model = new RootElement(this._modelOptions());\n    model.chart = this;\n    model._plotArea = plotArea;\n    var title = Title.buildTitle(options.title);\n    var subtitle = Title.buildTitle(options.subtitle, {\n      align: options.title.align,\n      position: options.title.position\n    });\n    model.append.apply(model, Title.orderTitles([title, subtitle]));\n    if (options.legend && options.legend.visible) {\n      model.append(new Legend(plotArea.options.legend, this.chartService));\n    }\n    model.append(plotArea);\n    model.reflow();\n    return model;\n  };\n  Chart.prototype._modelOptions = function _modelOptions() {\n    var options = this.options;\n    var size = this.getSize();\n    return deepExtend({\n      transitions: options.transitions,\n      width: size.width || DEFAULT_WIDTH,\n      height: size.height || DEFAULT_HEIGHT\n    }, options.chartArea);\n  };\n  Chart.prototype._createPlotArea = function _createPlotArea(skipSeries) {\n    var options = this.options;\n    var plotArea = PlotAreaFactory.current.create(skipSeries ? [] : options.series, options, this.chartService);\n    return plotArea;\n  };\n  Chart.prototype._setupSelection = function _setupSelection() {\n    var this$1 = this;\n    var ref = this;\n    var axes = ref._plotArea.axes;\n    var selections = this._selections = [];\n    for (var i = 0; i < axes.length; i++) {\n      var axis = axes[i];\n      var options = axis.options;\n      if (axis instanceof CategoryAxis && options.select && !options.vertical) {\n        var range = axis.range();\n        var selection = new Selection(this$1, axis, deepExtend({\n          min: range.min,\n          max: range.max\n        }, options.select));\n        selections.push(selection);\n      }\n    }\n  };\n  Chart.prototype._selectStart = function _selectStart(e) {\n    return this.trigger(SELECT_START, e);\n  };\n  Chart.prototype._select = function _select(e) {\n    return this.trigger(SELECT, e);\n  };\n  Chart.prototype._selectEnd = function _selectEnd(e) {\n    return this.trigger(SELECT_END, e);\n  };\n  Chart.prototype._initHandlers = function _initHandlers() {\n    this._clickHandler = this._click.bind(this);\n    this._mousewheelHandler = this._mousewheel.bind(this);\n    this._mouseleaveHandler = this._mouseleave.bind(this);\n    this._surfaceMouseenterHandler = this._mouseover.bind(this);\n    this._surfaceMouseleaveHandler = this._mouseout.bind(this);\n    this._mousemove = throttle(this._mousemove.bind(this), MOUSEMOVE_DELAY);\n  };\n  Chart.prototype.addObserver = function addObserver(observer) {\n    if (observer) {\n      this.observers.push(observer);\n    }\n  };\n  Chart.prototype.removeObserver = function removeObserver(observer) {\n    var index = this.observers.indexOf(observer);\n    if (index >= 0) {\n      this.observers.splice(index, 1);\n    }\n  };\n  Chart.prototype.requiresHandlers = function requiresHandlers(eventNames) {\n    var observers = this.observers;\n    for (var idx = 0; idx < observers.length; idx++) {\n      if (observers[idx].requiresHandlers(eventNames)) {\n        return true;\n      }\n    }\n  };\n  Chart.prototype.trigger = function trigger(name, args) {\n    if (args === void 0) args = {};\n    if (name === SHOW_TOOLTIP) {\n      args.anchor.point = this._toDocumentCoordinates(args.anchor.point);\n    }\n    args.sender = this;\n    var observers = this.observers;\n    var isDefaultPrevented = false;\n    for (var idx = 0; idx < observers.length; idx++) {\n      if (observers[idx].trigger(name, args)) {\n        isDefaultPrevented = true;\n      }\n    }\n    return isDefaultPrevented;\n  };\n  Chart.prototype._attachEvents = function _attachEvents() {\n    var obj, obj$1;\n    var element = this.element;\n    this._touchAction = element.style.touchAction;\n    bindEvents(element, (obj = {}, obj[CONTEXTMENU] = this._clickHandler, obj[MOUSEWHEEL] = this._mousewheelHandler, obj[MOUSELEAVE] = this._mouseleaveHandler, obj));\n    if (this._shouldAttachMouseMove()) {\n      bindEvents(element, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mousemove, obj$1));\n    }\n    this.domEvents = DomEventsBuilder.create(this.element, {\n      start: this._start.bind(this),\n      move: this._move.bind(this),\n      end: this._end.bind(this),\n      tap: this._tap.bind(this),\n      gesturestart: this._gesturestart.bind(this),\n      gesturechange: this._gesturechange.bind(this),\n      gestureend: this._gestureend.bind(this)\n    });\n    this._toggleDragZoomEvents();\n  };\n  Chart.prototype._mouseleave = function _mouseleave(e) {\n    if (this._hoveredPoint) {\n      this._hoveredPoint.out(this, e);\n      this._hoveredPoint = null;\n    }\n    if (this._plotAreaHovered) {\n      this._plotAreaHovered = false;\n      this.trigger(PLOT_AREA_LEAVE);\n    }\n  };\n  Chart.prototype._cancelDomEvents = function _cancelDomEvents() {\n    if (this.domEvents && this.domEvents.cancel) {\n      this.domEvents.cancel();\n    }\n  };\n  Chart.prototype._gesturestart = function _gesturestart(e) {\n    if (this._mousewheelZoom && !this._stopChartHandlers(e)) {\n      this._gestureDistance = e.distance;\n      this._unsetActivePoint();\n      this.surface.suspendTracking();\n    }\n  };\n  Chart.prototype._gestureend = function _gestureend(e) {\n    if (this._zooming && !this._stopChartHandlers(e)) {\n      if (this.surface) {\n        this.surface.resumeTracking();\n      }\n      this._zooming = false;\n      this.trigger(ZOOM_END, {});\n    }\n  };\n  Chart.prototype._gesturechange = function _gesturechange(e) {\n    var mousewheelZoom = this._mousewheelZoom;\n    if (mousewheelZoom && !this._stopChartHandlers(e)) {\n      e.preventDefault();\n      var previousGestureDistance = this._gestureDistance;\n      var scaleDelta = -e.distance / previousGestureDistance + 1;\n      if (Math.abs(scaleDelta) >= 0.1) {\n        scaleDelta = Math.round(scaleDelta * 10);\n        this._gestureDistance = e.distance;\n        var args = {\n          delta: scaleDelta,\n          axisRanges: axisRanges(this._plotArea.axes),\n          originalEvent: e\n        };\n        if (this._zooming || !this.trigger(ZOOM_START, args)) {\n          var coords = this._eventCoordinates(e);\n          if (!this._zooming) {\n            this._zooming = true;\n          }\n          var ranges = args.axisRanges = mousewheelZoom.updateRanges(scaleDelta, coords);\n          if (ranges && !this.trigger(ZOOM, args)) {\n            mousewheelZoom.zoom();\n          }\n        }\n      }\n    }\n  };\n  Chart.prototype._mouseout = function _mouseout(e) {\n    if (e.element) {\n      var element = this._drawingChartElement(e.element, e);\n      if (element && element.leave) {\n        element.leave(this, e.originalEvent);\n      }\n    }\n  };\n  Chart.prototype._start = function _start(e) {\n    var coords = this._eventCoordinates(e);\n    if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {\n      return;\n    }\n    if (this.requiresHandlers([DRAG_START, DRAG, DRAG_END])) {\n      this._startNavigation(e, coords, DRAG_START);\n    }\n    if (this._pannable && this._pannable.start(e)) {\n      this.surface.suspendTracking();\n      this._unsetActivePoint();\n      this._suppressHover = true;\n      this.chartService.panning = true;\n    }\n    if (this._zoomSelection) {\n      if (this._zoomSelection.start(e)) {\n        this.trigger(ZOOM_START, {\n          axisRanges: axisRanges(this._plotArea.axes),\n          originalEvent: e\n        });\n      }\n    }\n  };\n  Chart.prototype._move = function _move(e) {\n    var ref = this;\n    var state = ref._navState;\n    var pannable = ref._pannable;\n    if (this._stopChartHandlers(e)) {\n      return;\n    }\n    if (pannable) {\n      var ranges = pannable.move(e);\n      if (ranges && !this.trigger(DRAG, {\n        axisRanges: ranges,\n        originalEvent: e\n      })) {\n        pannable.pan();\n      }\n    } else if (state) {\n      var ranges$1 = {};\n      var axes = state.axes;\n      for (var i = 0; i < axes.length; i++) {\n        var currentAxis = axes[i];\n        var axisName = currentAxis.options.name;\n        if (axisName) {\n          var axis = currentAxis.options.vertical ? e.y : e.x;\n          var delta = axis.startLocation - axis.location;\n          if (delta !== 0) {\n            ranges$1[currentAxis.options.name] = currentAxis.translateRange(delta);\n          }\n        }\n      }\n      state.axisRanges = ranges$1;\n      this.trigger(DRAG, {\n        axisRanges: ranges$1,\n        originalEvent: e\n      });\n    }\n    if (this._zoomSelection) {\n      this._zoomSelection.move(e);\n    }\n  };\n  Chart.prototype._end = function _end(e) {\n    if (this._stopChartHandlers(e)) {\n      return;\n    }\n    var pannable = this._pannable;\n    if (pannable && pannable.end(e)) {\n      this.surface.resumeTracking();\n      this.trigger(DRAG_END, {\n        axisRanges: axisRanges(this._plotArea.axes),\n        originalEvent: e\n      });\n      this._suppressHover = false;\n      this.chartService.panning = false;\n    } else {\n      this._endNavigation(e, DRAG_END);\n    }\n    if (this._zoomSelection) {\n      var ranges = this._zoomSelection.end(e);\n      if (ranges && !this.trigger(ZOOM, {\n        axisRanges: ranges,\n        originalEvent: e\n      })) {\n        this._zoomSelection.zoom();\n        this.trigger(ZOOM_END, {\n          axisRanges: ranges,\n          originalEvent: e\n        });\n      }\n    }\n  };\n  Chart.prototype._stopChartHandlers = function _stopChartHandlers(e) {\n    var selections = this._selections || [];\n    if (!selections.length) {\n      return false;\n    }\n    var coords = this._eventCoordinates(e);\n    var pane = this._plotArea.paneByPoint(coords);\n    if (pane) {\n      for (var idx = 0; idx < selections.length; idx++) {\n        if (selections[idx].onPane(pane)) {\n          return true;\n        }\n      }\n    }\n  };\n  Chart.prototype._mousewheelZoomRate = function _mousewheelZoomRate() {\n    var zoomable = this.options.zoomable;\n    var mousewheel = (zoomable || {}).mousewheel || {};\n    return valueOrDefault(mousewheel.rate, MOUSEWHEEL_ZOOM_RATE);\n  };\n  Chart.prototype._mousewheel = function _mousewheel(e) {\n    var this$1 = this;\n    var delta = mousewheelDelta(e);\n    var mousewheelZoom = this._mousewheelZoom;\n    var coords = this._eventCoordinates(e);\n    if (this._stopChartHandlers(e) || !this._plotArea.backgroundContainsPoint(coords)) {\n      return;\n    }\n    if (mousewheelZoom) {\n      var args = {\n        delta: delta,\n        axisRanges: axisRanges(this._plotArea.axes),\n        originalEvent: e\n      };\n      if (this._zooming || !this.trigger(ZOOM_START, args)) {\n        e.preventDefault();\n        if (!this._zooming) {\n          this._unsetActivePoint();\n          this.surface.suspendTracking();\n          this._zooming = true;\n        }\n        if (this._mwTimeout) {\n          clearTimeout(this._mwTimeout);\n        }\n        args.axisRanges = mousewheelZoom.updateRanges(delta, coords);\n        if (args.axisRanges && !this.trigger(ZOOM, args)) {\n          mousewheelZoom.zoom();\n        }\n        this._mwTimeout = setTimeout(function () {\n          this$1.trigger(ZOOM_END, args);\n          this$1._zooming = false;\n          if (this$1.surface) {\n            this$1.surface.resumeTracking();\n          }\n        }, MOUSEWHEEL_DELAY);\n      }\n    } else {\n      var state = this._navState;\n      if (!state) {\n        var prevented = this._startNavigation(e, coords, ZOOM_START);\n        if (!prevented) {\n          state = this._navState;\n        }\n      }\n      if (state) {\n        var totalDelta = state.totalDelta || delta;\n        state.totalDelta = totalDelta + delta;\n        var axes = this._navState.axes;\n        var ranges = {};\n        for (var i = 0; i < axes.length; i++) {\n          var currentAxis = axes[i];\n          var axisName = currentAxis.options.name;\n          if (axisName) {\n            ranges[axisName] = currentAxis.scaleRange(-totalDelta * this$1._mousewheelZoomRate(), coords);\n          }\n        }\n        this.trigger(ZOOM, {\n          delta: delta,\n          axisRanges: ranges,\n          originalEvent: e\n        });\n        if (this._mwTimeout) {\n          clearTimeout(this._mwTimeout);\n        }\n        this._mwTimeout = setTimeout(function () {\n          this$1._endNavigation(e, ZOOM_END);\n        }, MOUSEWHEEL_DELAY);\n      }\n    }\n  };\n  Chart.prototype._startNavigation = function _startNavigation(e, coords, chartEvent) {\n    var plotArea = this._model._plotArea;\n    var pane = plotArea.findPointPane(coords);\n    var axes = plotArea.axes.slice(0);\n    if (!pane) {\n      return;\n    }\n    var ranges = axisRanges(axes);\n    var prevented = this.trigger(chartEvent, {\n      axisRanges: ranges,\n      originalEvent: e\n    });\n    if (prevented) {\n      this._cancelDomEvents();\n    } else {\n      this._suppressHover = true;\n      this._unsetActivePoint();\n      this._navState = {\n        axisRanges: ranges,\n        pane: pane,\n        axes: axes\n      };\n    }\n  };\n  Chart.prototype._endNavigation = function _endNavigation(e, chartEvent) {\n    if (this._navState) {\n      this.trigger(chartEvent, {\n        axisRanges: this._navState.axisRanges,\n        originalEvent: e\n      });\n      this._suppressHover = false;\n      this._navState = null;\n    }\n  };\n  Chart.prototype._getChartElement = function _getChartElement(e, match) {\n    var element = this.surface.eventTarget(e);\n    if (element) {\n      return this._drawingChartElement(element, e, match);\n    }\n  };\n  Chart.prototype._drawingChartElement = function _drawingChartElement(element, e, match) {\n    var current = element;\n    var chartElement;\n    while (current && !chartElement) {\n      chartElement = current.chartElement;\n      current = current.parent;\n    }\n    if (chartElement) {\n      if (chartElement.aliasFor) {\n        chartElement = chartElement.aliasFor(e, this._eventCoordinates(e));\n      }\n      if (match) {\n        chartElement = chartElement.closest(match);\n        if (chartElement && chartElement.aliasFor) {\n          chartElement = chartElement.aliasFor();\n        }\n      }\n      return chartElement;\n    }\n  };\n  Chart.prototype._eventCoordinates = function _eventCoordinates(e) {\n    var coordinates = eventCoordinates(e);\n    return this._toModelCoordinates(coordinates.x, coordinates.y);\n  };\n  Chart.prototype._elementPadding = function _elementPadding() {\n    if (!this._padding) {\n      var ref = elementStyles(this.element, [\"paddingLeft\", \"paddingTop\"]);\n      var paddingLeft = ref.paddingLeft;\n      var paddingTop = ref.paddingTop;\n      this._padding = {\n        top: paddingTop,\n        left: paddingLeft\n      };\n    }\n    return this._padding;\n  };\n  Chart.prototype._toDocumentCoordinates = function _toDocumentCoordinates(point) {\n    var padding = this._elementPadding();\n    var offset = elementOffset(this.element);\n    return {\n      left: round(point.x + padding.left + offset.left),\n      top: round(point.y + padding.top + offset.top)\n    };\n  };\n\n  // TODO: Breaking change due to peer version change\n  // Reuse by exposing _surfacePoint on Surface\n  Chart.prototype._toModelCoordinates = function _toModelCoordinates(clientX, clientY) {\n    var element = this.element;\n    var offset = elementOffset(element);\n    var padding = this._elementPadding();\n    var inverseTransform = elementScale(element).invert();\n    var point = new geometry.Point(clientX - offset.left - padding.left, clientY - offset.top - padding.top).transform(inverseTransform);\n    return new Point(point.x, point.y);\n  };\n  Chart.prototype._tap = function _tap(e) {\n    var this$1 = this;\n    var drawingElement = this.surface.eventTarget(e);\n    var element = this._drawingChartElement(drawingElement, e);\n    var sharedTooltip = this._sharedTooltip();\n    if (!this._startHover(drawingElement, e) && !sharedTooltip) {\n      this._unsetActivePoint();\n    }\n    if (sharedTooltip) {\n      this._trackSharedTooltip(this._eventCoordinates(e), e, true);\n    }\n    this._propagateClick(element, e);\n\n    //part of fix for hover issue on windows touch\n    this.handlingTap = true;\n    setTimeout(function () {\n      this$1.handlingTap = false;\n    }, 0);\n  };\n  Chart.prototype._click = function _click(e) {\n    var element = this._getChartElement(e);\n    this._propagateClick(element, e);\n  };\n  Chart.prototype._propagateClick = function _propagateClick(element, e) {\n    var this$1 = this;\n    var current = element;\n    while (current) {\n      if (current.click) {\n        current.click(this$1, e);\n      }\n      current = current.parent;\n    }\n  };\n  Chart.prototype._startHover = function _startHover(element, e) {\n    if (this._suppressHover) {\n      return false;\n    }\n    var point = this._drawingChartElement(element, e, function (element) {\n      return (element.hover || element.over) && !(element instanceof PlotAreaBase);\n    });\n    this._showInactiveOpacity(point, e);\n    return point;\n  };\n  Chart.prototype._displayTooltip = function _displayTooltip(point) {\n    var tooltipOptions = deepExtend({}, this.options.tooltip, point.options.tooltip);\n    if (tooltipOptions.visible) {\n      this._tooltip.show(point);\n    }\n  };\n  Chart.prototype._displayInactiveOpacity = function _displayInactiveOpacity(activePoint, multipleSeries, highlightPoints) {\n    var chartInstance = this._activeChartInstance = this._chartInstanceFromPoint(activePoint);\n    if (!chartInstance) {\n      return;\n    }\n    if (multipleSeries) {\n      this._updateSeriesOpacity(activePoint);\n      this._applySeriesOpacity(chartInstance.children, null, true);\n      this._applySeriesOpacity(chartInstance.children, activePoint.series);\n      this._highlight.show(highlightPoints || activePoint);\n    } else {\n      var inactivePoints;\n      if (!chartInstance.supportsPointInactiveOpacity()) {\n        this._highlight.show(activePoint);\n        return;\n      }\n      inactivePoints = this._getInactivePoints(activePoint, chartInstance);\n      if (inactivePoints && inactivePoints.length) {\n        this._highlight.show(inactivePoints, 1 - this._getInactiveOpacityForSeries(activePoint.series));\n      }\n    }\n  };\n  Chart.prototype._getInactivePoints = function _getInactivePoints(activePoint, chartInstance) {\n    var allPoints = this._getAllPointsOfType(chartInstance, activePoint.constructor);\n    return allPoints.filter(function (point) {\n      return point !== activePoint;\n    });\n  };\n  Chart.prototype._getAllPointsOfType = function _getAllPointsOfType(container, type) {\n    var this$1 = this;\n    var points = [];\n    for (var i = 0; i < container.children.length; i++) {\n      var element = container.children[i];\n      if (element.constructor === type) {\n        points.push(element);\n      } else if (element.children && element.children.length) {\n        points = points.concat(this$1._getAllPointsOfType(element, type));\n      }\n    }\n    return points;\n  };\n  Chart.prototype._updateHoveredPoint = function _updateHoveredPoint(point, e) {\n    var hoveredPoint = this._hoveredPoint;\n    if (hoveredPoint && hoveredPoint !== point) {\n      hoveredPoint.out(this, e);\n      this._hoveredPoint = null;\n    }\n    if (point && hoveredPoint !== point && point.over) {\n      this._hoveredPoint = point;\n      point.over(this, e);\n    }\n  };\n  Chart.prototype._updateSeriesOpacity = function _updateSeriesOpacity(point, resetOpacity) {\n    var this$1 = this;\n    var plotArea = this._plotArea;\n    var length = plotArea.series.length;\n    for (var i = 0; i < length; i++) {\n      var currSeries = plotArea.series[i];\n      var defaultOpacity = this$1._getDefaultOpacityForSeries(currSeries);\n      var inactiveOpacity = this$1._getInactiveOpacityForSeries(currSeries);\n      if (!resetOpacity && currSeries !== point.series) {\n        currSeries.defaultOpacity = defaultOpacity;\n        currSeries.opacity = inactiveOpacity;\n        if (currSeries.line) {\n          currSeries.line.opacity = inactiveOpacity;\n        }\n      } else {\n        currSeries.opacity = defaultOpacity;\n        if (currSeries.line) {\n          currSeries.line.opacity = defaultOpacity;\n        }\n      }\n    }\n  };\n  Chart.prototype._applySeriesOpacity = function _applySeriesOpacity(elements, activeSeries, reset, series) {\n    var this$1 = this;\n    for (var i = 0; i < elements.length; i++) {\n      var element = elements[i];\n      var currSeries = element.series || series;\n      var shouldHighlight = currSeries && (currSeries.highlight || {}).visible;\n      if (shouldHighlight && element.visual) {\n        var opacity = series ? series.opacity : element.series.opacity;\n        if (currSeries !== activeSeries || reset) {\n          element.visual.opacity(reset ? 1 : opacity);\n        }\n      }\n      if (element.children && element.children.length) {\n        this$1._applySeriesOpacity(element.children, activeSeries, reset, element.series);\n      }\n    }\n  };\n  Chart.prototype._chartInstanceFromPoint = function _chartInstanceFromPoint(point) {\n    var chartInstance = point.parent;\n    while (chartInstance && !chartInstance.plotArea) {\n      chartInstance = chartInstance.parent;\n    }\n    return chartInstance;\n  };\n  Chart.prototype._showInactiveOpacity = function _showInactiveOpacity(point, e) {\n    var activePoint = this._activePoint;\n    var multipleSeries = this._plotArea.series.length > 1;\n    var hasInactiveOpacity = this._hasInactiveOpacity();\n    this._updateHoveredPoint(point, e);\n    if (point && activePoint !== point && point.hover) {\n      this._activePoint = point;\n      if (!this._sharedTooltip() && !point.hover(this, e)) {\n        this._displayTooltip(point);\n        if (hasInactiveOpacity) {\n          this._displayInactiveOpacity(point, multipleSeries);\n        } else {\n          this._highlight.show(point);\n        }\n      }\n    }\n    return point;\n  };\n  Chart.prototype._hideInactiveOpacity = function _hideInactiveOpacity(point) {\n    var multipleSeries = this._plotArea.series.length > 1;\n    var hasInactiveOpacity = this._hasInactiveOpacity();\n    if (hasInactiveOpacity) {\n      if (multipleSeries && this._activeChartInstance) {\n        this._updateSeriesOpacity(point, true);\n        this._applySeriesOpacity(this._activeChartInstance.children, null, true);\n        this._activeChartInstance = null;\n      }\n      this._highlight && this._highlight.hide();\n      this._activePoint = null;\n    }\n  };\n  Chart.prototype._hasInactiveOpacity = function _hasInactiveOpacity() {\n    var hasDefaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity !== undefined;\n    var hasInactiveOpacity = this.options.series.filter(function (s) {\n      return s.highlight.inactiveOpacity !== undefined;\n    }).length > 0;\n    return hasDefaultInactiveOpacity || hasInactiveOpacity;\n  };\n  Chart.prototype._getInactiveOpacityForSeries = function _getInactiveOpacityForSeries(series) {\n    var defaultInactiveOpacity = this.options.seriesDefaults.highlight.inactiveOpacity;\n    var seriesInactiveOpacity = series.highlight.inactiveOpacity;\n    return seriesInactiveOpacity || defaultInactiveOpacity || series.opacity || DEFAULT_SERIES_OPACITY;\n  };\n  Chart.prototype._getDefaultOpacityForSeries = function _getDefaultOpacityForSeries(series) {\n    return series.defaultOpacity || series.opacity || DEFAULT_SERIES_OPACITY;\n  };\n  Chart.prototype._mouseover = function _mouseover(e) {\n    var obj;\n    var point = this._startHover(e.element, e.originalEvent);\n    if (point && point.tooltipTracking && !this._mouseMoveTrackHandler && !this._sharedTooltip()) {\n      this._mouseMoveTrackHandler = this._mouseMoveTracking.bind(this);\n      bindEvents(document, (obj = {}, obj[MOUSEMOVE] = this._mouseMoveTrackHandler, obj));\n    }\n  };\n  Chart.prototype._mouseMoveTracking = function _mouseMoveTracking(e) {\n    var obj;\n    var ref = this;\n    var options = ref.options;\n    var tooltip = ref._tooltip;\n    var highlight = ref._highlight;\n    var point = ref._activePoint;\n    var coords = this._eventCoordinates(e);\n    if (this._plotArea.box.containsPoint(coords)) {\n      if (point && point.tooltipTracking && point.series && point.parent.getNearestPoint) {\n        var seriesPoint = point.parent.getNearestPoint(coords.x, coords.y, point.seriesIx);\n        if (seriesPoint && seriesPoint !== point) {\n          this._activePoint = seriesPoint;\n          if (!seriesPoint.hover(this, e)) {\n            var tooltipOptions = deepExtend({}, options.tooltip, seriesPoint.options.tooltip);\n            if (tooltipOptions.visible) {\n              tooltip.show(seriesPoint);\n            }\n            highlight.show(seriesPoint);\n          }\n        }\n      }\n    } else {\n      unbindEvents(document, (obj = {}, obj[MOUSEMOVE] = this._mouseMoveTrackHandler, obj));\n      this._unsetActivePoint();\n      this._mouseMoveTrackHandler = null;\n      this._hideInactiveOpacity(point);\n    }\n  };\n  Chart.prototype._mousemove = function _mousemove(e) {\n    var coords = this._eventCoordinates(e);\n    var plotArea = this._plotArea;\n    this._trackCrosshairs(coords);\n    if (plotArea.hover) {\n      var overPlotArea = plotArea.backgroundContainsPoint(coords);\n      if (overPlotArea) {\n        this._plotAreaHovered = true;\n        this._plotArea.hover(this, e);\n      } else if (this._plotAreaHovered && !overPlotArea) {\n        this._plotAreaHovered = false;\n        this.trigger(PLOT_AREA_LEAVE);\n      }\n    }\n    if (this._sharedTooltip()) {\n      this._trackSharedTooltip(coords, e);\n    }\n  };\n  Chart.prototype._trackCrosshairs = function _trackCrosshairs(coords) {\n    var crosshairs = this._plotArea.crosshairs;\n    for (var i = 0; i < crosshairs.length; i++) {\n      var current = crosshairs[i];\n      if (current.box.containsPoint(coords)) {\n        current.showAt(coords);\n      } else {\n        current.hide();\n      }\n    }\n  };\n  Chart.prototype._trackSharedTooltip = function _trackSharedTooltip(coords, e, toggle) {\n    if (this._suppressHover) {\n      return;\n    }\n    var ref = this;\n    var tooltipOptions = ref.options.tooltip;\n    var plotArea = ref._plotArea;\n    var categoryAxis = ref._plotArea.categoryAxis;\n    var tooltip = ref._tooltip;\n    var highlight = ref._highlight;\n    if (plotArea.backgroundContainsPoint(coords)) {\n      var index = categoryAxis.pointCategoryIndex(coords);\n      if (index !== this._tooltipCategoryIx || !this._sharedHighlight && toggle) {\n        var points = plotArea.pointsByCategoryIndex(index);\n        var pointArgs = points.map(function (point) {\n          return point.eventArgs(e);\n        });\n        var hoverArgs = pointArgs[0] || {};\n        hoverArgs.categoryPoints = pointArgs;\n        if (points.length > 0 && !this.trigger(SERIES_HOVER, hoverArgs)) {\n          if (tooltipOptions.visible) {\n            tooltip.showAt(points, coords);\n          }\n          highlight.show(points);\n          this._sharedHighlight = true;\n        } else {\n          tooltip.hide();\n        }\n        this._tooltipCategoryIx = index;\n      } else if (toggle && this._sharedHighlight) {\n        highlight.hide();\n        tooltip.hide();\n        this._sharedHighlight = false;\n      }\n    } else if (this._sharedHighlight) {\n      highlight.hide();\n      tooltip.hide();\n      this._tooltipCategoryIx = null;\n      this._sharedHighlight = false;\n    }\n  };\n  Chart.prototype.hideElements = function hideElements(options) {\n    var plotArea = this._plotArea;\n    this._mousemove.cancel();\n    plotArea.hideCrosshairs();\n    this._unsetActivePoint(options);\n  };\n  Chart.prototype._unsetActivePoint = function _unsetActivePoint(options) {\n    var ref = this;\n    var tooltip = ref._tooltip;\n    var highlight = ref._highlight;\n    this._activePoint = null;\n    this._hoveredPoint = null;\n    if (tooltip && !(options && options.keepTooltipOpen)) {\n      tooltip.hide();\n    }\n    this._tooltipCategoryIx = null;\n    this._sharedHighlight = false;\n    if (highlight) {\n      highlight.hide();\n    }\n  };\n  Chart.prototype._deferRedraw = function _deferRedraw() {\n    this._redraw();\n  };\n  Chart.prototype._clearRedrawTimeout = function _clearRedrawTimeout() {\n    if (this._redrawTimeout) {\n      clearInterval(this._redrawTimeout);\n      this._redrawTimeout = null;\n    }\n  };\n  Chart.prototype.bindCategories = function bindCategories() {\n    var this$1 = this;\n    var options = this.options;\n    var definitions = [].concat(options.categoryAxis);\n    for (var axisIx = 0; axisIx < definitions.length; axisIx++) {\n      var axis = definitions[axisIx];\n      if (axis.autoBind !== false) {\n        this$1.bindCategoryAxisFromSeries(axis, axisIx);\n      }\n    }\n  };\n  Chart.prototype.bindCategoryAxisFromSeries = function bindCategoryAxisFromSeries(axis, axisIx) {\n    var this$1 = this;\n    var series = this.options.series;\n    var seriesLength = series.length;\n    var uniqueCategories = new HashMap(); //perf improvement in case type category with dates\n    var items = [];\n    var bindable = false;\n    var dateAxis;\n    for (var seriesIx = 0; seriesIx < seriesLength; seriesIx++) {\n      var s = series[seriesIx];\n      var onAxis = s.categoryAxis === axis.name || !s.categoryAxis && axisIx === 0;\n      var data = s.data;\n      var dataLength = data.length;\n      var bind = s.categoryField && onAxis;\n      bindable = bind || bindable;\n      if (bind && dataLength > 0) {\n        dateAxis = isDateAxis(axis, getField(s.categoryField, data[0]));\n        var getFn = dateAxis ? getDateField : getField;\n        for (var dataIx = 0; dataIx < dataLength; dataIx++) {\n          var dataRow = data[dataIx];\n          var category = getFn(s.categoryField, dataRow, this$1.chartService.intl);\n          if (dateAxis || !uniqueCategories.get(category)) {\n            items.push([category, dataRow]);\n            if (!dateAxis) {\n              uniqueCategories.set(category, true);\n            }\n          }\n        }\n      }\n    }\n    if (items.length > 0) {\n      if (dateAxis) {\n        items = uniqueDates(items, function (a, b) {\n          return dateComparer(a[0], b[0]);\n        });\n      }\n      var result = transpose(items);\n      axis.categories = result[0];\n    } else if (bindable) {\n      axis.categories = [];\n    }\n  };\n  Chart.prototype._isBindable = function _isBindable(series) {\n    var valueFields = SeriesBinder.current.valueFields(series);\n    var result = true;\n    for (var i = 0; i < valueFields.length; i++) {\n      var field = valueFields[i];\n      if (field === VALUE) {\n        field = \"field\";\n      } else {\n        field = field + \"Field\";\n      }\n      if (!defined(series[field])) {\n        result = false;\n        break;\n      }\n    }\n    return result;\n  };\n  Chart.prototype._noTransitionsRedraw = function _noTransitionsRedraw() {\n    var options = this.options;\n    var transitionsState;\n    if (options.transitions !== false) {\n      options.transitions = false;\n      transitionsState = true;\n    }\n    this._redraw();\n    if (transitionsState) {\n      options.transitions = true;\n    }\n  };\n  Chart.prototype._legendItemHover = function _legendItemHover(seriesIndex, pointIndex) {\n    var ref = this;\n    var plotArea = ref._plotArea;\n    var highlight = ref._highlight;\n    var currentSeries = (plotArea.srcSeries || plotArea.series)[seriesIndex];\n    var items;\n    if (inArray(currentSeries.type, [PIE, DONUT, FUNNEL])) {\n      items = plotArea.findPoint(function (point) {\n        return point.series.index === seriesIndex && point.index === pointIndex;\n      });\n    } else {\n      items = plotArea.pointsBySeriesIndex(seriesIndex);\n    }\n    if (this._hasInactiveOpacity() && currentSeries.visible && items) {\n      var multipleSeries = plotArea.series.length > 1;\n      var point = items.length ? items[0] : items;\n      this._displayInactiveOpacity(point, multipleSeries, items);\n    } else {\n      highlight.show(items);\n    }\n  };\n  Chart.prototype._shouldAttachMouseMove = function _shouldAttachMouseMove() {\n    return this._plotArea.crosshairs.length || this._tooltip && this._sharedTooltip() || this.requiresHandlers([PLOT_AREA_HOVER, PLOT_AREA_LEAVE]);\n  };\n  Chart.prototype.updateMouseMoveHandler = function updateMouseMoveHandler() {\n    var obj, obj$1;\n    unbindEvents(this.element, (obj = {}, obj[MOUSEMOVE] = this._mousemove, obj));\n    if (this._shouldAttachMouseMove()) {\n      bindEvents(this.element, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mousemove, obj$1));\n    }\n  };\n  Chart.prototype.applyOptions = function applyOptions(options, theme) {\n    clearMissingValues(this._originalOptions, options);\n    this._originalOptions = deepExtend(this._originalOptions, options);\n    this.options = deepExtend({}, this._originalOptions);\n    if (theme) {\n      this._theme = theme;\n      this.chartService.theme = theme;\n    }\n    this._initTheme(this.options, this._theme);\n    this._toggleDragZoomEvents();\n  };\n  Chart.prototype.setOptions = function setOptions(options, theme) {\n    this.applyOptions(options, theme);\n    this.bindCategories();\n    this.redraw();\n    this.updateMouseMoveHandler();\n  };\n  Chart.prototype.setDirection = function setDirection(rtl) {\n    this.chartService.rtl = Boolean(rtl);\n    if (this.surface && this.surface.type === 'svg') {\n      this._destroySurface();\n    }\n  };\n  Chart.prototype.setIntlService = function setIntlService(intl) {\n    this.chartService.intl = intl;\n  };\n  Chart.prototype.noTransitionsRedraw = function noTransitionsRedraw() {\n    this._noTransitionsRedraw();\n  };\n  Chart.prototype.destroy = function destroy() {\n    var obj, obj$1;\n    this._destroyed = true;\n    unbindEvents(this.element, (obj = {}, obj[CONTEXTMENU] = this._clickHandler, obj[MOUSEWHEEL] = this._mousewheelHandler, obj[MOUSEMOVE] = this._mousemove, obj[MOUSELEAVE] = this._mouseleaveHandler, obj));\n    if (this.domEvents) {\n      this.domEvents.destroy();\n      delete this.domEvents;\n    }\n    if (this._mouseMoveTrackHandler) {\n      unbindEvents(document, (obj$1 = {}, obj$1[MOUSEMOVE] = this._mouseMoveTrackHandler, obj$1));\n    }\n    this._destroyView();\n    this._destroySurface();\n    this._clearRedrawTimeout();\n  };\n  Chart.prototype._destroySurface = function _destroySurface() {\n    var surface = this.surface;\n    if (surface) {\n      surface.unbind(\"mouseenter\", this._surfaceMouseenterHandler);\n      surface.unbind(\"mouseleave\", this._surfaceMouseleaveHandler);\n      surface.destroy();\n      this.surface = null;\n    }\n  };\n  Chart.prototype._destroySelections = function _destroySelections() {\n    var selections = this._selections;\n    if (selections) {\n      while (selections.length > 0) {\n        selections.shift().destroy();\n      }\n    }\n  };\n  Chart.prototype._destroyView = function _destroyView() {\n    var model = this._model;\n    if (model) {\n      model.destroy();\n      this._model = null;\n    }\n    this._unsetActivePoint();\n    this._destroySelections();\n    if (this._tooltip) {\n      this._tooltip.destroy();\n    }\n    if (this._highlight) {\n      this._highlight.destroy();\n    }\n    if (this._zoomSelection) {\n      this._zoomSelection.destroy();\n      delete this._zoomSelection;\n    }\n    if (this._pannable) {\n      this._pannable.destroy();\n      delete this._pannable;\n    }\n    if (this._mousewheelZoom) {\n      this._mousewheelZoom.destroy();\n      delete this._mousewheelZoom;\n    }\n  };\n  return Chart;\n}(Class);\nfunction resolveAxisAliases(options) {\n  var aliases = AXIS_NAMES;\n  for (var idx = 0; idx < aliases.length; idx++) {\n    var alias = aliases[idx] + \"Axes\";\n    if (options[alias]) {\n      options[aliases[idx] + \"Axis\"] = options[alias];\n      delete options[alias];\n    }\n  }\n}\nfunction pointByCategoryName(points, name) {\n  if (points) {\n    for (var idx = 0; idx < points.length; idx++) {\n      if (points[idx].category === name) {\n        return [points[idx]];\n      }\n    }\n  }\n}\nfunction applyAxisDefaults(options, themeOptions) {\n  var themeAxisDefaults = (themeOptions || {}).axisDefaults || {};\n  var axisName, axisDefaults, axes;\n  function mapAxisOptions(axisOptions) {\n    var axisColor = (axisOptions || {}).color || axisDefaults.color;\n    var result = deepExtend({}, themeAxisDefaults, themeAxisDefaults[axisName], axisDefaults, axisDefaults[axisName], {\n      line: {\n        color: axisColor\n      },\n      labels: {\n        color: axisColor\n      },\n      title: {\n        color: axisColor\n      }\n    }, axisOptions);\n    delete result[axisName];\n    return result;\n  }\n  for (var idx = 0; idx < AXIS_NAMES.length; idx++) {\n    axisName = AXIS_NAMES[idx] + \"Axis\";\n    axisDefaults = options.axisDefaults || {};\n    axes = [].concat(options[axisName]);\n    axes = axes.map(mapAxisOptions);\n    options[axisName] = axes.length > 1 ? axes : axes[0];\n  }\n}\nfunction applySeriesDefaults(options, themeOptions) {\n  var series = options.series;\n  var seriesLength = series.length;\n  var seriesDefaults = options.seriesDefaults;\n  var commonDefaults = deepExtend({}, options.seriesDefaults);\n  var themeSeriesDefaults = themeOptions ? deepExtend({}, themeOptions.seriesDefaults) : {};\n  var commonThemeDefaults = deepExtend({}, themeSeriesDefaults);\n  cleanupNestedSeriesDefaults(commonDefaults);\n  cleanupNestedSeriesDefaults(commonThemeDefaults);\n  for (var i = 0; i < seriesLength; i++) {\n    var seriesType = series[i].type || options.seriesDefaults.type;\n    var baseOptions = deepExtend({\n      data: []\n    }, commonThemeDefaults, themeSeriesDefaults[seriesType], {\n      tooltip: options.tooltip\n    }, commonDefaults, seriesDefaults[seriesType]);\n    series[i]._defaults = baseOptions;\n    series[i] = deepExtend({}, baseOptions, series[i]);\n    series[i].data = series[i].data || [];\n  }\n}\nfunction cleanupNestedSeriesDefaults(seriesDefaults) {\n  delete seriesDefaults.bar;\n  delete seriesDefaults.column;\n  delete seriesDefaults.rangeColumn;\n  delete seriesDefaults.line;\n  delete seriesDefaults.verticalLine;\n  delete seriesDefaults.pie;\n  delete seriesDefaults.donut;\n  delete seriesDefaults.area;\n  delete seriesDefaults.verticalArea;\n  delete seriesDefaults.scatter;\n  delete seriesDefaults.scatterLine;\n  delete seriesDefaults.bubble;\n  delete seriesDefaults.candlestick;\n  delete seriesDefaults.ohlc;\n  delete seriesDefaults.boxPlot;\n  delete seriesDefaults.bullet;\n  delete seriesDefaults.verticalBullet;\n  delete seriesDefaults.polarArea;\n  delete seriesDefaults.polarLine;\n  delete seriesDefaults.radarArea;\n  delete seriesDefaults.radarLine;\n  delete seriesDefaults.waterfall;\n}\nfunction axisRanges(axes) {\n  var ranges = {};\n  for (var i = 0; i < axes.length; i++) {\n    var axis = axes[i];\n    var axisName = axis.options.name;\n    if (axisName) {\n      ranges[axisName] = axis.range();\n    }\n  }\n  return ranges;\n}\nfunction sortDates(dates, comparer) {\n  if (comparer === void 0) comparer = dateComparer;\n  for (var i = 1, length = dates.length; i < length; i++) {\n    if (comparer(dates[i], dates[i - 1]) < 0) {\n      dates.sort(comparer);\n      break;\n    }\n  }\n  return dates;\n}\nfunction uniqueDates(srcDates, comparer) {\n  if (comparer === void 0) comparer = dateComparer;\n  var dates = sortDates(srcDates, comparer);\n  var length = dates.length;\n  var result = length > 0 ? [dates[0]] : [];\n  for (var i = 1; i < length; i++) {\n    if (comparer(dates[i], last(result)) !== 0) {\n      result.push(dates[i]);\n    }\n  }\n  return result;\n}\nfunction transpose(rows) {\n  var rowCount = rows.length;\n  var result = [];\n  for (var rowIx = 0; rowIx < rowCount; rowIx++) {\n    var row = rows[rowIx];\n    var colCount = row.length;\n    for (var colIx = 0; colIx < colCount; colIx++) {\n      result[colIx] = result[colIx] || [];\n      result[colIx].push(row[colIx]);\n    }\n  }\n  return result;\n}\nvar DATA_FIELDS = ['data', 'categories'];\nfunction clearMissingValues(originalOptions, options) {\n  for (var field in options) {\n    if (!inArray(field, DATA_FIELDS) && options.hasOwnProperty(field)) {\n      var fieldValue = options[field];\n      var originalValue = originalOptions[field];\n      if (defined(originalValue)) {\n        var nullValue = fieldValue === null;\n        if (nullValue || !defined(fieldValue)) {\n          delete originalOptions[field];\n          if (nullValue) {\n            delete options[field];\n          }\n        } else if (originalValue && isObject(fieldValue)) {\n          if (isObject(originalValue)) {\n            clearMissingValues(originalValue, fieldValue);\n          }\n        }\n      }\n    }\n  }\n}\nfunction triggerPaneRender(panes) {\n  for (var idx = 0; idx < panes.length; idx++) {\n    panes[idx].notifyRender();\n  }\n}\nsetDefaultOptions(Chart, {\n  renderAs: \"\",\n  chartArea: {},\n  legend: {\n    visible: true,\n    labels: {}\n  },\n  categoryAxis: {},\n  seriesDefaults: {\n    type: COLUMN,\n    data: [],\n    highlight: {\n      visible: true\n    },\n    labels: {},\n    negativeValues: {\n      visible: false\n    }\n  },\n  series: [],\n  seriesColors: null,\n  tooltip: {\n    visible: false\n  },\n  transitions: true,\n  valueAxis: {},\n  plotArea: {},\n  title: {},\n  xAxis: {},\n  yAxis: {},\n  panes: [{}],\n  pannable: false,\n  zoomable: false\n});\nexport default Chart;","map":null,"metadata":{},"sourceType":"module"}
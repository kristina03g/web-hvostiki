{"ast":null,"code":"import Axis from './axis';\nimport AxisLabel from './axis-label';\nimport { BLACK, COORD_PRECISION, DEFAULT_PRECISION, X, Y } from '../common/constants';\nimport { defined, isNumber, last, limitValue, round, setDefaultOptions, valueOrDefault, HashMap } from '../common';\nimport { dateEquals } from '../date-utils';\nvar MIN_CATEGORY_POINTS_RANGE = 0.01;\nvar MIN_CATEGORY_RANGE = 0.1;\nfunction indexOf(value, arr) {\n  if (value instanceof Date) {\n    var length = arr.length;\n    for (var idx = 0; idx < length; idx++) {\n      if (dateEquals(arr[idx], value)) {\n        return idx;\n      }\n    }\n    return -1;\n  }\n  return arr.indexOf(value);\n}\nvar CategoryAxis = function (Axis) {\n  function CategoryAxis() {\n    Axis.apply(this, arguments);\n  }\n  if (Axis) CategoryAxis.__proto__ = Axis;\n  CategoryAxis.prototype = Object.create(Axis && Axis.prototype);\n  CategoryAxis.prototype.constructor = CategoryAxis;\n  CategoryAxis.prototype.initFields = function initFields() {\n    this._ticks = {};\n  };\n  CategoryAxis.prototype.categoriesHash = function categoriesHash() {\n    return \"\";\n  };\n  CategoryAxis.prototype.clone = function clone() {\n    var copy = new CategoryAxis(Object.assign({}, this.options, {\n      categories: this.options.srcCategories\n    }), this.chartService);\n    copy.createLabels();\n    return copy;\n  };\n  CategoryAxis.prototype.initUserOptions = function initUserOptions(options) {\n    var categories = options.categories || [];\n    var definedMin = defined(options.min);\n    var definedMax = defined(options.max);\n    options.srcCategories = options.categories = categories;\n    if ((definedMin || definedMax) && categories.length) {\n      var min = definedMin ? Math.floor(options.min) : 0;\n      var max;\n      if (definedMax) {\n        max = options.justified ? Math.floor(options.max) + 1 : Math.ceil(options.max);\n      } else {\n        max = categories.length;\n      }\n      options.categories = options.categories.slice(min, max);\n    }\n    return options;\n  };\n  CategoryAxis.prototype.rangeIndices = function rangeIndices() {\n    var options = this.options;\n    var length = options.categories.length || 1;\n    var min = isNumber(options.min) ? options.min % 1 : 0;\n    var max;\n    if (isNumber(options.max) && options.max % 1 !== 0 && options.max < this.totalRange().max) {\n      max = length - (1 - options.max % 1);\n    } else {\n      max = length - (options.justified ? 1 : 0);\n    }\n    return {\n      min: min,\n      max: max\n    };\n  };\n  CategoryAxis.prototype.totalRangeIndices = function totalRangeIndices(limit) {\n    var options = this.options;\n    var min = isNumber(options.min) ? options.min : 0;\n    var max;\n    if (isNumber(options.max)) {\n      max = options.max;\n    } else if (isNumber(options.min)) {\n      max = min + options.categories.length;\n    } else {\n      max = this.totalRange().max || 1;\n    }\n    if (limit) {\n      var totalRange = this.totalRange();\n      min = limitValue(min, 0, totalRange.max);\n      max = limitValue(max, 0, totalRange.max);\n    }\n    return {\n      min: min,\n      max: max\n    };\n  };\n  CategoryAxis.prototype.range = function range() {\n    var options = this.options;\n    var min = isNumber(options.min) ? options.min : 0;\n    var max = isNumber(options.max) ? options.max : this.totalRange().max;\n    return {\n      min: min,\n      max: max\n    };\n  };\n  CategoryAxis.prototype.roundedRange = function roundedRange() {\n    return this.range();\n  };\n  CategoryAxis.prototype.totalRange = function totalRange() {\n    var options = this.options;\n    return {\n      min: 0,\n      max: Math.max(this._seriesMax || 0, options.srcCategories.length) - (options.justified ? 1 : 0)\n    };\n  };\n  CategoryAxis.prototype.scaleOptions = function scaleOptions() {\n    var ref = this.rangeIndices();\n    var min = ref.min;\n    var max = ref.max;\n    var lineBox = this.lineBox();\n    var size = this.options.vertical ? lineBox.height() : lineBox.width();\n    var scale = size / (max - min || 1);\n    return {\n      scale: scale * (this.options.reverse ? -1 : 1),\n      box: lineBox,\n      min: min,\n      max: max\n    };\n  };\n  CategoryAxis.prototype.arrangeLabels = function arrangeLabels() {\n    Axis.prototype.arrangeLabels.call(this);\n    this.hideOutOfRangeLabels();\n  };\n  CategoryAxis.prototype.hideOutOfRangeLabels = function hideOutOfRangeLabels() {\n    var ref = this;\n    var box = ref.box;\n    var labels = ref.labels;\n    if (labels.length > 0) {\n      var valueAxis = this.options.vertical ? Y : X;\n      var start = box[valueAxis + 1];\n      var end = box[valueAxis + 2];\n      var firstLabel = labels[0];\n      var lastLabel = last(labels);\n      if (firstLabel.box[valueAxis + 1] > end || firstLabel.box[valueAxis + 2] < start) {\n        firstLabel.options.visible = false;\n      }\n      if (lastLabel.box[valueAxis + 1] > end || lastLabel.box[valueAxis + 2] < start) {\n        lastLabel.options.visible = false;\n      }\n    }\n  };\n  CategoryAxis.prototype.getMajorTickPositions = function getMajorTickPositions() {\n    return this.getTicks().majorTicks;\n  };\n  CategoryAxis.prototype.getMinorTickPositions = function getMinorTickPositions() {\n    return this.getTicks().minorTicks;\n  };\n  CategoryAxis.prototype.getLabelsTickPositions = function getLabelsTickPositions() {\n    return this.getTicks().labelTicks;\n  };\n  CategoryAxis.prototype.tickIndices = function tickIndices(stepSize) {\n    var ref = this.rangeIndices();\n    var min = ref.min;\n    var max = ref.max;\n    var limit = Math.ceil(max);\n    var current = Math.floor(min);\n    var indices = [];\n    while (current <= limit) {\n      indices.push(current);\n      current += stepSize;\n    }\n    return indices;\n  };\n  CategoryAxis.prototype.getTickPositions = function getTickPositions(stepSize) {\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var reverse = ref.reverse;\n    var ref$1 = this.scaleOptions();\n    var scale = ref$1.scale;\n    var box = ref$1.box;\n    var min = ref$1.min;\n    var pos = box[(vertical ? Y : X) + (reverse ? 2 : 1)];\n    var indices = this.tickIndices(stepSize);\n    var positions = [];\n    for (var idx = 0; idx < indices.length; idx++) {\n      positions.push(pos + round(scale * (indices[idx] - min), COORD_PRECISION));\n    }\n    return positions;\n  };\n  CategoryAxis.prototype.getTicks = function getTicks() {\n    var options = this.options;\n    var cache = this._ticks;\n    var range = this.rangeIndices();\n    var lineBox = this.lineBox();\n    var hash = lineBox.getHash() + range.min + \",\" + range.max + options.reverse + options.justified;\n    if (cache._hash !== hash) {\n      var hasMinor = options.minorTicks.visible || options.minorGridLines.visible;\n      cache._hash = hash;\n      cache.labelTicks = this.getTickPositions(1);\n      cache.majorTicks = this.filterOutOfRangePositions(cache.labelTicks, lineBox);\n      cache.minorTicks = hasMinor ? this.filterOutOfRangePositions(this.getTickPositions(0.5), lineBox) : [];\n    }\n    return cache;\n  };\n  CategoryAxis.prototype.filterOutOfRangePositions = function filterOutOfRangePositions(positions, lineBox) {\n    if (!positions.length) {\n      return positions;\n    }\n    var axis = this.options.vertical ? Y : X;\n    var inRange = function inRange(position) {\n      return lineBox[axis + 1] <= position && position <= lineBox[axis + 2];\n    };\n    var end = positions.length - 1;\n    var startIndex = 0;\n    while (!inRange(positions[startIndex]) && startIndex <= end) {\n      startIndex++;\n    }\n    var endIndex = end;\n    while (!inRange(positions[endIndex]) && endIndex >= 0) {\n      endIndex--;\n    }\n    return positions.slice(startIndex, endIndex + 1);\n  };\n  CategoryAxis.prototype.lineInfo = function lineInfo() {\n    var ref = this.options;\n    var vertical = ref.vertical;\n    var reverse = ref.reverse;\n    var lineBox = this.lineBox();\n    var lineSize = vertical ? lineBox.height() : lineBox.width();\n    var axis = vertical ? Y : X;\n    var axisDir = reverse ? -1 : 1;\n    var startEdge = axisDir === 1 ? 1 : 2;\n    var axisOrigin = axis + startEdge.toString();\n    var lineStart = lineBox[axisOrigin];\n    return {\n      axis: axis,\n      axisOrigin: axisOrigin,\n      axisDir: axisDir,\n      lineBox: lineBox,\n      lineSize: lineSize,\n      lineStart: lineStart\n    };\n  };\n  CategoryAxis.prototype.lineDir = function lineDir() {\n    /*\n     *  Category axis line direction:\n     *    * Vertical: down.\n     *    * Horizontal: right.\n     */\n\n    var ref = this.options;\n    var reverse = ref.reverse;\n    return reverse ? -1 : 1;\n  };\n\n  // TODO: Rename to slotBox, valueSlot, slotByIndex?\n  CategoryAxis.prototype.getSlot = function getSlot(from, to, limit) {\n    var options = this.options;\n    var reverse = options.reverse;\n    var justified = options.justified;\n    var ref = this.scaleOptions();\n    var scale = ref.scale;\n    var box = ref.box;\n    var min = ref.min;\n    var ref$1 = this.lineInfo();\n    var valueAxis = ref$1.axis;\n    var lineStart = ref$1.lineStart;\n    var slotBox = box.clone();\n    var singleSlot = !defined(to);\n    var start = valueOrDefault(from, 0);\n    var end = valueOrDefault(to, start);\n    end = Math.max(end - 1, start);\n\n    // Fixes transient bug caused by iOS 6.0 JIT\n    // (one can never be too sure)\n    end = Math.max(start, end);\n    var p1 = lineStart + (start - min) * scale;\n    var p2 = lineStart + (end + 1 - min) * scale;\n    if (singleSlot && justified) {\n      p2 = p1;\n    }\n    if (limit) {\n      p1 = limitValue(p1, box[valueAxis + 1], box[valueAxis + 2]);\n      p2 = limitValue(p2, box[valueAxis + 1], box[valueAxis + 2]);\n    }\n    slotBox[valueAxis + 1] = reverse ? p2 : p1;\n    slotBox[valueAxis + 2] = reverse ? p1 : p2;\n    return slotBox;\n  };\n  CategoryAxis.prototype.limitSlot = function limitSlot(slot) {\n    var vertical = this.options.vertical;\n    var valueAxis = vertical ? Y : X;\n    var lineBox = this.lineBox();\n    var limittedSlot = slot.clone();\n    limittedSlot[valueAxis + 1] = limitValue(slot[valueAxis + 1], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n    limittedSlot[valueAxis + 2] = limitValue(slot[valueAxis + 2], lineBox[valueAxis + 1], lineBox[valueAxis + 2]);\n    return limittedSlot;\n  };\n  CategoryAxis.prototype.slot = function slot(from, to, limit) {\n    var min = Math.floor(this.options.min || 0);\n    var start = from;\n    var end = to;\n    if (typeof start === \"string\") {\n      start = this.categoryIndex(start);\n    } else if (isNumber(start)) {\n      start -= min;\n    }\n    if (typeof end === \"string\") {\n      end = this.categoryIndex(end);\n    } else if (isNumber(end)) {\n      end -= min;\n    }\n    return Axis.prototype.slot.call(this, start, end, limit);\n  };\n  CategoryAxis.prototype.pointCategoryIndex = function pointCategoryIndex(point) {\n    var ref = this.options;\n    var reverse = ref.reverse;\n    var justified = ref.justified;\n    var vertical = ref.vertical;\n    var valueAxis = vertical ? Y : X;\n    var ref$1 = this.scaleOptions();\n    var scale = ref$1.scale;\n    var box = ref$1.box;\n    var min = ref$1.min;\n    var max = ref$1.max;\n    var startValue = reverse ? max : min;\n    var lineStart = box[valueAxis + 1];\n    var lineEnd = box[valueAxis + 2];\n    var pos = point[valueAxis];\n    if (pos < lineStart || pos > lineEnd) {\n      return null;\n    }\n    var value = startValue + (pos - lineStart) / scale;\n    var diff = value % 1;\n    if (justified) {\n      value = Math.round(value);\n    } else if (diff === 0 && value > 0) {\n      value--;\n    }\n    return Math.floor(value);\n  };\n  CategoryAxis.prototype.getCategory = function getCategory(point) {\n    var index = this.pointCategoryIndex(point);\n    if (index === null) {\n      return null;\n    }\n    return this.options.categories[index];\n  };\n  CategoryAxis.prototype.categoryIndex = function categoryIndex(value) {\n    return this.totalIndex(value) - Math.floor(this.options.min || 0);\n  };\n  CategoryAxis.prototype.categoryAt = function categoryAt(index, total) {\n    var options = this.options;\n    return (total ? options.srcCategories : options.categories)[index];\n  };\n  CategoryAxis.prototype.categoriesCount = function categoriesCount() {\n    return (this.options.categories || []).length;\n  };\n  CategoryAxis.prototype.translateRange = function translateRange(delta) {\n    var options = this.options;\n    var lineBox = this.lineBox();\n    var size = options.vertical ? lineBox.height() : lineBox.width();\n    var range = options.categories.length;\n    var scale = size / range;\n    var offset = round(delta / scale, DEFAULT_PRECISION);\n    return {\n      min: offset,\n      max: range + offset\n    };\n  };\n  CategoryAxis.prototype.scaleRange = function scaleRange(scale, cursor) {\n    var position = Math.abs(this.pointOffset(cursor));\n    var rangeIndices = this.totalRangeIndices();\n    var range = rangeIndices.max - rangeIndices.min;\n    var delta = this.scaleToDelta(scale, range);\n    var minDelta = position * delta;\n    var maxDelta = (1 - position) * delta;\n    var min = rangeIndices.min + minDelta;\n    var max = rangeIndices.max - maxDelta;\n    if (max - min < MIN_CATEGORY_RANGE) {\n      max = min + MIN_CATEGORY_RANGE;\n    }\n    return {\n      min: min,\n      max: max\n    };\n  };\n  CategoryAxis.prototype.zoomRange = function zoomRange(scale, cursor) {\n    var ref = this.totalRange();\n    var totalMin = ref.min;\n    var totalMax = ref.max;\n    var range = this.scaleRange(scale, cursor);\n    return {\n      min: limitValue(range.min, totalMin, totalMax),\n      max: limitValue(range.max, totalMin, totalMax)\n    };\n  };\n  CategoryAxis.prototype.labelsCount = function labelsCount() {\n    var labelsRange = this.labelsRange();\n    return labelsRange.max - labelsRange.min;\n  };\n  CategoryAxis.prototype.labelsRange = function labelsRange() {\n    var options = this.options;\n    var justified = options.justified;\n    var labelOptions = options.labels;\n    var ref = this.totalRangeIndices(true);\n    var min = ref.min;\n    var max = ref.max;\n    var start = Math.floor(min);\n    if (!justified) {\n      min = Math.floor(min);\n      max = Math.ceil(max);\n    } else {\n      min = Math.ceil(min);\n      max = Math.floor(max);\n    }\n    var skip;\n    if (min > labelOptions.skip) {\n      skip = labelOptions.skip + labelOptions.step * Math.ceil((min - labelOptions.skip) / labelOptions.step);\n    } else {\n      skip = labelOptions.skip;\n    }\n    return {\n      min: skip - start,\n      max: (options.categories.length ? max + (justified ? 1 : 0) : 0) - start\n    };\n  };\n  CategoryAxis.prototype.createAxisLabel = function createAxisLabel(index, labelOptions, labelContext) {\n    var options = this.options;\n    var dataItem = options.dataItems ? options.dataItems[index] : null;\n    var category = valueOrDefault(options.categories[index], \"\");\n    labelContext.dataItem = dataItem;\n    var text = this.axisLabelText(category, labelOptions, labelContext);\n    return new AxisLabel(category, text, index, dataItem, labelOptions);\n  };\n  CategoryAxis.prototype.shouldRenderNote = function shouldRenderNote(value) {\n    var range = this.totalRangeIndices();\n    return Math.floor(range.min) <= value && value <= Math.ceil(range.max);\n  };\n  CategoryAxis.prototype.noteSlot = function noteSlot(value) {\n    var options = this.options;\n    var index = value - Math.floor(options.min || 0);\n    return this.getSlot(index);\n  };\n  CategoryAxis.prototype.arrangeNotes = function arrangeNotes() {\n    Axis.prototype.arrangeNotes.call(this);\n    this.hideOutOfRangeNotes();\n  };\n  CategoryAxis.prototype.hideOutOfRangeNotes = function hideOutOfRangeNotes() {\n    var ref = this;\n    var notes = ref.notes;\n    var box = ref.box;\n    if (notes && notes.length) {\n      var valueAxis = this.options.vertical ? Y : X;\n      var start = box[valueAxis + 1];\n      var end = box[valueAxis + 2];\n      for (var idx = 0; idx < notes.length; idx++) {\n        var note = notes[idx];\n        if (note.box && (end < note.box[valueAxis + 1] || note.box[valueAxis + 2] < start)) {\n          note.hide();\n        }\n      }\n    }\n  };\n  CategoryAxis.prototype.pan = function pan(delta) {\n    var range = this.totalRangeIndices(true);\n    var ref = this.scaleOptions();\n    var scale = ref.scale;\n    var offset = round(delta / scale, DEFAULT_PRECISION);\n    var totalRange = this.totalRange();\n    var min = range.min + offset;\n    var max = range.max + offset;\n    return this.limitRange(min, max, 0, totalRange.max, offset);\n  };\n  CategoryAxis.prototype.pointsRange = function pointsRange(start, end) {\n    var ref = this.options;\n    var reverse = ref.reverse;\n    var vertical = ref.vertical;\n    var valueAxis = vertical ? Y : X;\n    var range = this.totalRangeIndices(true);\n    var ref$1 = this.scaleOptions();\n    var scale = ref$1.scale;\n    var box = ref$1.box;\n    var lineStart = box[valueAxis + (reverse ? 2 : 1)];\n    var diffStart = start[valueAxis] - lineStart;\n    var diffEnd = end[valueAxis] - lineStart;\n    var min = range.min + diffStart / scale;\n    var max = range.min + diffEnd / scale;\n    var rangeMin = Math.min(min, max);\n    var rangeMax = Math.max(min, max);\n    if (rangeMax - rangeMin >= MIN_CATEGORY_POINTS_RANGE) {\n      return {\n        min: rangeMin,\n        max: rangeMax\n      };\n    }\n  };\n  CategoryAxis.prototype.valueRange = function valueRange() {\n    return this.range();\n  };\n  CategoryAxis.prototype.totalIndex = function totalIndex(value) {\n    var options = this.options;\n    var index = this._categoriesMap ? this._categoriesMap.get(value) : indexOf(value, options.srcCategories);\n    return index;\n  };\n  CategoryAxis.prototype.currentRangeIndices = function currentRangeIndices() {\n    var options = this.options;\n    var min = 0;\n    if (isNumber(options.min)) {\n      min = Math.floor(options.min);\n    }\n    var max;\n    if (isNumber(options.max)) {\n      max = options.justified ? Math.floor(options.max) : Math.ceil(options.max) - 1;\n    } else {\n      max = this.totalCount() - 1;\n    }\n    return {\n      min: min,\n      max: max\n    };\n  };\n  CategoryAxis.prototype.mapCategories = function mapCategories() {\n    if (!this._categoriesMap) {\n      var map = this._categoriesMap = new HashMap();\n      var srcCategories = this.options.srcCategories;\n      for (var idx = 0; idx < srcCategories.length; idx++) {\n        map.set(srcCategories[idx], idx);\n      }\n    }\n  };\n  CategoryAxis.prototype.totalCount = function totalCount() {\n    return Math.max(this.options.srcCategories.length, this._seriesMax || 0);\n  };\n  return CategoryAxis;\n}(Axis);\nsetDefaultOptions(CategoryAxis, {\n  type: \"category\",\n  vertical: false,\n  majorGridLines: {\n    visible: false,\n    width: 1,\n    color: BLACK\n  },\n  labels: {\n    zIndex: 1\n  },\n  justified: false,\n  _deferLabels: true\n});\nexport default CategoryAxis;","map":null,"metadata":{},"sourceType":"module"}
{"ast":null,"code":"import Group from '../shapes/group';\nimport Point from '../geometry/point';\nimport { Observable } from '../common';\nimport { eventElement, eventCoordinates, elementPadding, elementScale, elementSize, elementOffset } from '../util';\nvar events = [\"click\", \"mouseenter\", \"mouseleave\", \"mousemove\", \"resize\"];\nvar Surface = function (Observable) {\n  function Surface(element, options) {\n    Observable.call(this);\n    this.options = Object.assign({}, options);\n    this.element = element;\n    this.element._kendoExportVisual = this.exportVisual.bind(this);\n    this._click = this._handler(\"click\");\n    this._mouseenter = this._handler(\"mouseenter\");\n    this._mouseleave = this._handler(\"mouseleave\");\n    this._mousemove = this._handler(\"mousemove\");\n    this._visual = new Group();\n    elementSize(element, this.options);\n    this.bind(events, this.options);\n    this._enableTracking();\n  }\n  if (Observable) Surface.__proto__ = Observable;\n  Surface.prototype = Object.create(Observable && Observable.prototype);\n  Surface.prototype.constructor = Surface;\n  Surface.prototype.draw = function draw(element) {\n    this._visual.children.push(element);\n  };\n  Surface.prototype.clear = function clear() {\n    this._visual.children = [];\n  };\n  Surface.prototype.destroy = function destroy() {\n    this._visual = null;\n    this.element._kendoExportVisual = null;\n    this.unbind();\n  };\n  Surface.prototype.eventTarget = function eventTarget(e) {\n    var this$1 = this;\n    var domNode = eventElement(e);\n    var node;\n    while (!node && domNode) {\n      node = domNode._kendoNode;\n      if (domNode === this$1.element) {\n        break;\n      }\n      domNode = domNode.parentElement;\n    }\n    if (node) {\n      return node.srcElement;\n    }\n  };\n  Surface.prototype.exportVisual = function exportVisual() {\n    return this._visual;\n  };\n  Surface.prototype.getSize = function getSize() {\n    return elementSize(this.element);\n  };\n  Surface.prototype.currentSize = function currentSize(size) {\n    if (size) {\n      this._size = size;\n    } else {\n      return this._size;\n    }\n  };\n  Surface.prototype.setSize = function setSize(size) {\n    elementSize(this.element, size);\n    this.currentSize(size);\n    this._resize();\n  };\n  Surface.prototype.resize = function resize(force) {\n    var size = this.getSize();\n    var currentSize = this.currentSize();\n    if (force || (size.width > 0 || size.height > 0) && (!currentSize || size.width !== currentSize.width || size.height !== currentSize.height)) {\n      this.currentSize(size);\n      this._resize(size, force);\n      this.trigger(\"resize\", size);\n    }\n  };\n  Surface.prototype.size = function size(value) {\n    if (!value) {\n      return this.getSize();\n    }\n    this.setSize(value);\n  };\n  Surface.prototype.suspendTracking = function suspendTracking() {\n    this._suspendedTracking = true;\n  };\n  Surface.prototype.resumeTracking = function resumeTracking() {\n    this._suspendedTracking = false;\n  };\n  Surface.prototype._enableTracking = function _enableTracking() {};\n  Surface.prototype._resize = function _resize() {};\n  Surface.prototype._handler = function _handler(eventName) {\n    var this$1 = this;\n    return function (e) {\n      var node = this$1.eventTarget(e);\n      if (node && !this$1._suspendedTracking) {\n        this$1.trigger(eventName, {\n          element: node,\n          originalEvent: e,\n          type: eventName\n        });\n      }\n    };\n  };\n  Surface.prototype._elementOffset = function _elementOffset() {\n    var element = this.element;\n    var padding = elementPadding(element);\n    var ref = elementOffset(element);\n    var left = ref.left;\n    var top = ref.top;\n    return {\n      left: left + padding.left,\n      top: top + padding.top\n    };\n  };\n  Surface.prototype._surfacePoint = function _surfacePoint(e) {\n    var offset = this._elementOffset();\n    var coord = eventCoordinates(e);\n    var x = coord.x - offset.left;\n    var y = coord.y - offset.top;\n    var inverseTransform = elementScale(this.element).invert();\n    var point = new Point(x, y).transform(inverseTransform);\n    return point;\n  };\n  return Surface;\n}(Observable);\nexport default Surface;","map":null,"metadata":{},"sourceType":"module"}